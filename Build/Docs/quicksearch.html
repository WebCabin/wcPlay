<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"nodes_node.js.html":{"id":"nodes_node.js.html","title":"Source: nodes/node.js","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Source: nodes/node.js var wcNodeNextID = 0; wcClass.extend('wcNode', 'Node', '', { /** * @class * The foundation class for all nodes.&lt;br&gt; * When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init functions. * * @constructor wcNode * @description * &lt;b&gt;Should be inherited and never constructed directly.&lt;/b&gt; * @param {String} parent - The parent object of this node. * @param {wcPlay~Coordinates} pos - The position of this node in the visual editor. */ init: function(parent, pos) { this.id = ++wcNodeNextID; this.color = '#FFFFFF'; if (!this.name) { this.name = ''; } this._viewportSize = null; this.pos = { x: pos &amp;&amp; pos.x || 0, y: pos &amp;&amp; pos.y || 0, }; this.chain = { entry: [], exit: [], }; this.properties = []; this._meta = { flash: false, flashDelta: 0, color: null, broken: 0, awake: false, dirty: true, threads: [], description: '', details: '', }; this._break = false; this._log = false; this._parent = parent; // Give the node its default properties. this.createProperty(wcNode.PROPERTY_ENABLED, wcPlay.PROPERTY.TOGGLE, true, {description: &quot;Disabled nodes will be treated as if they were not there, all connections will be ignored.&quot;, input: true, output: true}); // this.createProperty(wcNode.PROPERTY.DEBUG_LOG, wcPlay.PROPERTY.TOGGLE, false, {collapsible: true, description: &quot;Output various debugging information about this node.&quot;}); // Add this node to its parent. this._parent &amp;&amp; this._parent.__addNode(this); }, /** * Inherits a new class from this node. * @function wcNode#extend * @param {String} className - The class name for your node, this should be unique between all global class names. * @param {String} displayName - The display name of your node. * @param {String} category - The category to display your node in the editor palette. * @param {Object} classDef - An object that defines your class with all functions and variables. */ /** * Destroys and removes the node. * @function wcNode#destroy */ destroy: function() { this.onDestroying(); // Remove all links. for (var i = 0; i &lt; this.chain.entry.length; ++i) { var item = this.chain.entry[i]; this.disconnectEntry(item.name); } for (var i = 0; i &lt; this.chain.exit.length; ++i) { var item = this.chain.exit[i]; this.disconnectExit(item.name); } for (var i = 0; i &lt; this.properties.length; ++i) { var item = this.properties[i]; this.disconnectInput(item.name); this.disconnectOutput(item.name); } this.reset(); // Remove the node from its parent. this._parent &amp;&amp; this._parent.__removeNode(this); this.onDestroyed(); }, /** * Resets all properties to their initial values. * @function wcNode#reset */ reset: function() { this.onReset(); this.resetThreads(); this._meta.awake = false; this._meta.dirty = true; this._meta.broken = 0; this._meta.paused = false; for (var i = 0; i &lt; this.properties.length; ++i) { this.properties[i].value = this.properties[i].initialValue; } }, /** * Resets only latent running threads. * @function wcNode#resetThreads */ resetThreads: function() { for (var i = 0; i &lt; this._meta.threads.length; ++i) { if (typeof this._meta.threads[i] === 'number') { clearTimeout(this._meta.threads[i]); clearInterval(this._meta.threads[i]); } else if (this._meta.threads[i] instanceof wcNodeTimeoutEvent) { this._meta.threads[i].__clear(); } else if (this._meta.threads[i] instanceof jqXHR) { this._meta.threads[i].abort(); } else if (typeof this._meta.threads[i] === 'function') { this._meta.threads[i](); } } this._meta.threads = []; }, /** * Imports previously [exported]{@link wcNode#export} data to generate this node. * @function wcNode#import * @param {Object} data - The data to import. * @param {Number[]} [idMap] - If supplied, identifies a mapping of old ID's to new ID's, any not found in this list will be unchanged. */ import: function(data, idMap) { this.onImporting(data, idMap); this.id = idMap &amp;&amp; idMap[data.id] || data.id; this.name = data.name, this.color = data.color, this.pos.x = data.pos.x, this.pos.y = data.pos.y, this.debugBreak(data.breakpoint); if (this.id &gt; wcNodeNextID) { wcNodeNextID = this.id; } // Restore property values. for (var i = 0; i &lt; data.properties.length; ++i) { this.initialProperty(data.properties[i].name, data.properties[i].initialValue); this.property(data.properties[i].name, data.properties[i].value); } var engine = this.engine(); if (!engine) { return; } // Re-connect all chains. for (var i = 0; i &lt; data.entryChains.length; ++i) { var chain = data.entryChains[i]; var targetNode = engine.nodeById((idMap &amp;&amp; idMap[chain.outNodeId]) || chain.outNodeId); if (targetNode &amp;&amp; this._parent === targetNode._parent) { this.connectEntry(chain.inName, targetNode, chain.outName); } } for (var i = 0; i &lt; data.exitChains.length; ++i) { var chain = data.exitChains[i]; var targetNode = engine.nodeById((idMap &amp;&amp; idMap[chain.inNodeId]) || chain.inNodeId); if (targetNode &amp;&amp; this._parent === targetNode._parent) { this.connectExit(chain.outName, targetNode, chain.inName); } } for (var i = 0; i &lt; data.inputChains.length; ++i) { var chain = data.inputChains[i]; var targetNode = engine.nodeById((idMap &amp;&amp; idMap[chain.outNodeId]) || chain.outNodeId); if (targetNode &amp;&amp; this._parent === targetNode._parent) { this.connectInput(chain.inName, targetNode, chain.outName); } } for (var i = 0; i &lt; data.outputChains.length; ++i) { var chain = data.outputChains[i]; var targetNode = engine.nodeById((idMap &amp;&amp; idMap[chain.inNodeId]) || chain.inNodeId); if (targetNode &amp;&amp; this._parent === targetNode._parent) { this.connectOutput(chain.outName, targetNode, chain.inName); } } this._meta.dirty = true; this.onImported(data, idMap); }, /** * Exports information about this node as well as all connected chain data so it can be [imported]{@link wcNode#import} later. * @function wcNode#export * @param {Boolean} [minimal] - If true, only the most important data should be exported, this means current values and redundant link connections are omitted. * @returns {Object} - The exported data for this node. */ export: function(minimal) { var data = { className: this.className, id: this.id, name: this.name, color: this.color, pos: { x: this.pos.x, y: this.pos.y }, breakpoint: this._break, properties: this.listProperties(minimal), exitChains: this.listExitChains(), outputChains: this.listOutputChains(), }; // Include additional info if we aren't minimal if (!minimal) { data.entryChains = this.listEntryChains(); data.inputChains = this.listInputChains(); } else { data.entryChains = []; data.inputChains = []; } this.onExport(data, minimal); return data; }, /** * Retrieves the wcPlay engine that owns this node. * @function wcNode#engine * @returns {wcPlay|null} - Either the wcPlay engine, or null if it doesn't belong to one. */ engine: function() { var play = this._parent; while (play &amp;&amp; !(play.instanceOf('wcPlay'))) { play = play._parent; } return play || null; }, /** * Sets, or Gets this node's enabled state. * @function wcNode#enabled * @param {Boolean} [enabled] - If supplied, will assign a new enabled state. * @returns {Boolean} - The current enabled state. */ enabled: function(enabled) { if (enabled !== undefined) { this.property(wcNode.PROPERTY_ENABLED, enabled? true: false); this._meta.dirty = true; } return this.property(wcNode.PROPERTY_ENABLED); }, /** * Gets, or Sets whether this node is paused, or any nodes inside if it is a composite.&lt;br&gt; * When pausing, all {@link wcNode#setTimeout} events are also paused so they don't jump ahead of the debugger. * @function wcNode#paused * @param {Boolean} paused - If supplied, will assign a new paused state. * @returns {Boolean} - Whether this, or inner nodes, are paused. */ paused: function(paused) { if (paused !== undefined) { // Pausing the node. if (paused) { for (var i = 0; i &lt; this._meta.threads.length; ++i) { if (this._meta.threads[i] instanceof wcNodeTimeoutEvent) { this._meta.threads[i].pause(); } } this._meta.paused = true; } else { for (var i = 0; i &lt; this._meta.threads.length; ++i) { if (this._meta.threads[i] instanceof wcNodeTimeoutEvent) { this._meta.threads[i].resume(); } } this._meta.paused = false; } } return this._meta.paused; }, /** * Retrieves whether the node has been broken via breakpoint in the debugger tool. * @function wcNode#isBroken * @returns {Boolean} */ isBroken: function() { return this._meta.broken &gt; 0; }, /** * Sets, or Gets this node's debug log state. * @function wcNode#debugLog * @param {Boolean} [enabled] - If supplied, will assign a new debug log state. * @returns {Boolean} - The current debug log state. */ debugLog: function(enabled) { if (enabled !== undefined) { this._log = enabled? true: false; } var engine = this.engine(); return (!engine || engine.silent())? false: this._log; }, /** * Sets, or Gets this node's debug pause state. * @function wcNode#debugBreak * @param {Boolean} [enabled] - If supplied, will assign a new debug pause state. * @returns {Boolean} - The current debug pause state. */ debugBreak: function(enabled) { if (enabled !== undefined) { this._break = enabled? true: false; } var engine = this.engine(); return (engine &amp;&amp; engine.debugging() &amp;&amp; this._break); }, /** * Gets, or Sets the description for this node. This is usually shown as a tooltip for the node within the editor tool. * @function wcNode#description * @param {String} [description] - If supplied, will assign a new description for this node. * @returns {String} - The current description of this node. */ description: function(description) { if (description !== undefined) { this._meta.description = description; } return this._meta.description; }, /** * Gets, or Sets the very verbose description details for this node. This is usually shown as a popup dialog to further explain the user of the node. * @function wcNode#details * @param {String} [details] - If supplied, will assign a new description details for this node. * @returns {String} - The current description details of this node. */ details: function(details) { if (details !== undefined) { this._meta.details = details; } return this._meta.details; }, /** * Determines whether a search value matches this node. * @function wcNode#search * @param {String} search - The search value. * @returns {Boolean} */ search: function(search) { if (this.type.toLowerCase().indexOf(search) &gt; -1 || this.name.toLowerCase().indexOf(search) &gt; -1) { return true; } return false; }, /** * Utility function for setting a timed event in a way that is compatible with live debugging in the editor tool. * @function wcNode#setTimeout * @param {Function} callback - A callback function to call when the time has elapsed. As an added convenience, 'this' will be the node instance. * @param {Number} delay - The time delay, in milliseconds, to wait before calling the callback function. * @example * onActivated: function(name) { * this._super(name); * * // Now set a timeout to wait for 'Milliseconds' amount of time. * var delay = this.property('milliseconds'); * * // Start a timeout event using the node's built in timeout handler. * this.setTimeout(function() { * this.activateExit('out'); * }, delay); * } */ setTimeout: function(callback, delay) { var timer = new wcNodeTimeoutEvent(this, callback, delay); this.beginThread(timer); if (!this._meta.paused) { timer.resume(); } }, /** * Utility function for setting an interval update in a way that is compatible with live debugging in the editor tool.&lt;br&gt; * &lt;b&gt;Note:&lt;/b&gt; You can call {@link wcNode#resetThreads} if you want to cancel any existing intervals running on your node. * @function wcNode#setInterval * @param {Function} callback - A callback function to call each time the time interval has elapsed. As an added convenience, 'this' will be the node instance. * @param {Number} interval - The time interval, in milliseconds, between each call to callback. * @example * onActivated: function(name) { * var interval = this.property('milliseconds'); * this.resetThreads(); * * this.setInterval(function() { * this.activateExit('out'); * }, interval); * } */ setInterval: function(callback, interval) { function __onInterval() { callback &amp;&amp; callback.call(this); // Really just call the set timeout, over and over. this.setTimeout(__onInterval, interval); }; this.setTimeout(__onInterval, interval); }, /** * Utility function for performing an AJAX request in a way that is compatible with live debugging in the editor tool.&lt;br&gt; * The success, error, and complete callback functions are changed so that the 'this' object is the node instance, or the custom context if you provided a context in your options. * @function wcNode#ajax * @param {String} [url] - Option URL to send the request, if not supplied, it should be provided in the options parameter. * @param {Object} [options] - The options for the request, as described here: {@link http://api.jquery.com/jquery.ajax/}. * @returns {jqXHR} - The jQuery XHR object generated by the ajax request. */ ajax: function(url, options) { if (typeof url === 'object') { options = url; } if (!options) { options = {}; } if (typeof url === 'string') { options.url = url; } var cancelled = false; var self = this; var context = options.context || this; function __wrapCallback(cb, isComplete) { return function() { if (isComplete) { setTimeout(function() { self.finishThread(xhr); }, 0); } if (!cancelled) { cb &amp;&amp; cb.apply(context, arguments); } }; }; options.success = __wrapCallback(options.success); options.error = __wrapCallback(options.error); options.complete = __wrapCallback(options.complete, true); var xhr = $.ajax(options); // Failsafe in case we are running an older version of jQuery which does not yet return the jqXHR object. if (xhr === undefined) { xhr = function() { cancelled = true; } } this.beginThread(xhr); }, /** * If your node takes time to process, call this to begin a thread that will keep the node 'active' until you close the thread with {@link wcNode#finishThread}.&lt;br&gt; * This ensures that, even if a node is executed more than once at the same time, each 'thread' is kept track of individually.&lt;br&gt; * &lt;b&gt;Note:&lt;/b&gt; This is not necessary if your node executes immediately without a timeout. * &lt;b&gt;Also Node:&lt;/b&gt; If using a setTimeout event, it is recommended that you use {@link wcNode#setTimeout} instead. * @function wcNode#beginThread * @param {Number|Function} id - The thread ID, generated by a call to setTimeout, setInterval, or a function to call when we want to force cancel the job. * @returns {Number} - The id that was given {@link wcNode#finishThread}. * @example * onActivated: function(name) { * this._super(name); * * // Always fire the 'out' link immediately. * this.activateExit('out'); * * // Now set a timeout to wait for 'Milliseconds' amount of time. * var self = this; * var delay = this.property('milliseconds'); * * // Start a new thread that will keep the node alive until we are finished. * var thread = this.beginThread(setTimeout(function() { * // Once the time has completed, fire the 'Finished' link and finish our thread. * self.activateExit('finished'); * self.finishThread(thread); * }, delay)); * } */ beginThread: function(id) { this._meta.threads.push(id); this._meta.flash = true; this._meta.awake = true; return id; }, /** * Finishes a previously started thread from {@link wcNode#beginThread}.&lt;br&gt; * &lt;b&gt;Note:&lt;/b&gt; If you do not properly finish a thread that was generated, your node will remain forever in its active state. * @function wcNode#finishThread * @params {Number|Function} id - The thread ID to close, returned to you by the call to {@link wcNode#beginThread}. */ finishThread: function(id) { var index = this._meta.threads.indexOf(id); if (index &gt; -1) { this._meta.threads.splice(index, 1); if (!this._meta.threads.length) { this._meta.awake = false; } } }, /** * Gets, or Sets the current position of the node. * @function wcNode#pos * @param {wcPlay~Coordinates} [pos] - If supplied, will assign a new position for this node. * @returns {wcPlay~Coordinates} - The current position of this node. */ pos: function(pos) { if (pos !== undefined) { this.pos.x = pos.x; this.pos.y = pos.y; this._meta.dirty = true; } return {x: this.pos.x, y: this.pos.y}; }, /** * Creates a new entry link on the node. * @function wcNode#createEntry * @param {String} name - The name of the entry link. * @param {String} [description] - An optional description to display as a tooltip for this link. * @returns {Boolean} - Fails if the entry link name already exists. */ createEntry: function(name, description) { for (var i = 0; i &lt; this.chain.entry.length; ++i) { if (this.chain.entry[i].name === name) { return false; } } this.chain.entry.push({ name: name, active: false, links: [], meta: { flash: false, flashDelta: 0, broken: 0, color: &quot;#000000&quot;, description: description, }, }); this._meta.dirty = true; return true; }, /** * Creates a new exit link on the node. * @function wcNode#createExit * @param {String} name - The name of the exit link. * @param {String} [description] - An optional description to display as a tooltip for this link. * @returns {Boolean} - Fails if the exit link name already exists. */ createExit: function(name, description) { for (var i = 0; i &lt; this.chain.exit.length; ++i) { if (this.chain.exit[i].name === name) { return false; } } this.chain.exit.push({ name: name, links: [], meta: { flash: false, flashDelta: 0, broken: 0, color: &quot;#000000&quot;, description: description, }, }); this._meta.dirty = true; return true; }, /** * Creates a new property. * @function wcNode#createProperty * @param {String} name - The name of the property. * @param {wcPlay.PROPERTY} type - The type of property. * @param {Object} [initialValue] - A initial value for this property when the script starts. * @param {Object} [options] - Additional options for this property, see {@link wcPlay.PROPERTY}. * @returns {Boolean} - Fails if the property does not exist. */ createProperty: function(name, type, initialValue, options) { // Make sure this property doesn't already exist. for (var i = 0; i &lt; this.properties.length; ++i) { if (this.properties[i].name === name) { return false; } } if (initialValue === undefined) { initialValue = 0; } this.properties.push({ name: name, value: initialValue, initialValue: initialValue, type: type, inputs: [], outputs: [], options: options || {}, inputMeta: { flash: false, flashDelta: 0, broken: 0, color: &quot;#000000&quot;, }, outputMeta: { flash: false, flashDelta: 0, broken: 0, color: &quot;#000000&quot;, } }); this._meta.dirty = true; return true; }, /** * Removes an entry link from the node. * @function wcNode#removeEntry * @param {String} name - The name of the entry link to remove. * @returns {Boolean} - Fails if the link does not exist. */ removeEntry: function(name) { for (var i = 0; i &lt; this.chain.entry.length; ++i) { if (this.chain.entry[i].name === name) { if (this.disconnectEntry(name) === wcNode.CONNECT_RESULT.SUCCESS) { this.chain.entry.splice(i, 1); this._meta.dirty = true; return true; } } } return false; }, /** * Removes an exit link from the node. * @function wcNode#removeExit * @param {String} name - The name of the exit link to remove. * @returns {Boolean} - Fails if the link does not exist. */ removeExit: function(name) { for (var i = 0; i &lt; this.chain.exit.length; ++i) { if (this.chain.exit[i].name === name) { if (this.disconnectExit(name) === wcNode.CONNECT_RESULT.SUCCESS) { this.chain.exit.splice(i, 1); this._meta.dirty = true; return true; } } } return false; }, /** * Removes a property from the node. * @function wcNode#removeProperty * @param {String} name - The name of the property to remove. * @returns {Boolean} - Fails if the property does not exist. */ removeProperty: function(name) { for (var i = 0; i &lt; this.properties.length; ++i) { if (this.properties[i].name === name) { if (this.disconnectInput(name) === wcNode.CONNECT_RESULT.SUCCESS &amp;&amp; this.disconnectOutput(name) === wcNode.CONNECT_RESULT.SUCCESS) { this.properties.splice(i, 1); this._meta.dirty = true; return true; } } } return false; }, /** * Renames an entry link on this node while preserving all connected chains. * @function wcNode#renameEntry * @param {String} oldName - The old (current) name of the link. * @param {String} newName - The new name of the link. * @returns {Boolean} - Fails if the new name already exists, or the old name does not. */ renameEntry: function(oldName, newName) { if (!this.createEntry(newName)) { return false; } if (this.createEntry(oldName)) { this.removeEntry(oldName); this.removeEntry(newName); return false; } var chains = this.listEntryChains(oldName); this.removeEntry(oldName); var engine = this.engine(); if (engine) { for (var i = 0; i &lt; chains.length; ++i) { this.connectEntry(newName, engine.nodeById(chains[i].outNodeId), chains[i].outName); } } this._meta.dirty = true; return true; }, /** * Renames an exit link on this node while preserving all connected chains. * @function wcNode#renameExit * @param {String} oldName - The old (current) name of the link. * @param {String} newName - The new name of the link. * @returns {Boolean} - Fails if the new name already exists, or the old name does not. */ renameExit: function(oldName, newName) { if (!this.createExit(newName)) { return false; } if (this.createExit(oldName)) { this.removeExit(oldName); this.removeExit(newName); return false; } var chains = this.listExitChains(oldName); this.removeExit(oldName); var engine = this.engine(); if (engine) { for (var i = 0; i &lt; chains.length; ++i) { this.connectExit(newName, engine.nodeById(chains[i].inNodeId), chains[i].inName); } } this._meta.dirty = true; return true; }, /** * Renames a property on this node while preserving all connected chains. * @function wcNode#renameProperty * @param {String} oldName - The old (current) name of the link. * @param {String} newName - The new name of the link. * @returns {Boolean} - Fails if the new name already exists, or the old name does not. */ renameProperty: function(oldName, newName) { var prop; for (var i = 0; i &lt; this.properties.length; ++i) { if (this.properties[i].name === oldName) { prop = this.properties[i]; } if (this.properties[i].name === newName) { return false; } } if (!prop) { return false; } this.createProperty(newName, prop.type, prop.initialValue, prop.options); this.property(newName, prop.value, false); var inputChains = this.listInputChains(oldName); var outputChains= this.listOutputChains(oldName); this.removeProperty(oldName); var engine = this.engine(); if (engine) { for (var i = 0; i &lt; inputChains.length; ++i) { this.connectInput(newName, engine.nodeById(inputChains[i].outNodeId), inputChains[i].outName); } for (var i = 0; i &lt; outputChains.length; ++i) { this.connectOutput(newName, engine.nodeById(outputChains[i].inNodeId), outputChains[i].inName); } } this._meta.dirty = true; return true; }, /** * Connects an entry link on this node to an exit link of another. * @function wcNode#connectEntry * @param {String} name - The name of the entry link on this node. * @param {wcNode} targetNode - The target node to link to. * @param {String} targetName - The name of the target node's exit link to link to. * @returns {wcNode.CONNECT_RESULT} - The result. */ connectEntry: function(name, targetNode, targetName) { if (!(targetNode &amp;&amp; targetNode.instanceOf('wcNode'))) { return wcNode.CONNECT_RESULT.NOT_FOUND; } var myLink = null; var targetLink = null; // Find my link. for (var i = 0; i &lt; this.chain.entry.length; ++i) { if (this.chain.entry[i].name === name) { myLink = this.chain.entry[i]; break; } } // Find the target link. for (var i = 0; i &lt; targetNode.chain.exit.length; ++i) { if (targetNode.chain.exit[i].name === targetName) { targetLink = targetNode.chain.exit[i]; break; } } if (!myLink || !targetLink) { return wcNode.CONNECT_RESULT.NOT_FOUND; } // Make sure the connection doesn't already exist. for (var i = 0; i &lt; myLink.links.length; ++i) { if (myLink.links[i].node === targetNode &amp;&amp; myLink.links[i].name === targetLink.name) { return wcNode.CONNECT_RESULT.ALREADY_CONNECTED; } } for (var i = 0; i &lt; targetLink.links.length; ++i) { if (targetLink.links[i].node === this &amp;&amp; targetLink.links[i].name === myLink.name) { return wcNode.CONNECT_RESULT.ALREADY_CONNECTED; } } // Now make the connection. myLink.links.push({ name: targetLink.name, node: targetNode, }); targetLink.links.push({ name: myLink.name, node: this, }); // Notify of the connection change. this.onConnect(true, myLink.name, wcNode.LINK_TYPE.ENTRY, targetNode, targetLink.name, wcNode.LINK_TYPE.EXIT); targetNode.onConnect(true, targetLink.name, wcNode.LINK_TYPE.EXIT, this, myLink.name, wcNode.LINK_TYPE.ENTRY); return wcNode.CONNECT_RESULT.SUCCESS; }, /** * Connects an exit link on this node to an entry link of another. * @function wcNode#connectExit * @param {String} name - The name of the exit link on this node. * @param {wcNode} targetNode - The target node to link to. * @param {String} targetName - The name of the target node's entry link to link to. * @returns {wcNode.CONNECT_RESULT} - The result. */ connectExit: function(name, targetNode, targetName) { if (!(targetNode &amp;&amp; targetNode.instanceOf('wcNode'))) { return wcNode.CONNECT_RESULT.NOT_FOUND; } var myLink = null; var targetLink = null; // Find my link. for (var i = 0; i &lt; this.chain.exit.length; ++i) { if (this.chain.exit[i].name === name) { myLink = this.chain.exit[i]; break; } } // Find the target link. for (var i = 0; i &lt; targetNode.chain.entry.length; ++i) { if (targetNode.chain.entry[i].name === targetName) { targetLink = targetNode.chain.entry[i]; break; } } if (!myLink || !targetLink) { return wcNode.CONNECT_RESULT.NOT_FOUND; } // Make sure the connection doesn't already exist. for (var i = 0; i &lt; myLink.links.length; ++i) { if (myLink.links[i].node === targetNode &amp;&amp; myLink.links[i].name === targetLink.name) { return wcNode.CONNECT_RESULT.ALREADY_CONNECTED; } } for (var i = 0; i &lt; targetLink.links.length; ++i) { if (targetLink.links[i].node === this &amp;&amp; targetLink.links[i].name === myLink.name) { return wcNode.CONNECT_RESULT.ALREADY_CONNECTED; } } // Now make the connection. myLink.links.push({ name: targetLink.name, node: targetNode, }); targetLink.links.push({ name: myLink.name, node: this, }); // Notify of the connection change. this.onConnect(true, myLink.name, wcNode.LINK_TYPE.EXIT, targetNode, targetLink.name, wcNode.LINK_TYPE.ENTRY); targetNode.onConnect(true, targetLink.name, wcNode.LINK_TYPE.ENTRY, this, myLink.name, wcNode.LINK_TYPE.EXIT); return wcNode.CONNECT_RESULT.SUCCESS; }, /** * Connects a property input link to a target property output link. * @function wcNode#connectInput * @param {String} name - The name of the property being connected. * @param {wcNode} targetNode - The target node to connect with. * @param {String} targetName - The name of the property on the target node to connect with. * @returns {wcNode.CONNECT_RESULT} - The result. */ connectInput: function(name, targetNode, targetName) { if (!(targetNode &amp;&amp; targetNode.instanceOf('wcNode'))) { return wcNode.CONNECT_RESULT.NOT_FOUND; } var myProperty = null; var targetProperty = null; // Find my property. for (var i = 0; i &lt; this.properties.length; ++i) { if (this.properties[i].name === name) { myProperty = this.properties[i]; break; } } // Find the target property. for (var i = 0; i &lt; targetNode.properties.length; ++i) { if (targetNode.properties[i].name === targetName) { targetProperty = targetNode.properties[i]; break; } } if (!myProperty || !targetProperty) { return wcNode.CONNECT_RESULT.NOT_FOUND; } // Make sure the connection doesn't already exist. for (var i = 0; i &lt; myProperty.inputs.length; ++i) { if (myProperty.inputs[i].node === targetNode &amp;&amp; myProperty.inputs[i].name === targetProperty.name) { return wcNode.CONNECT_RESULT.ALREADY_CONNECTED; } } for (var i = 0; i &lt; targetProperty.outputs.length; ++i) { if (targetProperty.outputs[i].node === this &amp;&amp; targetProperty.outputs[i].name === myProperty.name) { return wcNode.CONNECT_RESULT.ALREADY_CONNECTED; } } // Now make the connection. myProperty.inputs.push({ name: targetProperty.name, node: targetNode, }); targetProperty.outputs.push({ name: myProperty.name, node: this, }); // Notify of the connection change. this.onConnect(true, myProperty.name, wcNode.LINK_TYPE.INPUT, targetNode, targetProperty.name, wcNode.LINK_TYPE.OUTPUT); targetNode.onConnect(true, targetProperty.name, wcNode.LINK_TYPE.OUTPUT, this, myProperty.name, wcNode.LINK_TYPE.INPUT); return wcNode.CONNECT_RESULT.SUCCESS; }, /** * Connects a property output link to a target property input link. * @function wcNode#connectOutput * @param {String} name - The name of the property being connected. * @param {wcNode} targetNode - The target node to connect with. * @param {String} targetName - The name of the property on the target node to connect with. * @returns {wcNode.CONNECT_RESULT} - The result. */ connectOutput: function(name, targetNode, targetName) { if (!(targetNode &amp;&amp; targetNode.instanceOf('wcNode'))) { return wcNode.CONNECT_RESULT.NOT_FOUND; } var myProperty = null; var targetProperty = null; // Find my property. for (var i = 0; i &lt; this.properties.length; ++i) { if (this.properties[i].name === name) { myProperty = this.properties[i]; break; } } // Find the target property. for (var i = 0; i &lt; targetNode.properties.length; ++i) { if (targetNode.properties[i].name === targetName) { targetProperty = targetNode.properties[i]; break; } } if (!myProperty || !targetProperty) { return wcNode.CONNECT_RESULT.NOT_FOUND; } // Make sure the connection doesn't already exist. for (var i = 0; i &lt; myProperty.outputs.length; ++i) { if (myProperty.outputs[i].node === targetNode &amp;&amp; myProperty.outputs[i].name === targetProperty.name) { return wcNode.CONNECT_RESULT.ALREADY_CONNECTED; } } for (var i = 0; i &lt; targetProperty.inputs.length; ++i) { if (targetProperty.inputs[i].node === this &amp;&amp; targetProperty.inputs[i].name === myProperty.name) { return wcNode.CONNECT_RESULT.ALREADY_CONNECTED; } } // Now make the connection. myProperty.outputs.push({ name: targetProperty.name, node: targetNode, }); targetProperty.inputs.push({ name: myProperty.name, node: this, }); // Notify of the connection change. this.onConnect(true, myProperty.name, wcNode.LINK_TYPE.OUTPUT, targetNode, targetProperty.name, wcNode.LINK_TYPE.INPUT); targetNode.onConnect(true, targetProperty.name, wcNode.LINK_TYPE.INPUT, this, myProperty.name, wcNode.LINK_TYPE.OUTPUT); return wcNode.CONNECT_RESULT.SUCCESS; }, /** * Disconnects a chain, or all chains, from an entry link. * @function wcNode#disconnectEntry * @param {String} name - The name of the entry link. * @param {wcNode} [targetNode] - If supplied, will only remove links to the specified target node. * @param {String} [targetName] - If supplied, will only remove links to the specified named exit links. * @returns {wcNode.CONNECT_RESULT} */ disconnectEntry: function(name, targetNode, targetName) { // Find my entry link. var myLink = null; for (var i = 0; i &lt; this.chain.entry.length; ++i) { if (this.chain.entry[i].name === name) { myLink = this.chain.entry[i]; break; } } if (!myLink) { return wcNode.CONNECT_RESULT.NOT_FOUND; } // Iterate through all chained links and disconnect as necessary. for (var i = 0; i &lt; myLink.links.length; ++i) { var targetLink = myLink.links[i]; if ((!targetNode || targetNode === targetLink.node) &amp;&amp; (!targetName || targetName === targetLink.name)) { // Remove this link. myLink.links.splice(i, 1); i--; targetLink.node.disconnectExit(targetLink.name, this, name); } } return wcNode.CONNECT_RESULT.SUCCESS; }, /** * Disconnects a chain, or all chains, from an exit link. * @function wcNode#disconnectExit * @param {String} name - The name of the exit link. * @param {wcNode} [targetNode] - If supplied, will only remove links to the specified target node. * @param {String} [targetName] - If supplied, will only remove links to the specified named entry links. * @returns {wcNode.CONNECT_RESULT} */ disconnectExit: function(name, targetNode, targetName) { // Find my exit link. var myLink = null; for (var i = 0; i &lt; this.chain.exit.length; ++i) { if (this.chain.exit[i].name === name) { myLink = this.chain.exit[i]; break; } } if (!myLink) { return wcNode.CONNECT_RESULT.NOT_FOUND; } // Iterate through all chained links and disconnect as necessary. for (var i = 0; i &lt; myLink.links.length; ++i) { var targetLink = myLink.links[i]; if ((!targetNode || targetNode === targetLink.node) &amp;&amp; (!targetName || targetName === targetLink.name)) { // Remove this link. myLink.links.splice(i, 1); i--; targetLink.node.disconnectEntry(targetLink.name, this, name); } } return wcNode.CONNECT_RESULT.SUCCESS; }, /** * Disconnects a chain, or all chains, from a property input. * @function wcNode#disconnectInput * @param {String} name - The name of the property. * @param {wcNode} [targetNode] - If supplied, will only remove links to the specified target node. * @param {String} [targetName] - If supplied, will only remove links to the specified named property output links. * @returns {wcNode.CONNECT_RESULT} */ disconnectInput: function(name, targetNode, targetName) { // Find my property. var myProperty = null; for (var i = 0; i &lt; this.properties.length; ++i) { if (this.properties[i].name === name) { myProperty = this.properties[i]; break; } } if (!myProperty) { return wcNode.CONNECT_RESULT.NOT_FOUND; } // Iterate through all chained links and disconnect as necessary. for (var i = 0; i &lt; myProperty.inputs.length; ++i) { var targetProperty = myProperty.inputs[i]; if ((!targetNode || targetNode === targetProperty.node) &amp;&amp; (!targetName || targetName === targetProperty.name)) { // Remove this link. myProperty.inputs.splice(i, 1); i--; targetProperty.node.disconnectOutput(targetProperty.name, this, name); } } return wcNode.CONNECT_RESULT.SUCCESS; }, /** * Disconnects a chain, or all chains, from a property output. * @function wcNode#disconnectOutput * @param {String} name - The name of the property. * @param {wcNode} [targetNode] - If supplied, will only remove links to the specified target node. * @param {String} [targetName] - If supplied, will only remove links to the specified named property input links. * @returns {wcNode.CONNECT_RESULT} */ disconnectOutput: function(name, targetNode, targetName) { // Find my property. var myProperty = null; for (var i = 0; i &lt; this.properties.length; ++i) { if (this.properties[i].name === name) { myProperty = this.properties[i]; break; } } if (!myProperty) { return wcNode.CONNECT_RESULT.NOT_FOUND; } // Iterate through all chained links and disconnect as necessary. for (var i = 0; i &lt; myProperty.outputs.length; ++i) { var targetProperty = myProperty.outputs[i]; if ((!targetNode || targetNode === targetProperty.node) &amp;&amp; (!targetName || targetName === targetProperty.name)) { // Remove this link. myProperty.outputs.splice(i, 1); i--; targetProperty.node.disconnectInput(targetProperty.name, this, name); } } return wcNode.CONNECT_RESULT.SUCCESS; }, /** * Activates an entry link and activates this node. * @function wcNode#activateEntry * @param {String} name - The name of the entry link to trigger. * @param {wcNode} fromNode - The node triggering the entry. * @param {String} fromName - The Exit link name. * @returns {Boolean} - Fails if the entry link does not exist. */ activateEntry: function(name, fromNode, fromName) { for (var i = 0; i &lt; this.chain.entry.length; ++i) { if (this.chain.entry[i].name === name) { // Always queue the trigger so execution is not immediate. var engine = this.engine(); engine &amp;&amp; engine.queueNodeEntry(this, this.chain.entry[i].name, fromNode, fromName, false); return true; } } return false; }, /** * Activates an exit link. * @function wcNode#activateExit * @param {String} name - The name of the exit link to trigger. * @returns {Boolean} - Fails if the exit link does not exist. */ activateExit: function(name) { if (!this.enabled()) { return false; } if (this.debugLog()) { console.log('DEBUG: Node &quot;' + this.category + '.' + this.type + (this.name? ' (' + this.name + ')': '') + '&quot; Triggered Exit link &quot;' + name + '&quot;'); } for (var i = 0; i &lt; this.chain.exit.length; ++i) { var exitLink = this.chain.exit[i]; if (exitLink.name === name) { // Activate all entry links chained to this exit. var queued = false; var engine = this.engine(); for (var a = 0; a &lt; exitLink.links.length; ++a) { if (exitLink.links[a].node) { queued = true; exitLink.links[a].node.activateEntry(exitLink.links[a].name, this, name); } } // If we did not queue another node to activate, we should manually flash this link. if (!queued) { this.chain.exit[i].meta.flash = true; this._meta.flash = true; } return true; } } return false; }, /** Gets the options assigned to a property, you may change attributes from here. * @function wcNode#propertyOptions * @param {String} name - The name of the property. * @returns {Object|null} - The options object associated with the property, or null if the property does not exist. */ propertyOptions: function(name) { for (var i = 0; i &lt; this.properties.length; ++i) { var prop = this.properties[i]; if (prop.name === name) { // Assume the user will change options for this property, so make it dirty. this._meta.dirty = true; return prop.options; } } return null; }, /** * Gets, or Sets the value of a property. * @function wcNode#property * @param {String} name - The name of the property. * @param {Object} [value] - If supplied, will assign a new value to the property. * @param {Boolean} [forceOrSilent] - If supplied, true will force the change event to be sent to all chained properties even if this value didn't change while false will force the change to not be chained. * @param {Boolean} [forceUpstream] - Contrary to normal operation, if this is true then the property change will be sent backwards, from this property's input link to any outputs connected to it. * @returns {Object|undefined} - The value of the property, or undefined if not found. */ property: function(name, value, forceOrSilent, forceUpstream) { for (var i = 0; i &lt; this.properties.length; ++i) { var prop = this.properties[i]; if (prop.name === name) { if (value !== undefined) { // Retrieve the current value of the property var oldValue = prop.value; // Apply restrictions to the property based on its type and options supplied. switch (prop.type) { case wcPlay.PROPERTY.TOGGLE: value = value? true: false; break; case wcPlay.PROPERTY.NUMBER: var min = (prop.options.min !== undefined? prop.options.min: -Infinity); var max = (prop.options.max !== undefined? prop.options.max: Infinity); var num = Math.min(max, Math.max(min, parseInt(value))); if (isNaN(num)) { value = Math.min(max, Math.max(min, 0)); } break; case wcPlay.PROPERTY.STRING: var len = prop.options.maxlength; if (len) { value = value.toString().substring(0, len); } break; case wcPlay.PROPERTY.SELECT: var items = prop.options.items; if (typeof items === 'function') { items = items.call(this); } var found = false; if (Array.isArray(items)) { for (var i = 0; i &lt; items.length; ++i) { if (typeof items[i] === 'object') { if (items[i].value == value) { found = true; break; } } else { if (items[i] == value) { found = true; break; } } } } if (!found) { if (!prop.options.hasOwnProperty('allowNone') || prop.options.allowNone) { if (prop.options.hasOwnProperty('noneValue')) { value = prop.options.noneValue; } else { value = ''; } } } break; } var engine = this.engine(); prop.outputMeta.flash = true; if (this.debugBreak() || (engine &amp;&amp; engine.stepping())) { prop.outputMeta.broken++; } // Notify about to change event. if (forceOrSilent || prop.value !== value) { value = this.onPropertyChanging(prop.name, oldValue, value) || value; } if (forceOrSilent || prop.value !== value) { this._meta.dirty = true; prop.value = value; // Notify that the property has changed. this.onPropertyChanged(prop.name, oldValue, value); // Linked properties must sync with their initial values as well. if (prop.options.linked) { this.initialProperty(prop.name, value); } // Now follow any output links and assign the new value to them as well. if (forceOrSilent === undefined || forceOrSilent) { for (a = 0; a &lt; prop.outputs.length; ++a) { prop.outputs[a].node &amp;&amp; prop.outputs[a].node.activateProperty(prop.outputs[a].name, value); } } // Now propagate the change upstream if necessary. if (forceUpstream) { for (a = 0; a &lt; prop.inputs.length; ++a) { prop.inputs[a].node &amp;&amp; prop.inputs[a].node.activateProperty(prop.inputs[a].name, value, true); } } } } return this.onPropertyGet(prop.name) || prop.value; } } }, /** * Gets, or Sets the initial value of a property. * @function wcNode#initialProperty * @param {String} name - The name of the property. * @param {Object} [value] - If supplied, will assign a new default value to the property. * @param {Boolean} [forceOrSilent] - If supplied, true will force the change event to be sent to all chained properties even if this value didn't change while false will force the change to not be chained. * @param {Boolean} [forceUpstream] - Contrary to normal operation, if this is true then the property change will be sent backwards, from this property's input link to any outputs connected to it. * @returns {Object|undefined} - The default value of the property, or undefined if not found. */ initialProperty: function(name, value, forceOrSilent, forceUpstream) { for (var i = 0; i &lt; this.properties.length; ++i) { var prop = this.properties[i]; if (prop.name === name) { if (value !== undefined) { value = this.onInitialPropertyChanging(prop.name, prop.initialValue, value) || value; if (prop.value == prop.initialValue) { this.property(name, value); } var oldValue = prop.initialValue; if (forceOrSilent || prop.initialValue !== value) { this._meta.dirty = true; prop.initialValue = value; // Notify that the property has changed. this.onInitialPropertyChanged(prop.name, oldValue, value); // Linked properties must sync with their initial values as well. if (prop.options.linked) { this.property(prop.name, value); } prop.outputMeta.flash = true; var engine = this.engine(); if (this.debugBreak() || (engine &amp;&amp; engine.stepping())) { prop.outputMeta.broken++; } // Now follow any output links and assign the new value to them as well. if (forceOrSilent === undefined || forceOrSilent) { for (a = 0; a &lt; prop.outputs.length; ++a) { prop.outputs[a].node &amp;&amp; prop.outputs[a].node.initialProperty(prop.outputs[a].name, value); } } // Now propagate the change upstream if necessary. if (forceUpstream) { for (a = 0; a &lt; prop.inputs.length; ++a) { prop.inputs[a].node &amp;&amp; prop.inputs[a].node.initialProperty(prop.inputs[a].name, value, undefined, true); } } } } return this.onInitialPropertyGet(prop.name) || prop.initialValue; } } }, /** * Activates a property that is about to be changed by the output of another property. * @function wcNode#activateProperty * @param {String} name - The name of the property. * @param {Object} value - The new value of the property. * @param {Boolean} [upstream] - If true, the activation was from a property in its output, and we are propagating in reverse. */ activateProperty: function(name, value, upstream) { var engine = this.engine(); if (engine) { engine.queueNodeProperty(this, name, value, upstream); } for (var i = 0; i &lt; this.properties.length; ++i) { var prop = this.properties[i]; if (prop.name === name) { prop.inputMeta.flash = true; if (this.debugBreak() || (engine &amp;&amp; engine.stepping())) { prop.inputMeta.broken++; } } } }, /** * Retrieves a list of all chains connected to an entry link on this node. * @function wcNode#listEntryChains * @param {String} [name] - The entry link, if omitted, all link chains are retrieved. * @param {wcNode[]} [ignoreNodes] - If supplied, will ignore all chains connected to a node in this list. * @returns {wcNode~ChainData[]} - A list of all chains connected to this link, if the link was not found, an empty list is returned. */ listEntryChains: function(name, ignoreNodes) { var result = []; for (var i = 0; i &lt; this.chain.entry.length; ++i) { if (!name || this.chain.entry[i].name === name) { var myLink = this.chain.entry[i]; for (var a = 0; a &lt; myLink.links.length; ++a) { if (!ignoreNodes || ignoreNodes.indexOf(myLink.links[a].node) === -1) { result.push({ inName: myLink.name, inNodeId: this.id, outName: myLink.links[a].name, outNodeId: myLink.links[a].node.id, }); } } } } return result; }, /** * Retrieves a list of all chains connected to an exit link on this node. * @function wcNode#listExitChains * @param {String} [name] - The exit link, if omitted, all link chains are retrieved. * @param {wcNode[]} [ignoreNodes] - If supplied, will ignore all chains connected to a node in this list. * @returns {wcNode~ChainData[]} - A list of all chains connected to this link, if the link was not found, an empty list is returned. */ listExitChains: function(name, ignoreNodes) { var result = []; for (var i = 0; i &lt; this.chain.exit.length; ++i) { if (!name || this.chain.exit[i].name === name) { var myLink = this.chain.exit[i]; for (var a = 0; a &lt; myLink.links.length; ++a) { if (!ignoreNodes || ignoreNodes.indexOf(myLink.links[a].node) === -1) { result.push({ inName: myLink.links[a].name, inNodeId: myLink.links[a].node.id, outName: myLink.name, outNodeId: this.id, }); } } } } return result; }, /** * Retrieves a list of all chains connected to a property input link on this node. * @function wcNode#listInputChains * @param {String} [name] - The property input link, if omitted, all link chains are retrieved. * @param {wcNode[]} [ignoreNodes] - If supplied, will ignore all chains connected to a node in this list. * @returns {wcNode~ChainData[]} - A list of all chains connected to this link, if the link was not found, an empty list is returned. */ listInputChains: function(name, ignoreNodes) { var result = []; for (var i = 0; i &lt; this.properties.length; ++i) { if (!name || this.properties[i].name === name) { var myProp = this.properties[i]; for (var a = 0; a &lt; myProp.inputs.length; ++a) { if (!ignoreNodes || ignoreNodes.indexOf(myProp.inputs[a].node) === -1) { result.push({ inName: myProp.name, inNodeId: this.id, outName: myProp.inputs[a].name, outNodeId: myProp.inputs[a].node.id, }); } } } } return result; }, /** * Retrieves a list of all chains connected to a property output link on this node. * @function wcNode#listOutputChains * @param {String} [name] - The property output link, if omitted, all link chains are retrieved. * @param {wcNode[]} [ignoreNodes] - If supplied, will ignore all chains connected to a node in this list. * @returns {wcNode~ChainData[]} - A list of all chains connected to this link, if the link was not found, an empty list is returned. */ listOutputChains: function(name, ignoreNodes) { var result = []; for (var i = 0; i &lt; this.properties.length; ++i) { if (!name || this.properties[i].name === name) { var myProp = this.properties[i]; for (var a = 0; a &lt; myProp.outputs.length; ++a) { if (!ignoreNodes || ignoreNodes.indexOf(myProp.outputs[a].node) === -1) { result.push({ inName: myProp.outputs[a].name, inNodeId: myProp.outputs[a].node.id, outName: myProp.name, outNodeId: this.id, }); } } } } return result; }, /** * Retrieves a list of all properties and their values for this node. * @function wcNode#listProperties * @param {Boolean} [minimal] - If true, only the minimal data is listed, this means current values will be omitted. * @returns {wcNode~PropertyData[]} - A list of all property data. */ listProperties: function(minimal) { var result = []; for (var i = 0; i &lt; this.properties.length; ++i) { var myProp = this.properties[i]; var data = { name: myProp.name, initialValue: myProp.initialValue, }; if (!minimal) { data.value = myProp.value; } if (typeof myProp.options.exportValue === 'function') { var val = myProp.options.exportValue(myProp.initialValue); if (val !== undefined) { data.initialValue = val; } } result.push(data); } return result; }, /** * Sets a size for the custom viewport.&lt;br&gt; * The custom viewport is a rectangular area embedded into the node's visual display in which you can 'draw' whatever you wish. It appears below the title text and above properties. * @function wcNode#viewportSize * @param {Number} [width] - If supplied, assigns the width of the viewport desired. Use 0 or null to disable the viewport. * @param {Number} [height] - If supplied, assigns the height of the viewport desired. Use 0 or null to disable the viewport. * @returns {wcPlay~Coordinates} - The current size of the viewport. * @see wcNode#onViewportDraw */ viewportSize: function(width, height) { if (width !== undefined &amp;&amp; height !== undefined) { this._meta.dirty = true; if (!width || !height) { this._viewportSize = null; } else { this._viewportSize = { x: width, y: height, }; } } return {x: this._viewportSize.x, y: this._viewportSize.y}; }, /** * Event that is called when it is time to draw the contents of your custom viewport. It is up to you to stay within the [wcNode.viewportSize]{@link wcNode~viewportSize} you've specified.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode#onViewportDraw * @param {external:Canvas~Context} context - The canvas context to draw on, coordinates 0,0 will be the top left corner of your viewport. It is up to you to stay within the [viewport bounds]{@link wcNode#viewportSize} you have assigned. * @param {Boolean} readOnly - The editors readonly status, when true, you should not allow changes to the node. * @see wcNode#viewportSize */ onViewportDraw: function(context, readOnly) { // this._super(context, readOnly); }, /** * Event that is called when the mouse has entered the viewport area.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode~onViewportMouseEnter * @param {Object} event - The original jquery mouse event. * @param {wcPlay~Coordinates} pos - The position of the mouse relative to the viewport area (top left corner is 0,0). * @param {Boolean} readOnly - The editors readonly status, when true, you should not allow changes to the node. */ onViewportMouseEnter: function(event, pos, readOnly) { // this._super(event, pos, readOnly); if (this.debugLog()) { console.log('DEBUG: Node &quot;' + this.category + '.' + this.type + (this.name? ' (' + this.name + ')': '') + '&quot; mouse entered custom viewport!'); } }, /** * Event that is called when the mouse has left the viewport area.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode~onViewportMouseLeave * @param {Object} event - The original jquery mouse event. * @param {Boolean} readOnly - The editors readonly status, when true, you should not allow changes to the node. */ onViewportMouseLeave: function(event, readOnly) { // this._super(event, readOnly); if (this.debugLog()) { console.log('DEBUG: Node &quot;' + this.category + '.' + this.type + (this.name? ' (' + this.name + ')': '') + '&quot; mouse left custom viewport!'); } }, /** * Event that is called when the mouse button is pressed over your viewport area.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode~onViewportMouseDown * @param {Object} event - The original jquery mouse event. * @param {wcPlay~Coordinates} pos - The position of the mouse relative to the viewport area (top left corner is 0,0). * @param {Boolean} readOnly - The editors readonly status, when true, you should not allow changes to the node. * @returns {Boolean|undefined} - Return true if you want to disable node dragging during mouse down within your viewport. */ onViewportMouseDown: function(event, pos, readOnly) { // this._super(event, pos, readOnly); }, /** * Event that is called when the mouse button is released over your viewport area.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode~onViewportMouseUp * @param {Object} event - The original jquery mouse event. * @param {wcPlay~Coordinates} pos - The position of the mouse relative to the viewport area (top left corner is 0,0). * @param {Boolean} readOnly - The editors readonly status, when true, you should not allow changes to the node. */ onViewportMouseUp: function(event, pos, readOnly) { // this._super(event, pos, readOnly); }, /** * Event that is called when the mouse has moved over your viewport area.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode~onViewportMouseMove * @param {Object} event - The original jquery mouse event. * @param {wcPlay~Coordinates} pos - The position of the mouse relative to the viewport area (top left corner is 0,0). * @param {Boolean} readOnly - The editors readonly status, when true, you should not allow changes to the node. */ onViewportMouseMove: function(event, pos, readOnly) { // this._super(event, pos, readOnly); }, /** * Event that is called when the mouse wheel is used over your viewport area.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode~onViewportMouseWheel * @param {Object} event - The original jquery mouse event. * @param {wcPlay~Coordinates} pos - The position of the mouse relative to the viewport area (top left corner is 0,0). * @param {Number} scrollDelta - The scroll amount and direction. * @param {Boolean} readOnly - The editors readonly status, when true, you should not allow changes to the node. */ onViewportMouseWheel: function(event, pos, scrollDelta, readOnly) { // this._super(event, pos, scrollDelta, readOnly); }, /** * Event that is called when the mouse button is pressed and released in the same spot over your viewport area.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode~onViewportMouseClick * @param {Object} event - The original jquery mouse event. * @param {wcPlay~Coordinates} pos - The position of the mouse relative to the viewport area (top left corner is 0,0). * @param {Boolean} readOnly - The editors readonly status, when true, you should not allow changes to the node. */ onViewportMouseClick: function(event, pos, readOnly) { // this._super(event, pos, readOnly); }, /** * Event that is called when the mouse button is double clicked in the same spot over your viewport area.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode~onViewportMouseClick * @param {Object} event - The original jquery mouse event. * @param {wcPlay~Coordinates} pos - The position of the mouse relative to the viewport area (top left corner is 0,0). * @param {Boolean} readOnly - The editors readonly status, when true, you should not allow changes to the node. * @returns {Boolean|undefined} - Return true if you want to disable node auto-collapse when double clicking. */ onViewportMouseDoubleClick: function(event, pos, readOnly) { // this._super(event, pos, readOnly); }, /** * Event that is called when a connection has been made.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode#onConnect * @param {Boolean} isConnecting - True if a connection is being made, false if it is a disconnection. * @param {String} name - The name of the link being connected to. * @param {wcNode.LINK_TYPE} type - The link's type. * @param {wcNode} targetNode - The target node being connected to. * @param {String} targetName - The link name on the target node being connected to. * @param {wcNode.LINK_TYPE} targetType - The target link's type. */ onConnect: function(isConnecting, name, type, targetNode, targetName, targetType) { // this._super(isConnecting, name, type, targetNode, targetName, targetType); // If we are connecting one of our property outputs to another property, alert them and send your value to them. if (isConnecting &amp;&amp; type === wcNode.LINK_TYPE.OUTPUT) { targetNode.activateProperty(targetName, this.property(name)); targetNode.initialProperty(targetName, this.initialProperty(name)); } }, /** * Event that is called as soon as the Play script has started.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode#onStart */ onStart: function() { // this._super(); if (this.debugLog()) { console.log('DEBUG: Node &quot;' + this.category + '.' + this.type + (this.name? ' (' + this.name + ')': '') + '&quot; started!'); } }, /** * Event that is called as soon as the Play script has stopped.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode#onStop */ onStop: function() { // this._super(); this._meta.dirty = true; if (this.debugLog()) { console.log('DEBUG: Node &quot;' + this.category + '.' + this.type + (this.name? ' (' + this.name + ')': '') + '&quot; stopped!'); } }, /** * Event that is called when this node is about to be drawn.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode#onDraw */ onDraw: function() { // this._super(); }, /** * Event that is called when an entry link has been activated.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode#onActivated * @param {String} name - The name of the entry link triggered. */ onActivated: function(name) { // this._super(name); if (this.debugLog()) { console.log('DEBUG: Node &quot;' + this.category + '.' + this.type + (this.name? ' (' + this.name + ')': '') + '&quot; Triggered Entry link &quot;' + name + '&quot;'); } }, /** * Event that is called when the node is about to change its position. * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode#onMoving * @param {wcPlay~Coordinates} oldPos - The current position of the node. * @param {wcPlay~Coordinates} newPos - The new position to move the node. * @returns {wcPlay~Coordinates|undefined} - Return the new position of the node (usually newPos unless you are restricting the position). If no value is returned, newPos is assumed. */ onMoving: function(oldPos, newPos) { // this._super(oldPos, newPos); }, /** * Event that is called after the node has changed its position. * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode#onMoving * @param {wcPlay~Coordinates} oldPos - The old position of the node. * @param {wcPlay~Coordinates} newPos - The new position of the node. */ onMoved: function(oldPos, newPos) { // this._super(oldPos, newPos); }, /** * Event that is called when the name of this node is about to change.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode#onNameChanging * @param {String} oldName - The current name. * @param {String} newName - The new name. * @return {String|undefined} - Return the new value of the name (usually newValue unless you are restricting the name). If no value is returned, newValue is assumed. */ onNameChanging: function(oldName, newName) { // this._super(oldName, newName); }, /** * Event that is called when the name of this node has changed.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode#onNameChanged * @param {String} oldName - The current name. * @param {String} newName - The new name. */ onNameChanged: function(oldName, newName) { // this._super(oldName, newName); this._meta.dirty = true; }, /** * Event that is called when a property is about to be changed.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode#onPropertyChanging * @param {String} name - The name of the property. * @param {Object} oldValue - The current value of the property. * @param {Object} newValue - The new, proposed, value of the property. * @returns {Object} - Return the new value of the property (usually newValue unless you are proposing restrictions). If no value is returned, newValue is assumed. */ onPropertyChanging: function(name, oldValue, newValue) { // this._super(name, oldValue, newValue); // if (this.debugLog()) { // console.log('DEBUG: Node &quot;' + this.category + '.' + this.type + (this.name? ' (' + this.name + ')': '') + '&quot; Changing Property &quot;' + name + '&quot; from &quot;' + oldValue + '&quot; to &quot;' + newValue + '&quot;'); // } }, /** * Event that is called when a property has changed.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode#onPropertyChanged * @param {String} name - The name of the property. * @param {Object} oldValue - The old value of the property. * @param {Object} newValue - The new value of the property. */ onPropertyChanged: function(name, oldValue, newValue) { // this._super(name, oldValue, newValue); if (this.debugLog()) { console.log('DEBUG: Node &quot;' + this.category + '.' + this.type + (this.name? ' (' + this.name + ')': '') + '&quot; Changed Property &quot;' + name + '&quot; from &quot;' + oldValue + '&quot; to &quot;' + newValue + '&quot;'); } }, /** * Event that is called when the property is being asked its value, before the value is actually retrieved.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode#onPropertyGet * @param {String} name - The name of the property. * @returns {Object|undefined} - If a value is returned, that value is what will be retrieved from the get. */ onPropertyGet: function(name) { // this._super(name); // if (this.debugLog()) { // console.log('DEBUG: Node &quot;' + this.category + '.' + this.type + (this.name? ' (' + this.name + ')': '') + '&quot; Requested Property &quot;' + name + '&quot;'); // } }, /** * Event that is called when a property initial value is about to be changed.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode#onInitialPropertyChanging * @param {String} name - The name of the property. * @param {Object} oldValue - The current value of the property. * @param {Object} newValue - The new, proposed, value of the property. * @returns {Object} - Return the new value of the property (usually newValue unless you are proposing restrictions). If no value is returned, newValue is assumed. */ onInitialPropertyChanging: function(name, oldValue, newValue) { // this._super(name, oldValue, newValue); // if (this.debugLog()) { // console.log('DEBUG: Node &quot;' + this.category + '.' + this.type + (this.name? ' (' + this.name + ')': '') + '&quot; Changing Property &quot;' + name + '&quot; from &quot;' + oldValue + '&quot; to &quot;' + newValue + '&quot;'); // } }, /** * Event that is called when a property initial value has changed.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode#onInitialPropertyChanged * @param {String} name - The name of the property. * @param {Object} oldValue - The old value of the property. * @param {Object} newValue - The new value of the property. */ onInitialPropertyChanged: function(name, oldValue, newValue) { // this._super(name, oldValue, newValue); if (this.debugLog()) { console.log('DEBUG: Node &quot;' + this.category + '.' + this.type + (this.name? ' (' + this.name + ')': '') + '&quot; Changed Property &quot;' + name + '&quot; from &quot;' + oldValue + '&quot; to &quot;' + newValue + '&quot;'); } }, /** * Event that is called when the property initial value is being asked its value, before the value is actually retrieved.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode#onInitialPropertyGet * @param {String} name - The name of the property. * @returns {Object|undefined} - If a value is returned, that value is what will be retrieved from the get. */ onInitialPropertyGet: function(name) { // this._super(name); // if (this.debugLog()) { // console.log('DEBUG: Node &quot;' + this.category + '.' + this.type + (this.name? ' (' + this.name + ')': '') + '&quot; Requested Property &quot;' + name + '&quot;'); // } }, /** * Event that is called when a global property value has changed. * Overload this in inherited nodes.&lt;br&gt; * &lt;b&gt;Note:&lt;/b&gt; Do not call 'this._super(..)' for this function, as the parent does not implement it. * @function wcNode#onGlobalPropertyChanged * @param {String} name - The name of the global property. * @param {Object} oldValue - The old value of the global property. * @param {Object} newValue - The new value of the global property. */ // onGlobalPropertyChanged: function(name, oldValue, newValue) { // }, /** * Event that is called when a global property has been removed. * Overload this in inherited nodes.&lt;br&gt; * &lt;b&gt;Note:&lt;/b&gt; Do not call 'this._super(..)' for this function, as the parent does not implement it. * @function wcNode#onGlobalPropertyRemoved * @param {String} name - The name of the global property. */ // onGlobalPropertyRemoved: function(name) { // }, /** * Event that is called when a global property has been renamed. * Overload this in inherited nodes.&lt;br&gt; * &lt;b&gt;Note:&lt;/b&gt; Do not call 'this._super(..)' for this function, as the parent does not implement it. * @function wcNode#onGlobalPropertyRenamed * @param {String} oldName - The old name of the global property. * @param {String} newName - The new name of the global property. */ // onGlobalPropertyRenamed: function(oldName, newName) { // }, /** * Event that is called when a global property initial value has changed. * Overload this in inherited nodes.&lt;br&gt; * &lt;b&gt;Note:&lt;/b&gt; Do not call 'this._super(..)' for this function, as the parent does not implement it. * @function wcNode#onGlobalInitialPropertyChanged * @param {String} name - The name of the global property. * @param {Object} oldValue - The old value of the global property. * @param {Object} newValue - The new value of the global property. */ // onGlobalInitialPropertyChanged: function(name, oldValue, newValue) { // }, /** * Event that is called when the node is about to be imported. This is your chance to prepare the node for import, or possibly modify the import data.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode#onImporting * @param {Object} data - The data being imported. * @param {Number[]} [idMap] - If supplied, identifies a mapping of old ID's to new ID's, any not found in this list will be unchanged. */ onImporting: function(data, idMap) { // this._super(data, idMap); }, /** * Event that is called after the node has imported.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode#onImported * @param {Object} data - The data being imported. * @param {Number[]} [idMap] - If supplied, identifies a mapping of old ID's to new ID's, any not found in this list will be unchanged. */ onImported: function(data, idMap) { // this._super(data, idMap); }, /** * Event that is called when the node is being exported, after the export data has been configured.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode#onExport * @param {Object} data - The export data for this node. * @param {Boolean} [minimal] - If true, only the most important data should be exported, this means current values and redundant link connections are omitted. */ onExport: function(data, minimal) { // this._super(data, minimal); }, /** * Event that is called when the node is about to be reset.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode#onReset */ onReset: function() { // this._super(); }, /** * Event that is called when the node is about to be destroyed.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode#onDestroying */ onDestroying: function() { // this._super(); }, /** * Event that is called after the node has been destroyed.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNode#onDestroyed */ onDestroyed: function() { // this._super(); }, }); /** * The type of node link. * @enum {String} */ wcNode.LINK_TYPE = { ENTRY: 'entry', EXIT: 'exit', INPUT: 'input', OUTPUT: 'output', }; /** * The connection result. * @enum {String} */ wcNode.CONNECT_RESULT = { NOT_FOUND: 'not_found', ALREADY_CONNECTED: 'already_connected', SUCCESS: 'success', }; /** * Enabled property name. * @typedef {String} */ wcNode.PROPERTY_ENABLED = 'enabled';  Search results Close "},"nodes_composite.js.html":{"id":"nodes_composite.js.html","title":"Source: nodes/composite.js","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Source: nodes/composite.js wcNode.extend('wcNodeComposite', 'Composite', '', { /** * @class * The base class for all composite nodes.&lt;br&gt; * * @constructor wcNodeComposite * @param {String} parent - The parent object of this node. * @param {wcPlay~Coordinates} pos - The position of this node in the visual editor. */ init: function(parent, pos) { this._super(parent, pos); this.color = '#990099'; this.removeEntry('in'); this.removeExit('out'); }, /** * Magic function that is called whenever any new class type is extended from this one.&lt;br&gt; * Handles initializing of the class as well as registering the new node type. * @function wcNodeComposite#classInit * @param {String} className - The name of the class constructor. * @param {String} type - The type name for the node. * @param {String} category - A category where this node will be grouped. */ classInit: function(className, type, category) { if (category) { this.className = className; this.type = type; this.nodeType = wcPlay.NODE.COMPOSITE; this.category = category; wcPlay.registerNodeType(className, type, category, wcPlay.NODE.COMPOSITE); } }, });  Search results Close "},"nodes_entry.js.html":{"id":"nodes_entry.js.html","title":"Source: nodes/entry.js","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Source: nodes/entry.js wcNode.extend('wcNodeEntry', 'Entry Node', '', { /** * @class * The base class for all entry nodes. These are nodes that start script chains.&lt;br&gt; * When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. * * @constructor wcNodeEntry * @description * &lt;b&gt;Should be inherited and never constructed directly.&lt;/b&gt; * @param {String} parent - The parent object of this node. * @param {wcPlay~Coordinates} pos - The position of this node in the visual editor. */ init: function(parent, pos) { this._super(parent, pos); this.color = '#CCCC00'; // Create a default exit link. this.createExit('out'); }, /** * Magic function that is called whenever any new class type is extended from this one.&lt;br&gt; * Handles initializing of the class as well as registering the new node type. * @function wcNodeEntry#classInit * @param {String} className - The name of the class constructor. * @param {String} type - The type name for the node. * @param {String} category - A category where this node will be grouped. */ classInit: function(className, type, category) { if (category) { this.className = className; this.type = type; this.nodeType = wcPlay.NODE.ENTRY; this.category = category; wcPlay.registerNodeType(className, type, category, wcPlay.NODE.ENTRY); } }, /** * Overloading the default onActivated event handler so we can make it immediately trigger our Exit link. * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNodeEntry#onActivated * @param {String} name - The name of the entry link triggered. */ onActivated: function(name) { this._super(name); this.activateExit('out'); }, });  Search results Close "},"nodes_entry_callremote.js.html":{"id":"nodes_entry_callremote.js.html","title":"Source: nodes/entry/callremote.js","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Source: nodes/entry/callremote.js wcNodeEntry.extend('wcNodeEntryCallRemote', 'Call Remote Event', 'Flow Control', { /** * @class * An entry node that fires when a [Call Remote Event Node]{@link wcNodeEntryCallRemote} of the same name is activated.&lt;br&gt; * When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. * * @constructor wcNodeEntryCallRemote * @param {String} parent - The parent object of this node. * @param {wcPlay~Coordinates} pos - The position of this node in the visual editor. */ init: function(parent, pos) { this._super(parent, pos); this.description(&quot;An entry node that activates all Remote Event Nodes of the same name.&quot;); this.details(&quot;This node uses it's Title Name value as an identifier that links it with any Remote Event Nodes of the same name. Whenever this Node is activated, All Remote Event Nodes of the same name will also become active as well.&quot;); this.createEntry('in'); this.removeExit('out'); this.createProperty('local', wcPlay.PROPERTY.TOGGLE, true, {description: &quot;If true, only matching Remote Event Nodes that are within, or nested within, the same Composite Node or scope will be activated.&quot;}); }, /** * Event that is called when an entry link has been activated.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNodeEntryCallRemote#onActivated * @param {String} name - The name of the entry link triggered. */ onActivated: function(name) { this._super(name); var engine = this.engine(); var scope = engine; if (this.property('local')) { scope = this._parent; } var remoteNodes = scope.nodesByClassName('wcNodeEntryRemote'); for (var i = 0; i &lt; remoteNodes.length; ++i) { if (remoteNodes[i].name === this.name) { engine.queueNodeEntry(remoteNodes[i], 'in', this, 'out'); } } }, });  Search results Close "},"nodes_entry_remote.js.html":{"id":"nodes_entry_remote.js.html","title":"Source: nodes/entry/remote.js","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Source: nodes/entry/remote.js wcNodeEntry.extend('wcNodeEntryRemote', 'Remote Event', 'Flow Control', { /** * @class * An entry node that fires when a [Call Remote Event Node]{@link wcNodeEntryCallRemote} of the same name is activated.&lt;br&gt; * When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. * * @constructor wcNodeEntryRemote * @param {String} parent - The parent object of this node. * @param {wcPlay~Coordinates} pos - The position of this node in the visual editor. */ init: function(parent, pos) { this._super(parent, pos); this.description(&quot;An entry node that fires when a Call Remote Event Node of the same name is activated.&quot;); this.details(&quot;This node uses it's Title Name value as an identifier that links it with any Call Remote Event Nodes of the same name. Whenever any Call Remote Event Node of the same name is activated, this Node will become active as well. If multiple Remote Nodes exist with the same name, they will all be called in parallel.&quot;); }, });  Search results Close "},"nodes_entry_start.js.html":{"id":"nodes_entry_start.js.html","title":"Source: nodes/entry/start.js","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Source: nodes/entry/start.js wcNodeEntry.extend('wcNodeEntryStart', 'Start', 'Automatic', { /** * @class * An entry node that fires as soon as the script [starts]{@link wcPlay#start}.&lt;br&gt; * When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. * * @constructor wcNodeEntryStart * @param {String} parent - The parent object of this node. * @param {wcPlay~Coordinates} pos - The position of this node in the visual editor. */ init: function(parent, pos) { this._super(parent, pos); this.description(&quot;When the script starts, this will activate immediately and only once.&quot;); }, /** * Event that is called as soon as the Play script has started.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNodeEntryStart#onStart */ onStart: function() { this._super(); this.onActivated(); }, });  Search results Close "},"nodes_entry_update.js.html":{"id":"nodes_entry_update.js.html","title":"Source: nodes/entry/update.js","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Source: nodes/entry/update.js wcNodeEntry.extend('wcNodeEntryUpdate', 'Update', 'Automatic', { /** * @class * An entry node that fires continuously on a regular update.&lt;br&gt; * When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. * * @constructor wcNodeEntryUpdate * @param {String} parent - The parent object of this node. * @param {wcPlay~Coordinates} pos - The position of this node in the visual editor. */ init: function(parent, pos) { this._super(parent, pos); this.description(&quot;Once the script starts, this will activate continuously on a time interval defined by the milliseconds property.&quot;); this.createProperty(&quot;milliseconds&quot;, wcPlay.PROPERTY.NUMBER, 1000, {description: &quot;The time, in milliseconds, per update.&quot;, input: true}); }, /** * Overloading the default onActivated event handler so we can make it immediately trigger our exit link if our conditions are met. * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNodeEntryUpdate#onActivated * @param {String} name - The name of the entry link triggered. */ onActivated: function(name) { var interval = this.property('milliseconds'); this.resetThreads(); this.setInterval(function() { this.activateExit('out'); }, interval); }, /** * Event that is called as soon as the Play script has started.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNodeEntryUpdate#onStart */ onStart: function() { this._super(); this.onActivated(); }, /** * Event that is called when a property has changed.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNodeEntryUpdate#onPropertyChanged * @param {String} name - The name of the property. * @param {Object} oldValue - The old value of the property. * @param {Object} newValue - The new value of the property. */ onPropertyChanged: function(name, oldValue, newValue) { this._super(name, oldValue, newValue); if (name === 'milliseconds') { this.resetThreads(); this.onActivated(); } }, });  Search results Close "},"nodes_process.js.html":{"id":"nodes_process.js.html","title":"Source: nodes/process.js","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Source: nodes/process.js wcNode.extend('wcNodeProcess', 'Node Process', '', { /** * @class * The base class for all process nodes. These are nodes that make up the bulk of script chains.&lt;br&gt; * When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. * * @constructor wcNodeProcess * @description * &lt;b&gt;Should be inherited and never constructed directly.&lt;/b&gt; * @param {String} parent - The parent object of this node. * @param {wcPlay~Coordinates} pos - The position of this node in the visual editor. */ init: function(parent, pos) { this._super(parent, pos); this.color = '#007ACC'; // Create a default links. this.createEntry('in'); this.createExit('out'); }, /** * Magic function that is called whenever any new class type is extended from this one.&lt;br&gt; * Handles initializing of the class as well as registering the new node type. * @function wcNodeProcess#classInit * @param {String} className - The name of the class constructor. * @param {String} type - The type name for the node. * @param {String} category - A category where this node will be grouped. */ classInit: function(className, type, category) { if (category) { this.className = className; this.type = type; this.nodeType = wcPlay.NODE.PROCESS; this.category = category; wcPlay.registerNodeType(className, type, category, wcPlay.NODE.PROCESS); } }, });  Search results Close "},"nodes_process_ajax.js.html":{"id":"nodes_process_ajax.js.html","title":"Source: nodes/process/ajax.js","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Source: nodes/process/ajax.js wcNodeProcess.extend('wcNodeProcessAJAX', 'AJAX', 'Data Retrieval', { /** * @class * Performs an AJAX request.&lt;br&gt; * When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. * * @constructor wcNodeProcessAJAX * @param {String} parent - The parent object of this node. * @param {wcPlay~Coordinates} pos - The position of this node in the visual editor. */ init: function(parent, pos) { this._super(parent, pos); this.description(&quot;Performs an AJAX request.&quot;); this.details(&quot;Once activated, a request will be sent to the given URL. Either the success or failure exit links will activate once the operation is completed and the result will be assigned to the result property.&quot;); this.removeExit('out'); this.createExit('success'); this.createExit('failure'); this.createProperty('type', wcPlay.PROPERTY.SELECT, 'GET', {items: ['GET', 'POST'], description:&quot;The AJAX method to perform.&quot;, input: true}); this.createProperty('url', wcPlay.PROPERTY.STRING, 'example.com', {description: &quot;The URL to send the request.&quot;, input: true}); this.createProperty('data', wcPlay.PROPERTY.STRING, 'foo=bar&amp;bar=foo', {description: &quot;The data to send with the request. This can be in query string form, or any object that $.ajax supports as the data parameter.&quot;, input: true}); this.createProperty('result', wcPlay.PROPERTY.STRING, '', {description: &quot;The result of the ajax request, if successful.&quot;, output: true}); }, /** * Event that is called when an entry link has been activated.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNodeProcessAJAX#onActivated * @param {String} name - The name of the entry link triggered. */ onActivated: function(name) { this._super(name); var type = this.property('type'); var url = this.property('url'); var data = this.property('data'); if (!url) { this.activateExit('failure'); return; } this.ajax({ type: type, url: url, data: data, success: function(result) { this.property('result', result); this.activateExit('success'); }, error: function(XHR, status, msg) { this.property('result', msg); this.activateExit('failure'); }, }); }, });  Search results Close "},"nodes_process_alert.js.html":{"id":"nodes_process_alert.js.html","title":"Source: nodes/process/alert.js","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Source: nodes/process/alert.js wcNodeProcess.extend('wcNodeProcessAlert', 'Alert', 'Debugging', { /** * @class * For debugging purposes, will popup an alert box with a message the moment it is activated. [Silent mode]{@link wcPlay~Options} will silence this node.&lt;br&gt; * When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. * * @constructor wcNodeProcessAlert * @param {String} parent - The parent object of this node. * @param {wcPlay~Coordinates} pos - The position of this node in the visual editor. */ init: function(parent, pos) { this._super(parent, pos); this.description(&quot;For debugging purposes, will popup an alert box with a message when activated (only if silent mode is not on).&quot;); // Create the message property so we know what to output in the log. this.createProperty('message', wcPlay.PROPERTY.STRING, 'Alert message.', {multiline: true, description: &quot;The message that will appear in the alert box.&quot;, input: true}); }, /** * Event that is called when an entry link has been activated.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNodeProcessAlert#onActivated * @param {String} name - The name of the entry link triggered. */ onActivated: function(name) { this._super(name); // Always trigger the out immediately. this.activateExit('out'); // Cancel the log in silent mode. var engine = this.engine(); if (!engine || engine.silent()) { return; } var msg = this.property('message'); alert(msg); }, });  Search results Close "},"nodes_process_consolelog.js.html":{"id":"nodes_process_consolelog.js.html","title":"Source: nodes/process/consolelog.js","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Source: nodes/process/consolelog.js wcNodeProcess.extend('wcNodeProcessConsoleLog', 'Console Log', 'Debugging', { /** * @class * For debugging purposes, will print out a message into the console log the moment it is activated. [Silent mode]{@link wcPlay~Options} will silence this node.&lt;br&gt; * When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. * * @constructor wcNodeProcessConsoleLog * @param {String} parent - The parent object of this node. * @param {wcPlay~Coordinates} pos - The position of this node in the visual editor. */ init: function(parent, pos) { this._super(parent, pos); this.description(&quot;For debugging purposes, will print out a message into the console log when activated (only if silent mode is not on).&quot;); // Create the message property so we know what to output in the log. this.createProperty('message', wcPlay.PROPERTY.STRING, 'msg', {description: &quot;The message that will appear in the console log.&quot;, input: true}); }, /** * Event that is called when an entry link has been activated.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNodeProcessConsoleLog#onActivated * @param {String} name - The name of the entry link triggered. */ onActivated: function(name) { this._super(name); // Always trigger the out immediately. this.activateExit('out'); // Cancel the log in silent mode. var engine = this.engine(); if (!engine || engine.silent()) { return; } var msg = this.property('message'); console.log(msg); }, });  Search results Close "},"nodes_process_delay.js.html":{"id":"nodes_process_delay.js.html","title":"Source: nodes/process/delay.js","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Source: nodes/process/delay.js wcNodeProcess.extend('wcNodeProcessDelay', 'Delay', 'Flow Control', { /** * @class * Waits for a specified amount of time before continuing the flow chain.&lt;br&gt; * When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. * * @constructor wcNodeProcessDelay * @param {String} parent - The parent object of this node. * @param {wcPlay~Coordinates} pos - The position of this node in the visual editor. */ init: function(parent, pos) { this._super(parent, pos); this.description(&quot;Waits for a specified amount of time before continuing the flow chain.&quot;); this.createProperty('milliseconds', wcPlay.PROPERTY.NUMBER, 1000, {description: &quot;The time delay, in milliseconds, to wait before firing the 'out' Exit link.&quot;, input: true}); }, /** * Event that is called when an entry link has been activated.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNodeProcessDelay#onActivated * @param {String} name - The name of the entry link triggered. */ onActivated: function(name) { this._super(name); // Now set a timeout to wait for 'Milliseconds' amount of time. var delay = this.property('milliseconds'); // Start a timeout event using the node's built in timeout handler. this.setTimeout(function() { this.activateExit('out'); }, delay); }, });  Search results Close "},"nodes_process_operation.js.html":{"id":"nodes_process_operation.js.html","title":"Source: nodes/process/operation.js","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Source: nodes/process/operation.js wcNodeProcess.extend('wcNodeProcessOperation', 'Operation', 'Data Manipulation', { /** * @class * Performs a simple math operation on two values. * When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. * * @constructor wcNodeProcessOperation * @param {String} parent - The parent object of this node. * @param {wcPlay~Coordinates} pos - The position of this node in the visual editor. */ init: function(parent, pos) { this._super(parent, pos); this.description(&quot;Performs a simple math operation on two values.&quot;); this.details(&quot;Activate the entry link of the operation you want to perform, either an addition, subtraction, multiplication, or division. The operation will then be performed using valueA and valueB, the result will be output to the result property.&quot;); // Remove our default entry. this.removeEntry('in'); // Create an input link per operation type. this.createEntry('add', &quot;valueA + valueB = result&quot;); this.createEntry('sub', &quot;valueA - valueB = result&quot;); this.createEntry('mul', &quot;valueA * valueB = result&quot;); this.createEntry('div', &quot;valueA / valueB = result&quot;); // Create our two operator values. this.createProperty('valueA', wcPlay.PROPERTY.NUMBER, 0, {description: &quot;Left hand value for the operation.&quot;, input: true}); this.createProperty('valueB', wcPlay.PROPERTY.NUMBER, 0, {description: &quot;Right hand value for the operation.&quot;, input: true}); this.createProperty('result', wcPlay.PROPERTY.NUMBER, 0, {description: &quot;The result of the operation.&quot;, output: true}); }, /** * Event that is called when an entry link has been activated.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNodeProcessOperation#onActivated * @param {String} name - The name of the entry link triggered. */ onActivated: function(name) { this._super(name); var a = parseFloat(this.property('valueA')); var b = parseFloat(this.property('valueB')); var result; switch (name) { case 'add': result = a + b; break; case 'sub': result = a - b; break; case 'mul': result = a * b; break; case 'div': result = a / b; break; } this.property('result', result, true); this.activateExit('out'); }, });  Search results Close "},"nodes_process_strcat.js.html":{"id":"nodes_process_strcat.js.html","title":"Source: nodes/process/strcat.js","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Source: nodes/process/strcat.js wcNodeProcess.extend('wcNodeProcessStrCat', 'String Concat', 'Data Manipulation', { /** * @class * Formats a templated string by replacing template commands with the value of other properties. * When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. * * @constructor wcNodeProcessStrCat * @param {String} parent - The parent object of this node. * @param {wcPlay~Coordinates} pos - The position of this node in the visual editor. */ init: function(parent, pos) { this._super(parent, pos); this.description(&quot;Concatenates two string values.&quot;); this.details(&quot;This takes the string of valueA and appends valueB to it, the result is stored in the result property.&quot;); // Create our two operator values. this.createProperty('valueA', wcPlay.PROPERTY.STRING, '', {description: &quot;The left side string to join.&quot;, input: true}); this.createProperty('valueB', wcPlay.PROPERTY.STRING, '', {description: &quot;The right side string to join.&quot;, input: true}); this.createProperty('result', wcPlay.PROPERTY.STRING, '', {description: &quot;The concatenated result.&quot;, output: true}); }, /** * Event that is called when an entry link has been activated.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNodeProcessStrCat#onActivated * @param {String} name - The name of the entry link triggered. */ onActivated: function(name) { this._super(name); this.property('result', this.property('valueA').toString() + this.property('valueB')); this.activateExit('out'); }, });  Search results Close "},"nodes_storage.js.html":{"id":"nodes_storage.js.html","title":"Source: nodes/storage.js","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Source: nodes/storage.js wcNode.extend('wcNodeStorage', 'Storage', '', { /** * @class * The base class for all storage nodes. These are nodes designed solely for managing data.&lt;br&gt; * When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function.&lt;br&gt; * Also when inheriting, a 'value' property MUST be created as the storage value. * * @constructor wcNodeStorage * @param {String} parent - The parent object of this node. * @param {wcPlay~Coordinates} pos - The position of this node in the visual editor. */ init: function(parent, pos) { this._super(parent, pos); this.color = '#009900'; }, /** * Magic function that is called whenever any new class type is extended from this one.&lt;br&gt; * Handles initializing of the class as well as registering the new node type. * @function wcNodeStorage#classInit * @param {String} className - The name of the class constructor. * @param {String} type - The type name for the node. * @param {String} category - A category where this node will be grouped. */ classInit: function(className, type, category) { if (category) { this.className = className; this.type = type; this.nodeType = wcPlay.NODE.STORAGE; this.category = category; wcPlay.registerNodeType(className, type, category, wcPlay.NODE.STORAGE); } }, /** * Event that is called as soon as the Play script has started.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNodeStorage#onStart */ onStart: function() { this._super(); // Force a property change event so all connected nodes receive our value. this.property('value', this.property('value'), true); }, });  Search results Close "},"nodes_storage_global.js.html":{"id":"nodes_storage_global.js.html","title":"Source: nodes/storage/global.js","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Source: nodes/storage/global.js wcNodeStorage.extend('wcNodeStorageGlobal', 'Script Value', 'Global', { /** * @class * References a global property on the script. * When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. * * @constructor wcNodeStorageGlobal * @param {String} parent - The parent object of this node. * @param {wcPlay~Coordinates} pos - The position of this node in the visual editor. */ init: function(parent, pos) { this._super(parent, pos); this.color = '#77CC77'; this.description(&quot;References a global property on the script.&quot;); this.details(&quot;The title name for this node becomes the name of the global property it references. Duplicate Global Nodes with the same name will all reference the same value.&quot;); this.createProperty('value', wcPlay.PROPERTY.STRING, '', {description: &quot;The current value of the global property (Use the title to identify the property).&quot;}); }, /** * Event that is called when the name of this node has changed.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNodeStorageGlobal#onNameChanged * @param {String} oldName - The current name. * @param {String} newName - The new name. */ onNameChanged: function(oldName, newName) { this._super(oldName, newName); // Attempt to create a new property if it does not exist. var engine = this.engine(); if (engine) { engine.createProperty(newName, wcPlay.PROPERTY.STRING, ''); // Perform a search and remove all global properties no longer being referenced. var propList = engine.listProperties(); var globalNodes = engine.nodesByClassName(this.className); for (var i = 0; i &lt; globalNodes.length; ++i) { var name = globalNodes[i].name; for (var a = 0; a &lt; propList.length; ++a) { if (propList[a].name === name) { propList.splice(a, 1); break; } } } for (var i = 0; i &lt; propList.length; ++i) { engine.removeProperty(propList[i].name); } this.property('value', engine.property(newName)); this.initialProperty('value', engine.initialProperty(newName)); } }, /** * Any changes to the 'value' property will also change the global property.&lt;br&gt; * Event that is called when a property has changed.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNodeStorageGlobal#onPropertyChanged * @param {String} name - The name of the property. * @param {Object} oldValue - The old value of the property. * @param {Object} newValue - The new value of the property. */ onPropertyChanged: function(name, oldValue, newValue) { this._super(name, oldValue, newValue); if (name === 'value') { if (this.name) { var engine = this.engine(); engine &amp;&amp; engine.property(this.name, newValue); } } }, /** * Always redirect property gets on 'value' to the referenced global property.&lt;br&gt; * Event that is called when the property is being asked its value, before the value is actually retrieved.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNodeStorageGlobal#onPropertyGet * @param {String} name - The name of the property. * @returns {Object|undefined} - If a value is returned, that value is what will be retrieved from the get. */ onPropertyGet: function(name) { this._super(name); if (name === 'value') { if (this.name) { var engine = this.engine(); return (engine &amp;&amp; engine.property(this.name)); } } }, /** * Any changes to the 'value' property will also change the global property.&lt;br&gt; * Event that is called when a property initial value is about to be changed.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNodeStorageGlobal#onInitialPropertyChanging * @param {String} name - The name of the property. * @param {Object} oldValue - The current value of the property. * @param {Object} newValue - The new, proposed, value of the property. * @returns {Object} - Return the new value of the property (usually newValue unless you are proposing restrictions). If no value is returned, newValue is assumed. */ onInitialPropertyChanging: function(name, oldValue, newValue) { this._super(name, oldValue, newValue); if (name === 'value') { if (this.name) { var engine = this.engine(); engine &amp;&amp; engine.initialProperty(this.name, newValue); } } }, /** * Always redirect property gets on 'value' to the referenced global property.&lt;br&gt; * Event that is called when the property initial value is being asked its value, before the value is actually retrieved.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNodeStorageGlobal#onInitialPropertyGet * @param {String} name - The name of the property. * @returns {Object|undefined} - If a value is returned, that value is what will be retrieved from the get. */ onInitialPropertyGet: function(name) { this._super(name); if (name === 'value') { if (this.name) { var engine = this.engine(); return (engine &amp;&amp; engine.initialProperty(this.name)); } } }, /** * Event that is called when a global property value has changed. * Overload this in inherited nodes.&lt;br&gt; * &lt;b&gt;Note:&lt;/b&gt; Do not call 'this._super(..)' for this function, as the parent does not implement it. * @function wcNodeStorageGlobal#onGlobalPropertyChanged * @param {String} name - The name of the global property. * @param {Object} oldValue - The old value of the global property. * @param {Object} newValue - The new value of the global property. */ onGlobalPropertyChanged: function(name, oldValue, newValue) { if (this.name === name) { this.property('value', newValue, true, true); this._meta.dirty = true; }; }, /** * Event that is called when a global property initial value has changed. * Overload this in inherited nodes.&lt;br&gt; * &lt;b&gt;Note:&lt;/b&gt; Do not call 'this._super(..)' for this function, as the parent does not implement it. * @function wcNodeStorageGlobal#onGlobalInitialPropertyChanged * @param {String} name - The name of the global property. * @param {Object} oldValue - The old value of the global property. * @param {Object} newValue - The new value of the global property. */ onGlobalInitialPropertyChanged: function (name, oldValue, newValue) { if (this.name === name) { this.initialProperty('value', newValue, true, true); this._meta.dirty = true; } }, /** * Event that is called when a global property has been removed. * Overload this in inherited nodes.&lt;br&gt; * &lt;b&gt;Note:&lt;/b&gt; Do not call 'this._super(..)' for this function, as the parent does not implement it. * @function wcNodeStorageGlobal#onGlobalPropertyRemoved * @param {String} name - The name of the global property. */ onGlobalPropertyRemoved: function(name) { if (this.name == name) { this.name = ''; } }, /** * Event that is called when a global property has been renamed. * Overload this in inherited nodes.&lt;br&gt; * &lt;b&gt;Note:&lt;/b&gt; Do not call 'this._super(..)' for this function, as the parent does not implement it. * @function wcNodeStorageGlobal#onGlobalPropertyRenamed * @param {String} oldName - The old name of the global property. * @param {String} newName - The new name of the global property. */ onGlobalPropertyRenamed: function(oldName, newName) { if (this.name == oldName) { this.name = newName; } }, });  Search results Close "},"nodes_storage_number.js.html":{"id":"nodes_storage_number.js.html","title":"Source: nodes/storage/number.js","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Source: nodes/storage/number.js wcNodeStorage.extend('wcNodeStorageNumber', 'Number', 'Local', { /** * @class * Stores a number value.&lt;br&gt; * When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. * * @constructor wcNodeStorageNumber * @param {String} parent - The parent object of this node. * @param {wcPlay~Coordinates} pos - The position of this node in the visual editor. */ init: function(parent, pos) { this._super(parent, pos); this.description(&quot;Stores a number value.&quot;); this.createProperty('value', wcPlay.PROPERTY.NUMBER, '', {input: true, output: true}); }, });  Search results Close "},"nodes_storage_string.js.html":{"id":"nodes_storage_string.js.html","title":"Source: nodes/storage/string.js","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Source: nodes/storage/string.js wcNodeStorage.extend('wcNodeStorageString', 'String', 'Local', { /** * @class * Stores a string value.&lt;br&gt; * When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. * * @constructor wcNodeStorageString * @param {String} parent - The parent object of this node. * @param {wcPlay~Coordinates} pos - The position of this node in the visual editor. */ init: function(parent, pos) { this._super(parent, pos); this.description(&quot;Stores a string value.&quot;); this.createProperty('value', wcPlay.PROPERTY.STRING, '', {multiline: true, input: true, output: true}); }, });  Search results Close "},"nodes_storage_toggle.js.html":{"id":"nodes_storage_toggle.js.html","title":"Source: nodes/storage/toggle.js","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Source: nodes/storage/toggle.js wcNodeStorage.extend('wcNodeStorageToggle', 'Toggle', 'Local', { /** * @class * Stores a boolean (toggleable) value. * When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. * * @constructor wcNodeStorageToggle * @param {String} parent - The parent object of this node. * @param {wcPlay~Coordinates} pos - The position of this node in the visual editor. */ init: function(parent, pos) { this._super(parent, pos); this.description(&quot;Stores a boolean (toggleable) value.&quot;); this.createProperty('value', wcPlay.PROPERTY.TOGGLE, false, {input: true, output: true}); } });  Search results Close "},"nodes_node.jsdoc.html":{"id":"nodes_node.jsdoc.html","title":"Source: nodes/node.jsdoc","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Source: nodes/node.jsdoc /** * Allows for overriding the display string for a property value as displayed on the node. * @callback wcNode~PropertyDisplay * @param {Object} - The value or initial value of the property to display. * @returns {String} - A string value to display on the node. */ /** * A set of options that apply to all property types. * @typedef {Object} wcNode~PropertyOptions * @property {String} [description] - An optional description to display as a tooltip for this property. * @property {wcNode~PropertyDisplay} [display] - An optional function that will be called to retrieve the display string for the value/initial value for this property. * @property {wcNode~ExportValue} [exportValue] - An optional function that will retrieve the property's value when it is about to be exported to file. * @property {Boolean} [input] - If true, this property will have an input link so its value can be changed through script. * @property {Boolean} [output] - If true, this property will have an output link so its value can be retrieved through script. * @property {Boolean} [linked] - If true, the value and initial values will be linked and can not be separated. Changing either will change them both. */ /** * Options for a [NUMBER]{@link wcPlay.PROPERTY} value. * @typedef {Object} wcNode~NumberOptions * @property {String} [description] - An optional description to display as a tooltip for this property. * @property {wcNode~PropertyDisplay} [display] - An optional function that will be called to retrieve the display string for the value/initial value for this property. * @property {wcNode~ExportValue} [exportValue] - An optional function that will retrieve the property's value when it is about to be exported to file. * @property {Boolean} [input] - If true, this property will have an input link so its value can be changed through script. * @property {Boolean} [output] - If true, this property will have an output link so its value can be retrieved through script. * @property {Boolean} [linked] - If true, the value and initial values will be linked and can not be separated. Changing either will change them both. * @property {Number} [min=-Infinity] - The minimum value of the number range. * @property {Number} [max=Infinity] - The maximum value of the number range. * @property {Number} [step=1] - The amount the value will go up or down when the user clicks the up and down arrow controls. */ /** * Options for a [STRING]{@link wcPlay.PROPERTY} value. * @typedef {Object} wcNode~StringOptions * @property {String} [description] - An optional description to display as a tooltip for this property. * @property {wcNode~PropertyDisplay} [display] - An optional function that will be called to retrieve the display string for the value/initial value for this property. * @property {wcNode~ExportValue} [exportValue] - An optional function that will retrieve the property's value when it is about to be exported to file. * @property {Boolean} [input] - If true, this property will have an input link so its value can be changed through script. * @property {Boolean} [output] - If true, this property will have an output link so its value can be retrieved through script. * @property {Boolean} [linked] - If true, the value and initial values will be linked and can not be separated. Changing either will change them both. * @property {Number} [maxlength=Infinity] - The maximum number of characters allowed. * @property {Boolean} [multiline=false] - Whether to use a multi-line text editor for this property. * @property {wcNode~SelectItem[]|String[]|wcNode~SelectItemFunc} items - A list of items to drop down in a suggestion as the user types, or a callback function that can dynamically retrieve a list. See [here]{@link http://caniuse.com/#search=datalist} for browser compatability information. */ /** * Options for a [SELECT]{@link wcPlay.PROPERTY} value. * @typedef {Object} wcNode~SelectOptions * @property {String} [description] - An optional description to display as a tooltip for this property. * @property {wcNode~PropertyDisplay} [display] - An optional function that will be called to retrieve the display string for the value/initial value for this property. * @property {wcNode~ExportValue} [exportValue] - An optional function that will retrieve the property's value when it is about to be exported to file. * @property {Boolean} [input] - If true, this property will have an input link so its value can be changed through script. * @property {Boolean} [output] - If true, this property will have an output link so its value can be retrieved through script. * @property {Boolean} [linked] - If true, the value and initial values will be linked and can not be separated. Changing either will change them both. * @property {wcNode~SelectItem[]|String[]|wcNode~SelectItemFunc} items - A list of items to display in the combo box, or a callback function that can dynamically retrieve a list. * @property {Boolean} [allowNone=true] - If true, will allow the user to select '&lt;none&gt;' as an option. * @property {Object} [noneValue] - If supplied, and allowNone is true, will assign the internal value of the '&lt;none&gt;' option. */ /** * Options for a [CUSTOM]{@link wcPlay.PROPERTY} value. * @typedef {Object} wcNode~CustomOptions * @property {String} [description] - An optional description to display as a tooltip for this property. * @property {wcNode~PropertyDisplay} [display] - An optional function that will be called to retrieve the display string for the value/initial value for this property. * @property {wcNode~ExportValue} [exportValue] - An optional function that will retrieve the property's value when it is about to be exported to file. * @property {Boolean} [input] - If true, this property will have an input link so its value can be changed through script. * @property {Boolean} [output] - If true, this property will have an output link so its value can be retrieved through script. * @property {Boolean} [linked] - If true, the value and initial values will be linked and can not be separated. Changing either will change them both. * @property {wcNode~CustomCreateFunc} [onCreate] - If supplied, will be called when the property control is being edited and should return an element to display the control. */ /** * A callback that dynamically retrieves a list of items to display in a Select property. * @callback wcNode~SelectItemFunc * @param {wcNode~SelectItem[]|String[]} items - A list of items to display in the combo box. */ /** * A callback function to generate a custom property control, this should generate the necessary controls and return a containing control element. * @callback wcNode~CustomCreateFunc * @param {wcNode} node - The node. * @param {String} name - The property name being changed. * @param {Object} value - The property value. * @param {Boolean} isInitial - If true, the property being changed is the initial value. * @param {wcNode~CustomOnChangedFunc} onChanged - A function to call when the property value has been changed. * @returns {external:jQuery~Object} - A containing element that contains the control. */ /** * Used with the custom property type, a callback to call when the property value has changed. This allows for proper undo management. * @callback wcNode~CustomOnChangedFunc * @param {Object} newValue - The new value. */ /** * A select property item. * @typedef {Object} wcNode~SelectItem * @property {String} name - The display text to display for this item. * @property {String|Number} value - The value to assign to the property when this property is selected. */ /** * Basic information about a chain connection. * @typedef {Object} wcNode~ChainData * @property {String} inName - The name of the input or entry link this chain is connected to. * @property {Number} inNodeId - The ID of the input or entry node this chain is connected to. * @property {String} outName - The name of the output or exit link this chain is connected to. * @property {Number} outNodeId - The ID of the output or exit node this chain is connected to. */ /** * Basic information for a property. * @typedef {Object} wcNode~PropertyData * @property {String} name - The name of the property. * @property {Object} value - The current value of the property. * @property {Object} initialValue - The initial value of the property. */  Search results Close "},"play.js.html":{"id":"play.js.html","title":"Source: play.js","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Source: play.js /** * @class * The main scripting engine. * * @constructor * @param {wcPlay~Options} [options] - Custom options. */ function wcPlay(options) { this._compositeNodes = []; this._entryNodes = []; this._processNodes = []; this._storageNodes = []; this._properties = []; this._waitingChain = []; this._queuedChain = []; this._queuedProperties = []; this._importedScripts = []; this._updateId = 0; this._isRunning = false; this._isPaused = false; this._isPausing = false; this._isStepping = false; this._customData = null; this._editors = []; // Setup our options. this._options = { silent: false, updateRate: 25, updateLimit: 100, debugging: true, }; for (var prop in options) { this._options[prop] = options[prop]; } if (!this._updateId) { var self = this; this._updateId = setInterval(function() { self.update(); }, this._options.updateRate); } wcPlay.INSTANCE_LIBRARY.push(this); }; /** * Determines how a property's control should be rendered within the editor view. * @enum {String} */ wcPlay.PROPERTY = { /** Displays the property as a string, but does not enforce or convert its type. [String options]{@link wcNode~StringOptions} are used. */ DYNAMIC: 'dynamic', /** Displays the property as a checkbox. [Default options]{@link wcNode~PropertyOptions} are used. */ TOGGLE: 'toggle', /** Displays the property as a number control. [Number options]{@link wcNode~NumberOptions} are used. */ NUMBER: 'number', /** Displays the property as a text field. [String options]{@link wcNode~StringOptions} are used. */ STRING: 'string', /** Displays the property as a combo box control. [Select options]{@link wcNode~SelectOptions} are used. */ SELECT: 'select', /** Displays the property as a custom control. [Custom options]{@link wcNode~CustomOptions} are used. */ CUSTOM: 'custom', }; /** * The different types of nodes. * @enum {String} */ wcPlay.NODE = { /** Entry nodes mark the beginning of an execution flow chain and are usually triggered by some type of event that happens outside of the script. */ ENTRY: 'entry', /** Process nodes perform a process, often very simple, and make up the bulk of a flow chain within the script. */ PROCESS: 'process', /** Storage nodes are designed with a single purpose of storing data for use within the script. */ STORAGE: 'storage', /** Composite nodes are a group of nodes combined into a single visible node. They appear in the composite section of the node palette for easy duplication within your script. */ COMPOSITE: 'composite', }; /** * A global list of nodes that exist. All node types must add themselves into this list when they are coded. * @member */ wcPlay.NODE_LIBRARY = []; /** * A global list of play engine instances that exist. * @member */ wcPlay.INSTANCE_LIBRARY = []; /** * A global function that registers a new node type into the library. This is called automatically when a new extended node type is defined, you should not have to do this manually. * @param {String} name - The name of the node constructor. * @param {String} displayName - The display name. * @param {String} category - The display category name. * @param {wcPlay.NODE} nodeType - The node's type. * @returns {Boolean} - Success or failure. */ wcPlay.registerNodeType = function(name, displayName, category, nodeType) { var data = { className: name, displayName: displayName, category: category, nodeType: nodeType, }; for (var i = 0; i &lt; wcPlay.NODE_LIBRARY.length; ++i) { if (wcPlay.NODE_LIBRARY[i].className === name) { wcPlay.NODE_LIBRARY[i] = data; for (var a = 0; a &lt; wcPlay.INSTANCE_LIBRARY.length; ++a) { var play = wcPlay.INSTANCE_LIBRARY[a]; for (var b = 0; b &lt; play._editors.length; ++b) { var editor = play._editors[b]; editor.__setupPalette(); } } return true; } } wcPlay.NODE_LIBRARY.push(data); return true; }; /** * A global function that unregisters a node type from the library. * @param {String} name - The name of the node constructor. * @returns {Boolean} - True if the node type has been found and removed. */ wcPlay.unregisterNodeType = function(name) { for (var i = 0; i &lt; wcPlay.NODE_LIBRARY.length; ++i) { if (wcPlay.NODE_LIBRARY[i].className === name) { wcPlay.NODE_LIBRARY.splice(i, 1); for (var a = 0; a &lt; wcPlay.INSTANCE_LIBRARY.length; ++a) { var play = wcPlay.INSTANCE_LIBRARY[a]; for (var b = 0; b &lt; play._editors.length; ++b) { var editor = play._editors[b]; editor.__setupPalette(); } } return true; } } return false; }; wcPlay.prototype = { /** * Initializes the script and begins the update process. * @function wcPlay#start */ start: function() { this.reset(); this._isRunning = true; this._isPaused = false; this._isPausing = false; this._isStepping = false; this.notifyNodes('onStart', []); }, /** * Stops the script. * @function wcPlay#stop */ stop: function() { this._isRunning = false; this.notifyNodes('onStop', []); }, /** * Retrieves whether the script is running. * @function wcPlay#isRunning * @returns {Boolean} */ isRunning: function() { return this._isRunning; }, /** * Resets all volotile data in the script. * @function wcPlay#reset */ reset: function() { for (var i = 0; i &lt; this._compositeNodes.length; ++i) { this._compositeNodes[i].reset(); } for (var i = 0; i &lt; this._entryNodes.length; ++i) { this._entryNodes[i].reset(); } for (var i = 0; i &lt; this._processNodes.length; ++i) { this._processNodes[i].reset(); } for (var i = 0; i &lt; this._storageNodes.length; ++i) { this._storageNodes[i].reset(); } this._queuedChain = []; this._queuedProperties = []; for (var i = 0; i &lt; this._properties.length; ++i) { this.property(this._properties[i].name, this._properties[i].initialValue, true); } }, /** * Clears all nodes from the script. * @function wcPlay#clear */ clear: function() { this._queuedChain = []; this._queuedProperties = []; this._waitingChain = []; this._properties = []; while (this._compositeNodes.length) { this._compositeNodes[0].destroy(); } while (this._entryNodes.length) { this._entryNodes[0].destroy(); } while (this._processNodes.length) { this._processNodes[0].destroy(); } while (this._storageNodes.length) { this._storageNodes[0].destroy(); } }, /** * Serializes the script into a string that can be saved into a file and [restored]{@link wcPlay#load}. * @function wcPlay#save * @returns {String} - A serialized string with the entire script. */ save: function() { var data = { version: '1.0.0' }; data.custom = this.customData(); data.properties = this.listProperties(); data.nodes = []; for (var i = 0; i &lt; this._compositeNodes.length; ++i) { data.nodes.push(this._compositeNodes[i].export(true)); } for (var i = 0; i &lt; this._entryNodes.length; ++i) { data.nodes.push(this._entryNodes[i].export(true)); } for (var i = 0; i &lt; this._processNodes.length; ++i) { data.nodes.push(this._processNodes[i].export(true)); } for (var i = 0; i &lt; this._storageNodes.length; ++i) { data.nodes.push(this._storageNodes[i].export(true)); } return JSON.stringify(data, function(key, value) { if (value == Infinity) { return &quot;Infinity&quot;; } return value; }); }, /** * Loads a script from previously serialized data generated by [save]{@link wcPlay#save}. * @function wcPlay#load * @param {String} serialData - The serialized data to load. * @returns {Boolean} - Success or failure. */ load: function(serialData) { // For safety in case the imported file does not load property, save the current state of the script so we can restore it if necessary. var saveData = this.save(); try { var data = JSON.parse(serialData, function(key, value) { if (value === 'Infinity') { return Infinity; } return value; }); this.customData(data.custom); this.clear(); for (var i = 0; i &lt; data.properties.length; ++i) { this.createProperty(data.properties[i].name, data.properties[i].type, data.properties[i].initialValue, data.properties[i].options); } // First pass, create all nodes. var nodes = []; for (var i = 0; i &lt; data.nodes.length; ++i) { if (window[data.nodes[i].className]) { try { var newNode = new window[data.nodes[i].className](this, data.nodes[i].pos, data.nodes[i].name); newNode.id = data.nodes[i].id; nodes.push({ node: newNode, data: data.nodes[i] }); } catch (e) { console.log('ERROR: Attempted to load node &quot;' + data.nodes[i].className + '&quot; with error :' + e); } } else { console.log('ERROR: Attempted to load node &quot;' + data.nodes[i].className + '&quot;, but the constructor could not be found!'); } } // Second pass, import each node's serialized data. for (var i = 0; i &lt; nodes.length; ++i) { nodes[i].node.import(nodes[i].data); } this.reset(); return true; } catch (e) { // Something went wrong, restore the previous script. console.log(e.stack); this.load(saveData); } return false; }, /** * Gets, or Sets a custom data object to the script that will be saved and restored with the output file data.&lt;br&gt; * NOTE: Binding new data will always replace any data that may have been previously bound. * @function wcPlay#customData * @param {Object|Function} [data] - If supplied, will assign a new custom data. If you supply a function, it will be invoked when retrieving the data. If not supplied, will retrieve the currently bound data. * @returns {Object} - The current custom data object. */ customData: function(data) { if (typeof data !== 'undefined') { this._customData = data; } if (typeof this._customData === 'function') { return this._customData(); } return this._customData; }, /** * Imports a script as a new composite node that can be retrieved with {@link wcPlay#importedComposites}. * @function wcPlay#import * @param {String} serialData - The serialized data to import. * @returns {Boolean} - Whether the new composite node was created. */ import: function(serialData, name) { var newNode = null; try { var data = JSON.parse(serialData, function(key, value) { if (value === 'Infinity') { return Infinity; } return value; }); // TODO: Ignore properties on the script? data.pos = {x: 0, y: 0}; newNode = new wcNodeCompositeScript(this, data.pos); newNode.nodeType = wcPlay.NODE.COMPOSITE; newNode.category = &quot;Imported&quot;; data.id = newNode.id; data.name = name; data.color = newNode.color; data.collapsed = false; data.breakpoint = false; data.properties = []; data.entryChains = []; data.exitChains = []; data.inputChains = []; data.outputChains = []; newNode.import(data, []); newNode._parent = null; this.__removeNode(newNode); this._importedScripts.push(newNode); return true; } catch (e) { if (newNode) { newNode.destroy(); } } return false; }, /** * Retrieves the list of all imported composite nodes. * @function wcPlay#importedComposites * @returns {wcNodeCompositeScript[]} - An array of imported composite nodes. * @see wcPlay#importComposite */ importedComposites: function() { return this._importedScripts; }, /** * Update handler. * @function wcPlay#update */ update: function() { // Skip updates on pause. if (this._isPaused) { return; } var count = Math.min(this._queuedProperties.length, this._options.updateLimit); if (this._isRunning &amp;&amp; !count &amp;&amp; this._waitingChain.length) { // If no properties are queued, but we have waiting flow nodes, add them to the queue for next update. for (var i = 0; i &lt; this._waitingChain.length; ++i) { var item = this._waitingChain[i]; this.queueNodeEntry(item.node, item.name, item.fromNode, item.fromName, true); } this._waitingChain = []; return; } // Update a queued properties if any var index = count; while (index) { index--; var item = this._queuedProperties.shift(); item.node._meta.flash = true; if (item.node._meta.broken &gt; 0) { item.node._meta.broken--; } item.node.property(item.name, item.value, (item.upstream? false: undefined), item.upstream); } // Update a queued node entry only if there are no more properties to update. if (this._isRunning &amp;&amp; !count) { count = Math.min(this._queuedChain.length, this._options.updateLimit - count); index = count; while (index) { index--; var item = this._queuedChain.shift(); item.node._meta.flash = true; if (item.node._meta.broken &gt; 0) { item.node._meta.broken--; } item.node.onActivated(item.name); } } // If we are step debugging, pause the script here. if (this._isStepping) { this._isPausing = true; } }, /** * Retrieves a node from a given ID, if it exists in this script. * @function wcPlay#nodeById * @param {Number} id - The ID of the node. * @returns {wcNode|null} - Either the found node, or null. */ nodeById: function(id) { for (var i = 0; i &lt; this._compositeNodes.length; ++i) { if (this._compositeNodes[i].id === id) { return this._compositeNodes[i]; } } for (var i = 0; i &lt; this._entryNodes.length; ++i) { if (this._entryNodes[i].id === id) { return this._entryNodes[i]; } } for (var i = 0; i &lt; this._processNodes.length; ++i) { if (this._processNodes[i].id === id) { return this._processNodes[i]; } } for (var i = 0; i &lt; this._storageNodes.length; ++i) { if (this._storageNodes[i].id === id) { return this._storageNodes[i]; } } for (var i = 0; i &lt; this._compositeNodes.length; ++i) { if (this._compositeNodes[i].instanceOf('wcNodeCompositeScript')) { var found = this._compositeNodes[i].nodeById(id); if (found) { return found; } } } return null; }, /** * Retrieves a list of nodes that match a given class name, if they exists in this script. * @function wcPlay#nodesByClassName * @param {String} className - The className of the nodes to retrieve. * @returns {wcNode[]} - A list of all found nodes. */ nodesByClassName: function(className) { var result = []; for (var i = 0; i &lt; this._compositeNodes.length; ++i) { if (this._compositeNodes[i].className === className) { result.push(this._compositeNodes[i]); } } for (var i = 0; i &lt; this._entryNodes.length; ++i) { if (this._entryNodes[i].className === className) { result.push(this._entryNodes[i]); } } for (var i = 0; i &lt; this._processNodes.length; ++i) { if (this._processNodes[i].className === className) { result.push(this._processNodes[i]); } } for (var i = 0; i &lt; this._storageNodes.length; ++i) { if (this._storageNodes[i].className === className) { result.push(this._storageNodes[i]); } } for (var i = 0; i &lt; this._compositeNodes.length; ++i) { if (this._compositeNodes[i].instanceOf('wcNodeCompositeScript')) { var found = this._compositeNodes[i].nodesByClassName(className); if (found.length) { result = result.concat(found); } } } return result; }, /** * Retrieves a list of nodes that match a given search filter. * @function wcPlay#nodesBySearch * @param {String} search - The search value. * @returns {wcNode[]} - A list of all found nodes. */ nodesBySearch: function(search) { var result = []; for (var i = 0; i &lt; this._compositeNodes.length; ++i) { if (this._compositeNodes[i].search(search)) { result.push(this._compositeNodes[i]); } } for (var i = 0; i &lt; this._entryNodes.length; ++i) { if (this._entryNodes[i].search(search)) { result.push(this._entryNodes[i]); } } for (var i = 0; i &lt; this._processNodes.length; ++i) { if (this._processNodes[i].search(search)) { result.push(this._processNodes[i]); } } for (var i = 0; i &lt; this._storageNodes.length; ++i) { if (this._storageNodes[i].search(search)) { result.push(this._storageNodes[i]); } } for (var i = 0; i &lt; this._compositeNodes.length; ++i) { if (this._compositeNodes[i].instanceOf('wcNodeCompositeScript')) { var found = this._compositeNodes[i].nodesBySearch(search); if (found.length) { result = result.concat(found); } } } return result; }, /** * Gets, or Sets whether the script is running in [silent mode]{@link wcPlay~Options}. * @function wcPlay#silent * @param {Boolean} silent - If supplied, assigns a new silent state of the script. * @returns {Boolean} - The current silent state of the script. */ silent: function(silent) { if (silent !== undefined) { this._options.silent = silent? true: false; } return this._options.silent; }, /** * Gets, or Sets the debugging state of the script. * @function wcPlay#debugging * @param {Boolean} [debug] - If supplied, will assign the debugging state of the script. * @returns {Boolean} - The current debugging state of the script. */ debugging: function(debug) { if (debug !== undefined) { this._options.debugging = debug? true: false; } return this._options.debugging; }, /** * Gets, or Sets the pause state of the script. * @function wcPlay#paused * @param {Boolean} [paused] - If supplied, will assign the paused state of the script. * @returns {Boolean} - The current pause state of the script. */ paused: function(paused) { if (paused !== undefined) { paused = paused? true: false; if (this._isPaused !== paused) { for (var i = 0; i &lt; this._compositeNodes.length; ++i) { this._compositeNodes[i].paused(paused); } for (var i = 0; i &lt; this._entryNodes.length; ++i) { this._entryNodes[i].paused(paused); } for (var i = 0; i &lt; this._processNodes.length; ++i) { this._processNodes[i].paused(paused); } for (var i = 0; i &lt; this._storageNodes.length; ++i) { this._storageNodes[i].paused(paused); } this._isPaused = paused; this._isPausing = false; } } return this._isPaused; }, /** * Gets, or Sets the stepping state of the script. * @function wcPlay#stepping * @param {Boolean} [stepping] - If supplied, will assign the stepping state of the script. * @returns {Boolean} - The current stepping state of the script. */ stepping: function(stepping) { if (stepping !== undefined) { this._isStepping = stepping? true: false; } return this._isStepping; }, /** * Creates a new global property (can be used with the global storage node). * @function wcPlay#createProperty * @param {String} name - The name of the property. * @param {wcPlay.PROPERTY} type - The type of property. * @param {Object} [initialValue] - A default value for this property. * @param {Object} [options] - Additional options for this property, see {@link wcPlay.PROPERTY}. * @returns {Boolean} - Fails if the property does not exist. */ createProperty: function(name, type, initialValue, options) { // Make sure this property doesn't already exist. for (var i = 0; i &lt; this._properties.length; ++i) { if (this._properties[i].name === name) { return false; } } if (initialValue === undefined) { initialValue = 0; } this._properties.push({ name: name, value: initialValue, initialValue: initialValue, type: type, options: options || {}, }); return true; }, /** * Renames an existing global property. * @function wcPlay#renameProperty * @param {String} name - The current name of the global property to rename. * @param {String} newName - The new desired name of the global property. * @returns {Boolean} - Fails if the property was not found or if the new name is already used. */ renameProperty: function(name, newName) { var prop = null; for (var i = 0; i &lt; this._properties.length; ++i) { if (this._properties[i].name === newName) { return false; } if (this._properties[i].name === name) { prop = this._properties[i]; } } if (!prop) { return false; } prop.name = newName; this.notifyNodes('onGlobalPropertyRenamed', [name, newName]); }, /** * Removes a global property. * @function wcPlay#removeProperty * @param {String} name - The name of the property to remove. * @returns {Boolean} - Fails if the property does not exist. */ removeProperty: function(name) { for (var i = 0; i &lt; this._properties.length; ++i) { if (this._properties[i].name === name) { this.notifyNodes('onGlobalPropertyRemoved', [name]); this._properties.splice(i, 1); return true; } } return false; }, /** * Gets, or Sets a global property value. * @function wcPlay#property * @param {String} name - The name of the property. * @param {Object} [value] - If supplied, will assign a new value to the property. * @returns {Object} - The current value of the property, or undefined if not found. */ property: function(name, value) { var prop = null; for (var i = 0; i &lt; this._properties.length; ++i) { if (this._properties[i].name === name) { prop = this._properties[i]; break; } } if (!prop) { return; } if (value !== undefined &amp;&amp; value !== prop.value) { var oldValue = prop.value; prop.value = value; this.notifyNodes('onGlobalPropertyChanged', [prop.name, oldValue, prop.value]); } return prop.value; }, /** * Gets, or Sets a global property initial value. * @function wcPlay#initialProperty * @param {String} name - The name of the property. * @param {Object} [value] - If supplied, will assign a new value to the property. * @returns {Object} - The current value of the property, or undefined if not found. */ initialProperty: function(name, value) { var prop = null; for (var i = 0; i &lt; this._properties.length; ++i) { if (this._properties[i].name === name) { prop = this._properties[i]; break; } } if (!prop) { return; } if (value !== undefined &amp;&amp; value !== prop.initialValue) { var oldValue = prop.initialValue; prop.initialValue = value; this.notifyNodes('onGlobalInitialPropertyChanged', [prop.name, oldValue, prop.initialValue]); if (prop.value == oldValue) { prop.value = value; this.notifyNodes('onGlobalPropertyChanged', [prop.name, oldValue, prop.value]); } } return prop.initialValue; }, /** * Retrieves a list of all global properties and their values for this script. * @function wcPlay#listProperties * @returns {wcNode~PropertyData[]} - A list of all property data. */ listProperties: function() { var result = []; for (var i = 0; i &lt; this._properties.length; ++i) { var myProp = this._properties[i]; result.push({ name: myProp.name, value: myProp.value, initialValue: myProp.initialValue, type: myProp.type, options: myProp.options, }); } return result; }, /** * Triggers an event into the Play script. * @function wcPlay#triggerEvent * @param {String} type - The type name of the node (as displayed in the title). * @param {String} [name] - The event name to trigger (as displayed in the title between the parenthesis). Use an empty string to ignore the name. * @param {Object} [data] - Any data object that will be passed into the entry node. */ triggerEvent: function(type, name, data) { for (var i = 0; i &lt; this._entryNodes.length; ++i) { if (this._entryNodes[i].type === type &amp;&amp; (!name || this._entryNodes[i].name === name)) { this._entryNodes[i].onActivated(data); } } }, /** * Sends a custom notification event to all nodes. * @function wcPlay#notifyNodes * @param {String} func - The node function to call. * @param {Object[]} args - A list of arguments to forward into the function call. * @param {Boolean} [includeEditorPalette] - If true, will also notify all nodes generated for use with editor palette views. */ notifyNodes: function(func, args, includeEditorPalette) { var self; for (var i = 0; i &lt; this._compositeNodes.length; ++i) { self = this._compositeNodes[i]; if (typeof self[func] === 'function') { self[func].apply(self, args); } } for (var i = 0; i &lt; this._entryNodes.length; ++i) { self = this._entryNodes[i]; if (typeof self[func] === 'function') { self[func].apply(self, args); } } for (var i = 0; i &lt; this._processNodes.length; ++i) { self = this._processNodes[i]; if (typeof self[func] === 'function') { self[func].apply(self, args); } } for (var i = 0; i &lt; this._storageNodes.length; ++i) { self = this._storageNodes[i]; if (typeof self[func] === 'function') { self[func].apply(self, args); } } for (var i = 0; i &lt; this._compositeNodes.length; ++i) { if (this._compositeNodes[i].instanceOf('wcNodeCompositeScript')) { this._compositeNodes[i].notifyNodes(func, args); } } if (includeEditorPalette) { this.notifyEditors('notifyPaletteNodes', [func, args]); } }, /** * Sends a custom notification event to all renderers. * @function wcPlay#notifyEditors * @param {String} func - The renderer function to call. * @param {Object[]} args - A list of arguments to forward into the function call. */ notifyEditors: function(func, args) { var self; for (var i = 0; i &lt; this._editors.length; ++i) { self = this._editors[i]; if (typeof self[func] === 'function') { self[func].apply(self, args); } } }, /** * Queues a node entry link to trigger on the next update. * @function wcPlay#queueNodeEntry * @param {wcNode} node - The node being queued. * @param {String} name - The entry link name. * @param {wcNode} fromNode - The node causing the queue. * @param {String} fromName - The exit link name. * @param {Boolean} [forceQueue] - If true, will force the event into the queue rather than the waiting list. */ queueNodeEntry: function(node, name, fromNode, fromName, forceQueue) { // Skip node queueing if the script is not even running. if (!this._isRunning) { return; } if (!forceQueue &amp;&amp; this._isStepping &amp;&amp; this._isPaused) { if (node.enabled()) { this._waitingChain.push({ node: node, name: name, fromNode: fromNode, fromName: fromName }); } return; } if (node.enabled()) { this._queuedChain.push({ node: node, name: name }); if (node.debugBreak() || this._isStepping) { node._meta.flash = true; node._meta.broken++; this._isPausing = true; } // Flash the entry link. for (var i = 0; i &lt; node.chain.entry.length; ++i) { if (node.chain.entry[i].name == name) { node.chain.entry[i].meta.flash = true; if (node.debugBreak() || this._isStepping) { node.chain.entry[i].meta.broken++; } break; } } // Flash the exit link. if (fromNode &amp;&amp; fromName) { for (var i = 0; i &lt; fromNode.chain.exit.length; ++i) { var exitLink = fromNode.chain.exit[i]; if (exitLink.name == fromName) { fromNode.chain.exit[i].meta.flash = true; fromNode._meta.flash = true; if (node.debugBreak() || this._isStepping) { fromNode.chain.exit[i].meta.broken++; } break; } } } if (this._isPausing) { this.paused(true); this._isPausing = false; } } }, /** * Queues a node property value change to trigger on the next update. * @function wcPlay#queueNodeProperty * @param {wcNode} node - The node being queued. * @param {String} name - The property name. * @param {Object} value - The property value. * @param {Boolean} [upstream] - If true, we are propagating the property change in reverse. */ queueNodeProperty: function(node, name, value, upstream) { // Skip node queueing if the script is not even running. if (!this._isRunning) { return; } if (node.enabled() || name === 'enabled') { this._queuedProperties.push({ node: node, name: name, value: value, upstream: upstream, }); // if (this._queuedChain.length &gt; 0) { // this._waitingChain = this._queuedChain; // this._queuedChain = []; // } if (node.debugBreak() || this._isStepping) { node._meta.flash = true; node._meta.broken++; this._isPausing = true; } if (this._isPausing) { this.paused(true); this._isPausing = false; } } }, /** * Destroys this instance. * @function wcPlay#destroy */ destroy: function() { this.clear(); this._importedScripts = []; while (this._editors.length) { this._editors[0].engine(null); } if (this._updateId) { clearInterval(this._updateId); } var index = wcPlay.INSTANCE_LIBRARY.indexOf(this); if (index &gt; -1) { wcPlay.INSTANCE_LIBRARY.splice(index, 1); } }, /** * Retrieves the class name of this object. * @function wcPlay#isA * @returns {String} */ isA: function(name) { return name === 'wcPlay'; }, /** * Retrieves the class name of this object. * @function wcPlay#instanceOf * @returns {String} */ instanceOf: function(name) { return name === 'wcPlay'; }, /** * Adds a node into the known node stacks. * @function wcPlay#__addNode * @private * @param {wcNode} node - The node to add. */ __addNode: function(node) { if (node.instanceOf('wcNodeComposite')) { this._compositeNodes.push(node); } else if (node.instanceOf('wcNodeEntry')) { this._entryNodes.push(node); } else if (node.instanceOf('wcNodeProcess')) { this._processNodes.push(node); } else if (node.instanceOf('wcNodeStorage')) { this._storageNodes.push(node); } }, /** * Removes a node from the known node stacks. * @function wcPlay#__removeNode * @private * @param {wcNode} node - The node to remove. * @returns {Boolean} - Fails if the node was not found in this script. */ __removeNode: function(node) { var index = -1; if (node.instanceOf('wcNodeComposite')) { index = this._compositeNodes.indexOf(node); if (index &gt; -1) { this._compositeNodes.splice(index, 1); } } else if (node.instanceOf('wcNodeEntry')) { index = this._entryNodes.indexOf(node); if (index &gt; -1) { this._entryNodes.splice(index, 1); } } else if (node.instanceOf('wcNodeProcess')) { index = this._processNodes.indexOf(node); if (index &gt; -1) { this._processNodes.splice(index, 1); } } else if (node.instanceOf('wcNodeStorage')) { index = this._storageNodes.indexOf(node); if (index &gt; -1) { this._storageNodes.splice(index, 1); } } // If the node was not found, propagate the removal to all composite nodes. if (index === -1) { for (var i = 0; i &lt; this._compositeNodes.length; ++i) { if (this._compositeNodes[i].instanceOf('wcNodeCompositeScript') &amp;&amp; this._compositeNodes[i].__removeNode(node)) { return true; } } } return false; }, }; function wcNodeTimeoutEvent(node, callback, delay) { this._node = node; this._timerId = 0; this._callback = callback; this._remaining = delay; this._marker = 0; }; wcNodeTimeoutEvent.prototype = { pause: function() { window.clearTimeout(this._timerId); this._remaining -= new Date().getTime() - this._marker; }, resume: function() { this._marker = new Date().getTime(); window.clearTimeout(this._timerId); var self = this; this._timerId = window.setTimeout(function() { self._node.finishThread(self); self._callback &amp;&amp; self._callback.call(self._node); self.__clear(); }, this._remaining); }, __clear: function() { this._node = null; this._callback = null; window.clearTimeout(this._timerId); }, };  Search results Close "},"editor.js.html":{"id":"editor.js.html","title":"Source: editor.js","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Source: editor.js // Create a global clipboard that can be shared between all instances of the editor tool. window.wcPlayEditorClipboard = { bounds: { top: 0, left: 0, width: 0, height: 0, }, nodes: [] }; /** * @class * Provides a visual interface for editing a Play script. Requires HTML5 canvas. * * @constructor * @param {external:jQuery~Object|external:jQuery~Selector|external:domNode} container - The container element. * @param {wcPlayEditor~Options} [options] - Custom options. */ function wcPlayEditor(container, options) { this.$container = $(container); this.$typeButton = []; this.$typeArea = []; this._paletteSize = 150; this._chainStyle = 1; this._chainStyleMax = 1; this._menu = null; this._size = {x: 0, y: 0}; this._engine = null; this._parent = null; this._nodeLibrary = {}; this._eventHandlers = { onBeforeSave: null, onSaved: null, onBeforeLoad: null, onLoaded: null, onBeforeImport: null, onImported: null }; // this._nodeDrawCount = 0; // this._chainDrawCount = 0; this._font = { breadcrumbs: {size: 10, family: 'Arial', weight: 'bold'}, title: {size: 13, family: 'Arial', weight: 'bold'}, titleDesc: {size: 10, family: 'Arial', weight: 'italic'}, details: {size: 9, family: 'Arial', weight: 'bold'}, links: {size: 9, family: 'Arial'}, property: {size: 9, family: 'Arial', weight: 'italic'}, value: {size: 9, family: 'Arial', weight: 'bold'}, initialValue: {size: 9, family: 'Arial', weight: 'bold italic'}, propertyHeader: {size: 8, family: 'Arial', weight: 'bold italic'} }; this._drawStyle = { palette: { spacing: 10, // Spacing between nodes in the palette view. scale: 0.7, // Scale to draw nodes within the palette view. width: 150 // The pixel width of the palette view. }, node: { radius: 7, // The radius to draw node corners. margin: 14 // The pixel space between the property text and the edge of the node border. }, title: { spacing: 5, // The pixel space between the title text and the bar that separates the properties. wrapL: ' ', // The left string to wrap around the title text. wrapR: ' ', // The right string to wrap around the title text. placeholder: ' ', // A placeholder label if there is no title name. nameWrapL: ' (', // The left string to wrap around the name portion of the title text. nameWrapR: ') ', // The right string to wrap around the name portion of the title text. details: ' [?] ' // The text to display for the detail popup button for the node. }, links: { length: 10, // Length of each link 'nub' width: 7, // Width of each link 'nub' spacing: 7, // The pixel space between the text of adjacent links. padding: 5, // The pixel space between the link and its text. margin: 7 // The pixel space between the link text and the edge of the node border. }, property: { spacing: 5, // The pixel space between adjacent properties. strLen: 20, // The maximum character length a property value can display. longStrLen: 43, // The maximum character length a property value can display when in expanded view. minLength: 30, // The minimum length the property value can be. valueWrapL: ' [', // The left string to wrap around a property value. valueWrapR: '] ', // The right string to wrap around a property value. initialWrapL: ' ', // The left string to wrap around a property initial value. initialWrapR: ' ', // The right string to wrap around a property initial value. highlightColor: 'rgba(255, 255, 255, 0.5)', normalColor: 'rgba(255, 255, 255, 0.5)', headerColor: 'rgba(255, 255, 255, 0.2)', highlightBorder: -1, normalBorder: 1, headerBorder: -1 } }; // Update properties. this._lastUpdate = 0; // Control properties. this._viewportCamera = {x: 0, y: 0, z: 1}; this._viewportBounds = {left: 0, top: 0, width: 0, height: 0}; this._viewportMovingNode = false; this._viewportMoving = false; this._viewportMoved = false; this._paletteMoving = false; this._autoScrollDirection = {x: 0, y: 0}; this._autoScrollInterval = 0; this._autoScrollNodes = false; this._mouse = {x: 0, y: 0}; this._mouseInViewport = false; this._highlightRect = null; this._highlightNode = null; this._selectedNode = null; this._selectedNodes = []; this._highlightTitle = false; this._highlightDetails = false; this._highlightDebugLog = false; this._highlightBreakpoint = false; this._highlightEntryLink = false; this._highlightExitLink = false; this._highlightInputLink = false; this._highlightOutputLink = false; this._highlightPropertyValue = false; this._highlightPropertyInitialValue = false; this._highlightViewport = false; this._selectedEntryLink = false; this._selectedExitLink = false; this._selectedInputLink = false; this._selectedOutputLink = false; this._selectedNodeOrigins = []; this._draggingNodeData = null; this._highlightCrumb = -1; this._crumbBounds = []; // Undo management is optional. this._undoManager = null; // Setup our options. this._options = { readOnly: false, playable: true, category: { items: [], isBlacklist: true, }, }; for (var prop in options) { this._options[prop] = options[prop]; } this.$top = $('&lt;div class=&quot;wcPlayEditorTop&quot; tabindex=&quot;1&quot;&gt;'); this.$main = $('&lt;div class=&quot;wcPlayEditorMain&quot; tabindex=&quot;1&quot;&gt;'); this.$palette = $('&lt;div class=&quot;wcPlayPalette wcPlayNoHighlights&quot; tabindex=&quot;1&quot;&gt;'); this.$paletteScroller = $('&lt;div class=&quot;wcPlayPaletteScroller&quot; tabindex=&quot;1&quot;&gt;'); this.$paletteInner = $('&lt;div class=&quot;wcPlayPaletteInner&quot; tabindex=&quot;1&quot;&gt;'); this.$viewport = $('&lt;canvas class=&quot;wcPlayViewport&quot; tabindex=&quot;1&quot;&gt;'); this._viewportContext = this.$viewport[0].getContext('2d'); this.$palette.append(this.$paletteScroller); this.$paletteScroller.append(this.$paletteInner); this.$main.append(this.$palette); this.$main.append(this.$viewport); this.$container.append(this.$top); this.$container.append(this.$main); this.$search = $('&lt;div class=&quot;wcPlayEditorSearch wcPlayHidden&quot;&gt;&lt;span&gt;Search&lt;/span&gt;&lt;input type=&quot;text&quot;/&gt;&lt;i class=&quot;fa fa-chevron-up wcPlayEditorSearchPrev&quot;/&gt;&lt;i class=&quot;fa fa-chevron-down wcPlayEditorSearchNext&quot;/&gt;&lt;/div&gt;'); this.$hiddenFileLoader = $('&lt;input type=&quot;file&quot; id=&quot;wcPlayEditorHiddenFileLoader&quot;/&gt;'); this.$hiddenFileImporter = $('&lt;input type=&quot;file&quot; id=&quot;wcPlayEditorHiddenFileImporter&quot;/&gt;'); this.$container.append(this.$search); this.onResized(); this.__setupMenu(); this.__setupControls(); this.$top.focus(); window.requestAnimationFrame(this.__update.bind(this)); } wcPlayEditor.prototype = { /** * Retrieves whether unsaved changes exist in the current script. * @function wcPlayEditor#isModified * @returns {Boolean} */ isModified: function() { if (this._engine &amp;&amp; this._engine._undoManager) { return this._engine._undoManager.isModified(); } return false; }, /** * Clears the modified state of the current script. * Note, this is done automatically when saving the script, * use this only under special circumstances. * @function wcPlayEditor#clearModified */ clearModified: function() { if (this._engine &amp;&amp; this._engine._undoManager) { this._engine._undoManager.clearModified(); } }, /** * Gets, or Sets the {@link wcPlay} engine that this renderer will render. * @function wcPlayEditor#engine * @param {wcPlay} [engine] - If supplied, will assign a new {@link wcPlay} engine to render. * @returns {wcPlay} - The current {@link wcPlay} engine. */ engine: function(engine) { if (engine !== undefined &amp;&amp; engine !== this._engine) { if (this._engine) { var index = this._engine._editors.indexOf(this); if (index &gt; -1) { this._engine._editors.splice(index, 1); } this._engine._undoManager = this._undoManager; this._undoManager = null; } this._engine = engine; this._parent = engine; this.__setupPalette(); this.center(); if (this._engine) { this._engine._editors.push(this); this._undoManager = this._engine._undoManager; if (!this._undoManager &amp;&amp; window.wcUndoManager) { this._undoManager = new wcUndoManager(); this._engine._undoManager = this._undoManager; } } } return this._engine; }, /** * Retrieves the current modified state of the editor. /** * Retrieves the menu instance. * @function wcPlayEditor#menu * @returns {wcMenu} */ menu: function() { return this._menu; }, /** * Positions the canvas view to the center of all nodes. * @function wcPlayEditor#center */ center: function() { if (this._parent) { this.focus(this._parent._entryNodes.concat(this._parent._processNodes, this._parent._storageNodes, this._parent._compositeNodes)); } }, /** * Scrolls the canvas view until a given set of nodes are within view. * @function wcPlayEditor#focus * @param {wcNode} nodes - A list of nodes to focus the view on. */ focus: function(nodes) { if (nodes.length) { this.__updateNodes(nodes, 0, this._viewportContext); this.__drawNodes(nodes, this._viewportContext); var boundList = []; var offsetList = []; for (var i = 0; i &lt; nodes.length; ++i) { boundList.push(nodes[i]._meta.bounds.farRect); offsetList.push(nodes[i].pos); } var focusRect = this.__expandRect(boundList, offsetList); // Clamp the focus rect to a minimum size, so we can not zoom in too far. if (focusRect.width &lt; 1000) { focusRect.left -= (1000 - focusRect.width)/2; focusRect.width = 1000; } this.focusRect(focusRect); } }, /** * Scrolls the canvas view and centers on a given bounding rectangle. * @function wcPlayEditor#focusRect * @param {wcPlayEditor~Rect} rect - The rectangle to focus on. */ focusRect: function(rect) { var scaleX = this.$viewport.width()? (this.$viewport.width() / (rect.width + 100)): 1; var scaleY = this.$viewport.height()? (this.$viewport.height() / (rect.height + 100)): 1; this._viewportCamera.z = Math.min(scaleX, scaleY); if (scaleX &gt; scaleY) { rect.left -= ((this.$viewport.width() / scaleY - (rect.width + 100))) / 2; } else { rect.top -= ((this.$viewport.height() / scaleX - (rect.height + 100))) / 2; } this._viewportCamera.x = -(rect.left - 50) * this._viewportCamera.z; this._viewportCamera.y = -(rect.top - 50) * this._viewportCamera.z; }, /** * Sends a custom notification event to all nodes. * @function wcPlayEditor#notifyPaletteNodes * @param {String} func - The node function to call. * @param {Object[]} args - A list of arguments to forward into the function call. */ notifyPaletteNodes: function(func, args) { for (var cat in this._nodeLibrary) { for (var type in this._nodeLibrary[cat]) { var typeData = this._nodeLibrary[cat][type]; for (var i = 0; i &lt; typeData.nodes.length; ++i) { var node = typeData.nodes[i]; if (typeof node[func] === 'function') { node[func].apply(node, args); } } } } }, /** * Triggers a previously bound event handler. * @function wcPlayEditor#triggerEvent * @param {String} eventName - The name of the event to trigger. */ triggerEvent: function(eventName, args) { if (this._eventHandlers.hasOwnProperty(eventName)) { if (this._eventHandlers[eventName]) { this._eventHandlers[eventName].apply(this, args); } } }, /** * Binds an event handler for when we are about to save our script. * @function wcPlayEditor#onBeforeSave * @param {Function} func - Assigns the function to handle this event. * @returns {Boolean} - Success or failure. */ onBeforeSave: function(func) { if (typeof func !== 'function') { console.log('Failed to bind event handler for onBeforeSave, argument must be a function!'); return false; } this._eventHandlers.onBeforeSave = func; return true; }, /** * Binds an event handler for when we are about to save our script. * @function wcPlayEditor#onSaved * @param {Function} func - Assigns the function to handle this event. * @returns {Boolean} - Success or failure. */ onSaved: function(func) { if (typeof func !== 'function') { console.log('Failed to bind event handler for onSaved, argument must be a function!'); return false; } this._eventHandlers.onSaved = func; return true; }, /** * Binds an event handler for when we are about to save our script. * @function wcPlayEditor#onBeforeLoad * @param {Function} func - Assigns the function to handle this event. * @returns {Boolean} - Success or failure. */ onBeforeLoad: function(func) { if (typeof func !== 'function') { console.log('Failed to bind event handler for onBeforeLoad, argument must be a function!'); return false; } this._eventHandlers.onBeforeLoad = func; return true; }, /** * Binds an event handler for when we are about to save our script. * @function wcPlayEditor#onLoaded * @param {Function} func - Assigns the function to handle this event. * @returns {Boolean} - Success or failure. */ onLoaded: function(func) { if (typeof func !== 'function') { console.log('Failed to bind event handler for onLoaded, argument must be a function!'); return false; } this._eventHandlers.onLoaded = func; return true; }, /** * Binds an event handler for when we are about to save our script. * @function wcPlayEditor#onBeforeImport * @param {Function} func - Assigns the function to handle this event. * @returns {Boolean} - Success or failure. */ onBeforeImport: function(func) { if (typeof func !== 'function') { console.log('Failed to bind event handler for onBeforeImport, argument must be a function!'); return false; } this._eventHandlers.onBeforeImport = func; return true; }, /** * Binds an event handler for when we are about to save our script. * @function wcPlayEditor#onImported * @param {Function} func - Assigns the function to handle this event. * @returns {Boolean} - Success or failure. */ onImported: function(func) { if (typeof func !== 'function') { console.log('Failed to bind event handler for onImported, argument must be a function!'); return false; } this._eventHandlers.onImported = func; return true; }, /** * Event that is called to begin an undo manager group operation. * @function wcPlayEditor#onBeginUndoGroup * @param {String} description - The description of the undo event. */ onBeginUndoGroup: function(description) { this._undoManager &amp;&amp; this._undoManager.beginGroup(description); }, /** * Event that is called to end an undo manager group operation. * @function wcPlayEditor#onEndUndoGroup */ onEndUndoGroup: function() { this._undoManager &amp;&amp; this._undoManager.endGroup(); }, /** * Event that is called when the container view is resized. * @function wcPlayEditor#onResized */ onResized: function() { var width = this.$main.width(); var height= this.$main.height(); if (this._size.x !== width || this._size.y !== height || this._size.z !== this._paletteSize) { this._size.x = width; this._size.y = height; this._size.z = this._paletteSize; this.$palette.css('width', this._size.z).attr('width', this._size.z).attr('height', height); this.$viewport.css('width', width - this._size.z).attr('width', width - this._size.z).attr('height', height); } this._viewportBounds.top = -this._viewportCamera.y / this._viewportCamera.z; this._viewportBounds.left = -this._viewportCamera.x / this._viewportCamera.z; this._viewportBounds.width = this._size.x / this._viewportCamera.z; this._viewportBounds.height = this._size.y / this._viewportCamera.z; }, /** * Disconnects all chains attached to a node's entry link. * @function wcPlayEditor#onDisconnectEntryChains * @param {wcNode} node - The node to disconnect from. * @param {String} linkName - The name of the link. */ onDisconnectEntryChains: function(node, linkName) { var chains = node.listEntryChains(linkName); if (chains.length) { this._undoManager &amp;&amp; this._undoManager.addEvent('Disconnected Entry Links for &quot;' + node.category + '.' + node.type + '.' + linkName + '&quot;', { id: node.id, name: linkName, chains: chains, engine: this._engine, }, // Undo function() { var myNode = this.engine.nodeById(this.id); for (var i = 0; i &lt; this.chains.length; ++i) { var targetNode = this.engine.nodeById(this.chains[i].outNodeId); var targetName = this.chains[i].outName; myNode.connectEntry(this.name, targetNode, targetName); } }, // Redo function() { var myNode = this.engine.nodeById(this.id); myNode.disconnectEntry(this.name); }); } node.disconnectEntry(linkName); }, /** * Disconnects all chains attached to a node's exit link. * @function wcPlayEditor#onDisconnectExitChains * @param {wcNode} node - The node to disconnect from. * @param {String} linkName - The name of the link. */ onDisconnectExitChains: function(node, linkName) { var chains = node.listExitChains(linkName); if (chains.length) { this._undoManager &amp;&amp; this._undoManager.addEvent('Disconnected Exit Links for &quot;' + node.category + '.' + node.type + '.' + linkName + '&quot;', { id: node.id, name: linkName, chains: chains, engine: this._engine, }, // Undo function() { var myNode = this.engine.nodeById(this.id); for (var i = 0; i &lt; this.chains.length; ++i) { var targetNode = this.engine.nodeById(this.chains[i].inNodeId); var targetName = this.chains[i].inName; myNode.connectExit(this.name, targetNode, targetName); } }, // Redo function() { var myNode = this.engine.nodeById(this.id); myNode.disconnectExit(this.name); }); } node.disconnectExit(linkName); }, /** * Disconnects all chains attached to a node's input link. * @function wcPlayEditor#onDisconnectInputChains * @param {wcNode} node - The node to disconnect from. * @param {String} linkName - The name of the link. */ onDisconnectInputChains: function(node, linkName) { var chains = node.listInputChains(linkName); if (chains.length) { this._undoManager &amp;&amp; this._undoManager.addEvent('Disconnected Property Input Links for &quot;' + node.category + '.' + node.type + '.' + linkName + '&quot;', { id: node.id, name: linkName, chains: chains, engine: this._engine, }, // Undo function() { var myNode = this.engine.nodeById(this.id); for (var i = 0; i &lt; this.chains.length; ++i) { var targetNode = this.engine.nodeById(this.chains[i].outNodeId); var targetName = this.chains[i].outName; myNode.connectInput(this.name, targetNode, targetName); } }, // Redo function() { var myNode = this.engine.nodeById(this.id); myNode.disconnectInput(this.name); }); } node.disconnectInput(linkName); }, /** * Disconnects all chains attached to a node's output link. * @function wcPlayEditor#onDisconnectOutputChains * @param {wcNode} node - The node to disconnect from. * @param {String} linkName - The name of the link. */ onDisconnectOutputChains: function(node, linkName) { var chains = node.listOutputChains(linkName); if (chains.length) { this._undoManager &amp;&amp; this._undoManager.addEvent('Disconnected Property Output Links for &quot;' + node.category + '.' + node.type + '.' + linkName + '&quot;', { id: node.id, name: linkName, chains: chains, engine: this._engine, }, // Undo function() { var myNode = this.engine.nodeById(this.id); for (var i = 0; i &lt; this.chains.length; ++i) { var targetNode = this.engine.nodeById(this.chains[i].inNodeId); var targetName = this.chains[i].inName; myNode.connectOutput(this.name, targetNode, targetName); } }, // Redo function() { var myNode = this.engine.nodeById(this.id); myNode.disconnectOutput(this.name); }); } node.disconnectOutput(linkName); }, /** * Retrieve mouse or touch position. * @function wcPlayEditor#__mouse * @private * @param {Object} event - The mouse event. * @param {wcPlayEditor~Offset} [offset] - An optional screen offset to apply to the pos. * @param {wcPlay~Coordinates} [translation] - An optional camera translation to apply to the pos. * @return {wcPlay~Coordinates} - The mouse position. */ __mouse: function(event, offset, translation) { if (event.originalEvent &amp;&amp; (event.originalEvent.touches || event.originalEvent.changedTouches)) { var touch = event.originalEvent.touches[0] || event.originalEvent.changedTouches[0]; return { x: touch.clientX - (offset? offset.left: 0) - (translation? translation.x: 0), y: touch.clientY - (offset? offset.top: 0) - (translation? translation.y: 0), gx: touch.clientX, gy: touch.clientY, which: 1, }; } return { x: (event.clientX || event.pageX) - (offset? offset.left: 0) - (translation? translation.x: 0), y: (event.clientY || event.pageY) - (offset? offset.top: 0) - (translation? translation.y: 0), gx: (event.clientX || event.pageX), gy: (event.clientY || event.pageY), which: event.which || 1, }; }, /** * Assigns font data to the canvas. * @function wcPlayEditor#__setCanvasFont * @private * @param {Object} font - The font data to assign (wcPlayEditor~_font object). * @param {external:Canvas~Context} context - The canvas context. */ __setCanvasFont: function(font, context) { context.font = (font.weight? font.weight + ' ': '') + (font.size + 'px ') + font.family; }, /** * Clamps a given string value to a specific number of characters and appends a '...' if necessary. * @function wcPlayEditor#__clampString * @private * @param {String} str - The string to clamp. * @param {Number} len - The number of characters to allow. * @returns {String} - A clamped string. */ __clampString: function(str, len) { if (str.length &gt; len) { return str.substr(0, len) + '...'; } return str; }, /** * Blends two colors together. Color strings can be in hex string {'#ffffff'} or rgb string {'rgb(250,250,250)'} formats. * @function wcPlayEditor#__blendColors * @private * @param {String} c0 - The first color string. * @param {String} c1 - The second color string. * @param {Number} p - a multiplier to blend the colors by. */ __blendColors: function(c0, c1, p) { var n=p&lt;0?p*-1:p,u=Math.round,w=parseInt; if(c0.length&gt;7){ var f=c0.split(&quot;,&quot;),t=(c1?c1:p&lt;0?&quot;rgb(0,0,0)&quot;:&quot;rgb(255,255,255)&quot;).split(&quot;,&quot;),R=w(f[0].slice(4)),G=w(f[1]),B=w(f[2]); return &quot;rgb(&quot;+(u((w(t[0].slice(4))-R)*n)+R)+&quot;,&quot;+(u((w(t[1])-G)*n)+G)+&quot;,&quot;+(u((w(t[2])-B)*n)+B)+&quot;)&quot; }else{ var f=w(c0.slice(1),16),t=w((c1?c1:p&lt;0?&quot;#000000&quot;:&quot;#FFFFFF&quot;).slice(1),16),R1=f&gt;&gt;16,G1=f&gt;&gt;8&amp;0x00FF,B1=f&amp;0x0000FF; return &quot;#&quot;+(0x1000000+(u(((t&gt;&gt;16)-R1)*n)+R1)*0x10000+(u(((t&gt;&gt;8&amp;0x00FF)-G1)*n)+G1)*0x100+(u(((t&amp;0x0000FF)-B1)*n)+B1)).toString(16).slice(1) } }, /** * Retrieves a bounding rectangle that encloses all given rectangles. * @function wcPlayEditor#__expandRect * @private * @param {wcPlayEditor~Rect[]} rects - A list of rectangles to expand from. * @param {wcPlay~Coordinates[]} [offsets] - Optional offsets for each rectangle, must be the same size as rects param. * @returns {wcPlayEditor~Rect} - A bounding rectangle that encloses all given rectangles. */ __expandRect: function(rects, offsets) { var bounds = { top: rects[0].top + (offsets? offsets[0].y: 0), left: rects[0].left + (offsets? offsets[0].x: 0), width: rects[0].width, height: rects[0].height, }; for (var i = 1; i &lt; rects.length; ++i) { var offsetX = 0; var offsetY = 0; if (offsets) { offsetX = offsets[i].x; offsetY = offsets[i].y; } if ((rects[i].top + offsetY) &lt; bounds.top) { bounds.top = (rects[i].top + offsetY); } if ((rects[i].left + offsetX) &lt; bounds.left) { bounds.left = (rects[i].left + offsetX); } } for (var i = 0; i &lt; rects.length; ++i) { var offsetX = 0; var offsetY = 0; if (offsets) { offsetX = offsets[i].x; offsetY = offsets[i].y; } if ((rects[i].top + offsetY) + rects[i].height &gt; bounds.top + bounds.height) { bounds.height = ((rects[i].top + offsetY) + rects[i].height) - bounds.top; } if ((rects[i].left + offsetX) + rects[i].width &gt; bounds.left + bounds.width) { bounds.width = ((rects[i].left + offsetX) + rects[i].width) - bounds.left; } } return bounds; }, /** * Tests whether a given point is within a bounding rectangle. * @function wcPlayEditor#__inRect * @private * @param {wcPlay~Coordinates} pos - The position to test. * @param {wcPlayEditor~Rect} rect - The bounding rectangle. * @param {wcPlay~Coordinates} [offset] - An optional offset to apply to the rect. * @param {wcPlay~Coordinates} [trans] - An optional camera translation to apply to the pos. * @returns {Boolean} - Whether there is a collision. */ __inRect: function(pos, rect, offset, trans) { if (offset === undefined) { offset = { x: 0, y: 0, }; } if (trans === undefined) { trans = { x: 0, y: 0, z: 1, }; } if ((pos.y - trans.y) / trans.z &gt;= offset.y + rect.top &amp;&amp; (pos.x - trans.x) / trans.z &gt;= offset.x + rect.left &amp;&amp; (pos.y - trans.y) / trans.z &lt;= offset.y + rect.top + rect.height &amp;&amp; (pos.x - trans.x) / trans.z &lt;= offset.x + rect.left + rect.width) { return true; } return false; }, /** * Tests whether a given rectangle is within a bounding rectangle. * @function wcPlayEditor#__rectOnRect * @private * @param {wcPlayEditor~Rect} rectA - The first rectangle. * @param {wcPlayEditor~Rect} rectB - The second rectangle. * @param {wcPlay~Coordinates} [offsetA] - An optional offset to apply to the rectA. * @returns {Boolean} - Whether there is a collision. */ __rectOnRect: function(rectA, rectB, offsetA) { if (offsetA === undefined) { offsetA = { x: 0, y: 0, }; } return !(rectB.left &gt; offsetA.x + rectA.left + rectA.width || rectB.left + rectB.width &lt; offsetA.x + rectA.left || rectB.top &gt; offsetA.y + rectA.top + rectA.height || rectB.top + rectB.height &lt; offsetA.y + rectA.top); }, /** * Draws a rounded rectangle. * @function wcPlayEditor#__drawRoundedRect * @private * @param {wcPlayEditor~Rect} rect - The rectangle bounds to draw. * @param {String} color - The color of the line. * @param {Number} lineWidth - The thickness of the line, -1 will fill the shape. * @param {Number} radius - The radius of the rounded corners. * @param {external:Canvas~Context} context - The canvas context to render on. * @param {wcPlay~Coordinates} [pos] - An option positional offset to draw the rect. */ __drawRoundedRect: function(rect, color, lineWidth, radius, context, pos) { if (!pos) { pos = {x: 0, y: 0}; } context.save(); context.strokeStyle = color; context.fillStyle = color; context.lineWidth = (lineWidth &gt; 0)? lineWidth: 1; context.beginPath(); context.moveTo(pos.x + rect.left + radius, pos.y + rect.top); context.arcTo(pos.x + rect.left + rect.width, pos.y + rect.top, pos.x + rect.left + rect.width, pos.y + rect.top + radius, radius); context.arcTo(pos.x + rect.left + rect.width, pos.y + rect.top + rect.height, pos.x + rect.left + rect.width - radius, pos.y + rect.top + rect.height, radius); context.arcTo(pos.x + rect.left, pos.y + rect.top + rect.height, pos.x + rect.left, pos.y + rect.top + rect.height - radius, radius); context.arcTo(pos.x + rect.left, pos.y + rect.top, pos.x + rect.left + radius, pos.y + rect.top, radius); context.closePath(); lineWidth == -1? context.fill(): context.stroke(); context.restore(); }, /** * Renders a new frame. * @function wcPlayEditor#__update * @private */ __update: function(timestamp) { if (!this._lastUpdate) { this._lastUpdate = timestamp; } var elapsed = (timestamp - this._lastUpdate) / 1000; this._lastUpdate = timestamp; this.onResized(); this._menu.update(); if (this._parent) { // Render the palette. this.__drawPalette(elapsed); // Setup viewport canvas. this._viewportContext.clearRect(0, 0, this.$viewport.width(), this.$viewport.height()); this._viewportContext.save(); this._viewportContext.translate(this._viewportCamera.x, this._viewportCamera.y); this._viewportContext.scale(this._viewportCamera.z, this._viewportCamera.z); // Update nodes. this.__updateNodes(this._parent._entryNodes, elapsed, this._viewportContext); this.__updateNodes(this._parent._processNodes, elapsed, this._viewportContext); this.__updateNodes(this._parent._storageNodes, elapsed, this._viewportContext); this.__updateNodes(this._parent._compositeNodes, elapsed, this._viewportContext); // Render the nodes in the main script. this.__drawNodes(this._parent._entryNodes, this._viewportContext); this.__drawNodes(this._parent._processNodes, this._viewportContext); this.__drawNodes(this._parent._compositeNodes, this._viewportContext); this.__drawNodes(this._parent._storageNodes, this._viewportContext); // Render chains between nodes. this.__drawChains(this._parent._entryNodes, this._viewportContext); this.__drawChains(this._parent._processNodes, this._viewportContext); this.__drawChains(this._parent._compositeNodes, this._viewportContext); this.__drawChains(this._parent._storageNodes, this._viewportContext); if (this._highlightRect) { var radius = Math.min(10, this._highlightRect.width/2, this._highlightRect.height/2); this.__drawRoundedRect(this._highlightRect, &quot;rgba(0, 255, 255, 0.25)&quot;, -1, radius, this._viewportContext); this.__drawRoundedRect(this._highlightRect, &quot;darkcyan&quot;, 2, radius, this._viewportContext); } // console.log('Draw count - Nodes: ' + this._nodeDrawCount + ', Chains: ' + this._chainDrawCount); // this._nodeDrawCount = 0; // this._chainDrawCount = 0; // if (this._selectedNodes.length) { // var boundList = []; // var offsetList = []; // for (var i = 0; i &lt; this._selectedNodes.length; ++i) { // var node = this._selectedNodes[i]; // boundList.push(node._meta.bounds.farRect); // offsetList.push(node.pos); // } // this.__drawRoundedRect(this.__expandRect(boundList, offsetList), &quot;red&quot;, -1, 10, this._viewportContext); // } this._viewportContext.restore(); // Draw breadcrumbs. var scopes = []; var scopeNames = []; var scope = this._parent; while (!(scope &amp;&amp; scope.instanceOf('wcPlay'))) { scopes.unshift(scope); scopeNames.unshift(scope.type + (scope.name? ' (' + scope.name + ')': '')); scope = scope._parent; } scopes.unshift(this._engine); scopeNames.unshift('Root'); this._viewportContext.fillStyle = 'black'; this.__setCanvasFont(this._font.breadcrumbs, this._viewportContext); this._crumbBounds = []; var left = 2; for (var i = 0; i &lt; scopeNames.length; ++i) { var w = this._viewportContext.measureText(scopeNames[i]).width; var w2 = this._viewportContext.measureText(' / ').width; var boundData = { rect: { top: 0, left: left, width: w + 6, height: this._font.breadcrumbs.size + this._drawStyle.property.spacing, }, parent: scopes[i], }; this._crumbBounds.push(boundData); left += w + w2; if (this._highlightCrumb === i) { this.__drawRoundedRect(boundData.rect, &quot;rgba(0, 255, 255, 0.25)&quot;, -1, 3, this._viewportContext); this.__drawRoundedRect(boundData.rect, &quot;darkcyan&quot;, 2, 3, this._viewportContext); } } this._viewportContext.fillText(scopeNames.join(' / '), 5, this._font.breadcrumbs.size); } window.requestAnimationFrame(this.__update.bind(this)); }, /** * Updates the status of a list of nodes. * @function wcPlayEditor#__updateNodes * @private * @param {wcNode[]} nodes - The nodes to update. * @param {Number} elapsed - Elapsed time since last update. * @param {external:Canvas~Context} context - The canvas context to render on. */ __updateNodes: function(nodes, elapsed, context) { for (var i = 0; i &lt; nodes.length; ++i) { this.__updateNode(nodes[i], elapsed, context); } }, /** * Updates the status of a node. * @function wcPlayEditor#__updateNode * @private * @param {wcNode} node - The Node to update. * @param {Number} elapsed - Elapsed time since last update. * @param {external:Canvas~Context} context - The canvas context to render on. */ __updateNode: function(node, elapsed, context) { node.onDraw(); // Update flash state. var self = this; function __updateFlash(meta, darkColor, lightColor, pauseColor, keepBroken, colorMul) { if (meta.flash) { meta.flashDelta += elapsed * 10.0; if (meta.flashDelta &gt;= 1.0) { meta.flashDelta = 1.0; if (!meta.awake &amp;&amp; (!meta.broken || (!keepBroken &amp;&amp; !self._engine.paused()))) { meta.flash = false; } } } else if (meta.flashDelta &gt; 0.0) { meta.flashDelta -= elapsed * 5.0; if (meta.flashDelta &lt;= 0.0) { meta.flashDelta = 0; meta.broken = keepBroken? meta.broken: meta.broken - 1; } } meta.color = self.__blendColors(darkColor, meta.broken? pauseColor: lightColor, meta.flashDelta * colorMul); } var color = node.color; if (this._highlightNode === node) { color = this.__blendColors(node.color, &quot;#FFFFFF&quot;, 0.25); } __updateFlash(node._meta, color, &quot;#FFFFFF&quot;, &quot;#FFFFFF&quot;, true, 0.5); var blackColor = &quot;#000000&quot;; var propColor = &quot;#117711&quot;; var flashColor = &quot;#FFFF00&quot;; for (var i = 0; i &lt; node.properties.length; ++i) { __updateFlash(node.properties[i].inputMeta, propColor, flashColor, flashColor, false, 0.9); __updateFlash(node.properties[i].outputMeta, propColor, flashColor, flashColor, false, 0.9); } if (this._engine._queuedProperties.length === 0) { for (var i = 0; i &lt; node.chain.entry.length; ++i) { __updateFlash(node.chain.entry[i].meta, blackColor, flashColor, flashColor, false, 0.9); } for (var i = 0; i &lt; node.chain.exit.length; ++i) { __updateFlash(node.chain.exit[i].meta, blackColor, flashColor, flashColor, false, 0.9); } } // Measure bounding areas for node, if it is dirty. if (node._meta.dirty) { node._meta.dirty = false; node._meta.bounds = { node: node, }; var entryBounds = this.__measureEntryLinkOuter(node, context); var outerBounds = this.__measureOuter(node, context, entryBounds.height); var exitBounds = this.__measureExitLinkOuter(node, context, entryBounds.height + outerBounds.height); var bounds = this.__expandRect([entryBounds, outerBounds, exitBounds]); bounds.top = outerBounds.top; bounds.height = outerBounds.height; bounds.propWidth = outerBounds.propWidth; bounds.valueWidth = outerBounds.valueWidth; bounds.initialWidth = outerBounds.initialWidth; node._meta.bounds.entryOuter = entryBounds; node._meta.bounds.exitOuter = exitBounds; node._meta.bounds.centerOuter = outerBounds; node._meta.bounds.rect = this.__expandRect([entryBounds, outerBounds, exitBounds]); node._meta.bounds.inner = this.__expandRect([outerBounds]); node._meta.bounds.inner.left = node._meta.bounds.rect.left; node._meta.bounds.inner.width = node._meta.bounds.rect.width; node._meta.bounds.rect.top -= 3; node._meta.bounds.rect.left -= this._drawStyle.links.length + 3; node._meta.bounds.rect.width += this._drawStyle.links.length * 2 + 6; node._meta.bounds.rect.height += 6; if (node.chain.entry.length) { node._meta.bounds.inner.top -= this._drawStyle.links.padding + this._font.links.size; node._meta.bounds.inner.height += this._drawStyle.links.padding + this._font.links.size; } else { node._meta.bounds.rect.top -= this._drawStyle.links.length; node._meta.bounds.rect.height += this._drawStyle.links.length; } if (node.chain.exit.length) { node._meta.bounds.inner.height += this._drawStyle.links.padding + this._font.links.size; } else { node._meta.bounds.rect.height += this._drawStyle.links.length; } var maxValueWidth = (node._meta.bounds.inner.width - this._drawStyle.node.margin*2 - bounds.propWidth); if (maxValueWidth &gt; bounds.valueWidth + bounds.initialWidth) { var extra = (maxValueWidth - (bounds.valueWidth + bounds.initialWidth)) / 2; bounds.valueWidth += extra; bounds.initialWidth += extra; } // Now use our measurements to draw our node. this.__measureCenter(node, context, bounds); this.__measureEntryLinks(node, context, entryBounds.width); this.__measureExitLinks(node, context, entryBounds.height + outerBounds.height, exitBounds.width); node._meta.bounds.farRect = { top: node._meta.bounds.inner.top - 30, left: node._meta.bounds.inner.left - 30, width: node._meta.bounds.inner.width + 60, height: node._meta.bounds.inner.height + 60, }; // Add a collapse button to the node in the left margin of the title. node._meta.bounds.debugLog = { left: node._meta.bounds.inner.left + 4, top: node._meta.bounds.inner.top + 4 + (node.chain.entry.length? this._font.links.size + this._drawStyle.links.padding: 0), width: this._drawStyle.node.margin - 5, height: this._font.title.size - 4, }; // Add breakpoint button to the node in the right margin of the title. node._meta.bounds.breakpoint = { left: node._meta.bounds.inner.left + node._meta.bounds.inner.width - this._drawStyle.node.margin + 2, top: node._meta.bounds.inner.top + 4 + (node.chain.entry.length? this._font.links.size + this._drawStyle.links.padding: 0), width: this._drawStyle.node.margin - 5, height: this._font.title.size - 4, }; } }, /** * Retrieves the index for a node type. * @function wcPlayEditor#__typeIndex * @private * @param {wcPlay.NODE} type - The node type. * @returns {Number} - The type index. */ __typeIndex: function(type) { switch (type) { case wcPlay.NODE.ENTRY: return 0; case wcPlay.NODE.PROCESS: return 1; case wcPlay.NODE.STORAGE: return 2; case wcPlay.NODE.COMPOSITE: return 3; } }, /** * Initializes the file menu and toolbar. * @function wcPlayEditor#__setupMenu * @private */ __setupMenu: function() { this._menu = new wcMenu(this.$top, { outer: this.$main, manualUpdate: true, data: this, version: &quot;v1.0.0&quot; }); // File -&gt; New Script... this._menu.addOption('File', 'New Script', { hotkeys: &quot;Alt+N&quot;, icon: &quot;fa fa-file-o fa-lg&quot;, description: &quot;Start a new script...&quot;, toolbarIndex: -1, condition: function(editor) { return !editor._options.readOnly; }, onActivated: function(editor) { if (editor._engine) { editor._engine.clear(); editor._undoManager &amp;&amp; editor._undoManager.clear(); editor._parent = editor._engine; } } }); // File -&gt; Open Script... this._menu.addOption('File', 'Open Script...', { hotkeys: &quot;Ctrl+O&quot;, icon: &quot;fa fa-folder-open-o fa-lg&quot;, description: &quot;Open a script file...&quot;, toolbarIndex: -1, condition: function(editor) { return !editor._options.readOnly; }, onActivated: function(editor) { if (editor._engine) { if (document.createEvent) { var evt = document.createEvent(&quot;MouseEvents&quot;); evt.initEvent(&quot;click&quot;, true, false); editor.$container.prepend(editor.$hiddenFileLoader); editor.$hiddenFileLoader[0].dispatchEvent(evt); } } } }); // File -&gt; Save Script this._menu.addOption('File', 'Save Script', { hotkeys: &quot;Ctrl+S&quot;, icon: &quot;fa fa-save fa-lg&quot;, description: &quot;Save this script...&quot;, toolbarIndex: -1, condition: function(editor) { return !editor._options.readOnly; }, onActivated: function(editor) { if (editor._engine) { if (!saveAs) { console.log(&quot;ERROR: Attempted to save the script when external dependency 'FileSaver' was not included.&quot;); return; } editor.triggerEvent('onBeforeSave', []); var savedData = editor._engine.save(); var blob; try { blob = new Blob([savedData], {type: 'text/plain'}); } catch (e) { // Legacy support var bb = new BlobBuilder(); bb.append(savedData); blob = bb.getBlob('text/plain'); } saveAs(blob, 'script.wcplay'); editor._engine._undoManager.clearModified(); editor.triggerEvent('onSaved', []); } } }); // File -&gt; Import... this._menu.addOption('File', 'Import...', { icon: &quot;fa fa-plus-square-o fa-lg&quot;, description: &quot;Import a script file as a Composite Node.&quot;, toolbarIndex: -1, condition: function(editor) { return !editor._options.readOnly; }, onActivated: function(editor) { if (editor._engine) { if (document.createEvent) { var evt = document.createEvent(&quot;MouseEvents&quot;); evt.initEvent(&quot;click&quot;, true, false); editor.$container.prepend(editor.$hiddenFileImporter); editor.$hiddenFileImporter[0].dispatchEvent(evt); } } } }); // Edit -&gt; Undo this._menu.addOption('Edit', 'Undo', { hotkeys: &quot;Ctrl+Z&quot;, icon: &quot;fa fa-undo fa-lg&quot;, toolbarIndex: -1, description: function(editor) { return 'Undo ' + ((editor._undoManager &amp;&amp; editor._undoManager.undoInfo()) || 'Event'); }, condition: function(editor) { return editor._undoManager &amp;&amp; editor._undoManager.canUndo(); }, onActivated: function(editor) { editor._undoManager &amp;&amp; editor._undoManager.undo(); } }); // Edit -&gt; Redo this._menu.addOption('Edit', 'Redo', { hotkeys: &quot;Ctrl+Y,Ctrl+Shift+Z&quot;, icon: &quot;fa fa-undo fa-flip-horizontal fa-lg&quot;, toolbarIndex: -1, description: function(editor) { return 'Redo ' + ((editor._undoManager &amp;&amp; editor._undoManager.redoInfo()) || 'Event'); }, condition: function(editor) { return editor._undoManager &amp;&amp; editor._undoManager.canRedo(); }, onActivated: function(editor) { editor._undoManager &amp;&amp; editor._undoManager.redo(); } }); function __copy(editor) { wcPlayEditorClipboard.nodes = []; var bounds = []; var offsets = []; for (var i = 0; i &lt; editor._selectedNodes.length; ++i) { var node = editor._selectedNodes[i]; var data = node.export(); bounds.push(node._meta.bounds.farRect); offsets.push(node.pos); wcPlayEditorClipboard.nodes.push(data); } wcPlayEditorClipboard.bounds = editor.__expandRect(bounds, offsets); } // Edit -&gt; Cut this._menu.addOption('Edit', 'Cut', { hotkeys: &quot;Ctrl+X&quot;, icon: &quot;fa fa-cut fa-lg&quot;, toolbarIndex: -1, description: &quot;Cut selected node(s) out of your script and into the clipboard.&quot;, condition: function(editor) { return editor._selectedNodes.length &gt; 0; }, onActivated: function(editor) { __copy(editor, editor._engine); editor._undoManager &amp;&amp; editor._undoManager.beginGroup('Cut Nodes to clipboard'); for (var i = 0; i &lt; editor._selectedNodes.length; ++i) { editor.__onDestroyNode(editor._selectedNodes[i]); editor._selectedNodes[i].destroy(); } editor._selectedNodes = []; editor._undoManager &amp;&amp; editor._undoManager.endGroup(); } }); // Edit -&gt; Copy this._menu.addOption('Edit', 'Copy', { hotkeys: &quot;Ctrl+C&quot;, icon: &quot;fa fa-copy fa-lg&quot;, toolbarIndex: -1, description: &quot;Copy selected node(s) to your clipboard.&quot;, condition: function(editor) { return editor._selectedNodes.length &gt; 0; }, onActivated: __copy }); // Edit -&gt; Paste this._menu.addOption('Edit', 'Paste', { hotkeys: &quot;Ctrl+V&quot;, icon: &quot;fa fa-paste fa-lg&quot;, toolbarIndex: -1, description: &quot;Paste node(s) in clipboard into your script.&quot;, condition: function(editor) { return wcPlayEditorClipboard.nodes.length &gt; 0; }, onActivated: function(editor) { var mouse = { x: editor._mouse.x, y: editor._mouse.y, }; if (!editor._mouseInViewport) { mouse.x = editor.$viewport.width()/2; mouse.y = editor.$viewport.height()/2; } editor._selectedNode = null; editor._selectedNodes = []; var idMap = []; var nodes = []; editor._undoManager &amp;&amp; editor._undoManager.beginGroup('Paste Nodes from clipboard'); var bounds = wcPlayEditorClipboard.bounds; for (var i = 0; i &lt; wcPlayEditorClipboard.nodes.length; ++i) { var data = wcPlayEditorClipboard.nodes[i]; var newNode = new window[data.className](editor._parent, data.pos); idMap[data.id] = newNode.id; nodes.push(newNode); } for (var i = 0; i &lt; wcPlayEditorClipboard.nodes.length; ++i) { var data = wcPlayEditorClipboard.nodes[i]; var newNode = nodes[i]; editor._selectedNodes.push(newNode); if (!editor._selectedNode) { editor._selectedNode = newNode; } newNode.import(data, idMap); newNode.pos.x = (mouse.x - editor._viewportCamera.x) / editor._viewportCamera.z - bounds.width/2 + (data.pos.x - bounds.left); newNode.pos.y = (mouse.y - editor._viewportCamera.y) / editor._viewportCamera.z - bounds.height/2 + (data.pos.y - bounds.top); editor.__onCreateNode(newNode); } editor._undoManager &amp;&amp; editor._undoManager.endGroup(); } }); // Edit -&gt; Delete this._menu.addOption('Edit', 'Delete', { hotkeys: &quot;Delete&quot;, icon: &quot;fa fa-trash fa-lg&quot;, toolbarIndex: -1, description: &quot;Delete selected node(s).&quot;, condition: function(editor) { return editor._selectedNodes.length &gt; 0; }, onActivated: function(editor) { if (editor._selectedNodes.length) { editor._undoManager &amp;&amp; editor._undoManager.beginGroup('Removed Nodes'); for (var i = 0; i &lt; editor._selectedNodes.length; ++i) { editor.__onDestroyNode(editor._selectedNodes[i]); editor._selectedNodes[i].destroy(); } editor._selectedNode = null; editor._selectedNodes = []; editor._undoManager &amp;&amp; editor._undoManager.endGroup(); } } }); // Edit -&gt; Create Composite this._menu.addOption('Edit', 'Create Composite', { hotkeys: 'C', icon: &quot;fa fa-suitcase fa-lg&quot;, toolbarIndex: -1, description: &quot;Combine all selected nodes into a new \\'Composite\\' Node.&quot;, condition: function(editor) { return editor._selectedNodes.length &gt; 0; }, onActivated: function(editor) { if (editor._selectedNodes.length &amp;&amp; editor._parent) { editor._undoManager &amp;&amp; editor._undoManager.beginGroup(&quot;Combined Nodes into Composite&quot;); // Create undo events for removing the selected nodes. for (var i = 0; i &lt; editor._selectedNodes.length; ++i) { editor.__onDestroyNode(editor._selectedNodes[i]); // Now give this node a new ID so it is treated like a different node. editor._selectedNodes[i].id = ++window.wcNodeNextID; } var compNode = new wcNodeCompositeScript(editor._parent, {x: 0, y: 0}, editor._selectedNodes); // Calculate the bounding box of all moved nodes. var boundList = []; var offsetList = []; for (var i = 0; i &lt; editor._selectedNodes.length; ++i) { var node = editor._selectedNodes[i]; boundList.push(node._meta.bounds.farRect); offsetList.push(node.pos); } var bounds = editor.__expandRect(boundList, offsetList); var exportedNodes = []; for (var i = 0; i &lt; editor._selectedNodes.length; ++i) { var node = editor._selectedNodes[i]; // The node was already moved to the composite node, now remove it from the parent object. editor._parent.__removeNode(node); // Find all chains that connect to an external node. var entryChains = node.listEntryChains(undefined, editor._selectedNodes); var exitChains = node.listExitChains(undefined, editor._selectedNodes); var inputChains = node.listInputChains(undefined, editor._selectedNodes); var outputChains = node.listOutputChains(undefined, editor._selectedNodes); // External entry chains. var createdLinks = []; for (var a = 0; a &lt; entryChains.length; ++a) { var targetNode = editor._engine.nodeById(entryChains[a].outNodeId); var targetName = entryChains[a].outName; var node = editor._engine.nodeById(entryChains[a].inNodeId); var linkName = entryChains[a].inName; // Make sure we only create one Composite Entry per link. var linkNode = null; for (var b = 0; b &lt; createdLinks.length; ++b) { if (createdLinks[b].name === linkName) { linkNode = createdLinks[b].node; break; } } if (!linkNode) { // Create a Composite Entry Node, this acts as a surrogate entry link for the Composite node. linkNode = new wcNodeCompositeEntry(compNode, {x: node.pos.x, y: bounds.top - 100}, linkName); createdLinks.push({ name: linkName, node: linkNode, }); } linkNode.connectExit('out', node, linkName); compNode.connectEntry(linkNode.name, targetNode, targetName); targetNode.disconnectExit(targetName, node, linkName); } // External exit chains. createdLinks = []; for (var a = 0; a &lt; exitChains.length; ++a) { var targetNode = editor._engine.nodeById(exitChains[a].inNodeId); var targetName = exitChains[a].inName; var node = editor._engine.nodeById(exitChains[a].outNodeId); var linkName = exitChains[a].outName; // Make sure we only create one Composite Entry per link. var linkNode = null; for (var b = 0; b &lt; createdLinks.length; ++b) { if (createdLinks[b].name === linkName) { linkNode = createdLinks[b].node; break; } } if (!linkNode) { // Create a Composite Exit Node, this acts as a surrogate exit link for the Composite node. linkNode = new wcNodeCompositeExit(compNode, {x: node.pos.x, y: bounds.top + bounds.height + 50}, linkName); createdLinks.push({ name: linkName, node: linkNode, }); } linkNode.connectEntry('in', node, linkName); compNode.connectExit(linkNode.name, targetNode, targetName); targetNode.disconnectEntry(targetName, node, linkName); } // External property input chains. createdLinks = []; for (var a = 0; a &lt; inputChains.length; ++a) { var targetNode = editor._engine.nodeById(inputChains[a].outNodeId); var targetName = inputChains[a].outName; var node = editor._engine.nodeById(inputChains[a].inNodeId); var linkName = inputChains[a].inName; // Make sure we only create one Composite Entry per link. var linkNode = null; for (var b = 0; b &lt; createdLinks.length; ++b) { if (createdLinks[b].name === linkName) { linkNode = createdLinks[b].node; break; } } if (!linkNode) { // Create a Composite Property Node, this acts as a surrogate property link for the Composite node. linkNode = new wcNodeCompositeProperty(compNode, {x: bounds.left - 200, y: node.pos.y}, linkName); createdLinks.push({ name: linkName, node: linkNode, }); } linkNode.connectOutput('value', node, linkName); compNode.connectInput(linkNode.name, targetNode, targetName); targetNode.disconnectOutput(targetName, node, linkName); } // External property output chains. createdLinks = []; for (var a = 0; a &lt; outputChains.length; ++a) { var targetNode = editor._engine.nodeById(outputChains[a].inNodeId); var targetName = outputChains[a].inName; var node = editor._engine.nodeById(outputChains[a].outNodeId); var linkName = outputChains[a].outName; // Make sure we only create one Composite Entry per link. var linkNode = null; for (var b = 0; b &lt; createdLinks.length; ++b) { if (createdLinks[b].name === linkName) { linkNode = createdLinks[b].node; break; } } if (!linkNode) { // Create a Composite Property Node, this acts as a surrogate property link for the Composite node. linkNode = new wcNodeCompositeProperty(compNode, {x: bounds.left + bounds.width + 200, y: node.pos.y}, linkName); createdLinks.push({ name: linkName, node: linkNode, }); } linkNode.connectInput('value', node, linkName); compNode.connectOutput(linkNode.name, targetNode, targetName); targetNode.disconnectInput(targetName, node, linkName); } } editor._selectedNode = null; editor._selectedNodes = []; compNode.pos.x = bounds.left + bounds.width/2; compNode.pos.y = bounds.top + bounds.height/2; // Compile the meta data for this node based on the nodes inside. // compNode.compile(); // Create undo event for creating the composite node. editor.__onCreateNode(compNode); editor._undoManager &amp;&amp; editor._undoManager.endGroup(); editor.__setupPalette(); } } }); // Debugging -&gt; Toggle Debug Mode this._menu.addOption('Debugging', 'Toggle Debug Mode', { icon: function(editor) { if (editor._engine &amp;&amp; editor._engine.debugging()) { return &quot;fa fa-dot-circle-o fa-lg&quot;; } else { return &quot;fa fa-circle-o fa-lg&quot;; } }, toolbarIndex: -1, description: &quot;Toggle debugging mode for the entire script.&quot;, onActivated: function(editor) { if (editor._engine) { editor._engine.debugging(!editor._engine.debugging()); editor._engine.paused(false); } } }); // Debugging -&gt; Toggle Silence Mode this._menu.addOption('Debugging', 'Toggle Silence Mode', { icon: function(editor) { if (editor._engine &amp;&amp; editor._engine.silent()) { return &quot;fa fa-volume-off fa-lg&quot;; } else { return &quot;fa fa-volume-up fa-lg&quot;; } }, toolbarIndex: -1, description: &quot;Toggle silent mode for the entire script.&quot;, onActivated: function(editor) { if (editor._engine) { editor._engine.silent(!editor._engine.silent()); } } }); // Debugging -&gt; Restart Script this._menu.addOption('Debugging', 'Start Script', { hotkeys: &quot;Shift+Enter&quot;, icon: function(editor) { if (editor._engine &amp;&amp; editor._engine.isRunning()) { return &quot;fa fa-stop fa-lg&quot;; } else { return &quot;fa fa-play fa-lg&quot;; } }, toolbarIndex: -1, display: function(editor) { if (editor._engine &amp;&amp; editor._engine.isRunning()) { return &quot;Stop Script&quot;; } else { return &quot;Start Script&quot;; } }, description: &quot;Starts or Stops execution of the script.&quot;, condition: function(editor) { return !editor._options.readOnly &amp;&amp; editor._options.playable; }, onActivated: function(editor) { if (editor._engine) { if (editor._engine.isRunning()) { editor._engine.stop(); } else { editor._engine.start(); } } } }); // Debugging -&gt; Pause/Continue Script this._menu.addOption('Debugging', 'Pause Script', { hotkeys: 'Return', icon: &quot;fa fa-pause fa-lg&quot;, toggle: function(editor) { return editor._engine &amp;&amp; editor._engine.paused(); }, display: function(editor) { if (editor._engine &amp;&amp; editor._engine.paused()) { return 'Resume Script'; } else { return 'Pause Script'; } }, toolbarIndex: -1, description: &quot;Pause or Continue the script.&quot;, condition: function(editor) { return !editor._options.readOnly &amp;&amp; (editor._engine &amp;&amp; editor._engine.isRunning()); }, onActivated: function(editor) { if (editor._engine) { if (editor._engine.paused() || editor._engine.stepping()) { editor._engine.paused(false); editor._engine.stepping(false); } else { editor._engine.stepping(true); } } } }); // Debugging -&gt; Step Script this._menu.addOption('Debugging', 'Step Script', { hotkeys: 'Spacebar', icon: &quot;fa fa-fast-forward fa-lg&quot;, toolbarIndex: -1, description: &quot;Perform a single script update.&quot;, condition: function(editor) { return !editor._options.readOnly &amp;&amp; (editor._engine &amp;&amp; editor._engine.isRunning()); }, onActivated: function(editor) { if (editor._engine) { editor._engine.paused(false); editor._engine.stepping(true); } } }); // View -&gt; Create Composite this._menu.addOption('View', 'Fit in View', { hotkeys: 'F', icon: &quot;fa fa-crosshairs fa-lg&quot;, categoryIndex: 2, toolbarIndex: -1, description: &quot;Center view on selected node(s).&quot;, onActivated: function(editor) { if (editor._selectedNodes.length) { editor.focus(editor._selectedNodes); } else { editor.center(); } } }); // View -&gt; Exit Composite this._menu.addOption('View', 'Exit Composite', { hotkeys: 'O', icon: &quot;fa fa-level-up fa-lg&quot;, toolbarIndex: -1, description: &quot;Step out of this Composite Node.&quot;, condition: function(editor) { return editor._parent &amp;&amp; editor._parent.instanceOf('wcNodeCompositeScript'); }, onActivated: function(editor) { var focusNode = editor._parent; editor._parent = editor._parent._parent; editor._selectedNode = focusNode; editor._selectedNodes = [focusNode]; editor.focus(editor._selectedNodes); } }); // View -&gt; Enter Composite this._menu.addOption('View', 'Enter Composite', { hotkeys: 'I', icon: &quot;fa fa-level-down fa-lg&quot;, toolbarIndex: -1, description: &quot;Step in to this Composite Node.&quot;, condition: function(editor) { return (editor._selectedNodes.length === 1 &amp;&amp; editor._selectedNodes[0].instanceOf('wcNodeCompositeScript')); }, onActivated: function(editor) { editor._parent = editor._selectedNodes[0]; editor._selectedNode = null; editor._selectedNodes = []; editor.center(); } }); // View -&gt; Chain Style this._menu.addOption('View', 'Chain Style', { hotkeys: 'V', icon: &quot;fa fa-sitemap fa-lg&quot;, toolbarIndex: -1, description: &quot;Toggle the visual style of the chains.&quot;, onActivated: function(editor) { editor._chainStyle += 1; if (editor._chainStyle &gt; editor._chainStyleMax) { editor._chainStyle = 0; } } }); var self = this; var $field = this.$search.children('input'); var searchResults = []; var searchParent = null; var searchValue = ''; var searchIndex = 0; function __searchNodes() { // Search nodes and focus on them. if (searchParent) { searchResults = searchParent.nodesBySearch(searchValue); if (searchResults.length &gt; 0) { self._parent = searchResults[searchIndex]._parent; self.focus([searchResults[searchIndex]]); self._selectedNodes = searchResults; } } }; function __searchPrev() { if (searchResults.length) { searchIndex -= 1; if (searchIndex &lt; 0) { searchIndex = searchResults.length-1; } self._parent = searchResults[searchIndex]._parent; self.focus([searchResults[searchIndex]]); self._selectedNodes = searchResults; } }; function __searchNext() { if (searchResults.length) { searchIndex += 1; if (searchIndex &gt;= searchResults.length) { searchIndex = 0; } self._parent = searchResults[searchIndex]._parent; self.focus([searchResults[searchIndex]]); self._selectedNodes = searchResults; } }; this.$search.children('.wcPlayEditorSearchPrev').click(__searchPrev); this.$search.children('.wcPlayEditorSearchNext').click(__searchNext); this.$search.keydown(function(event) { if (event.keyCode === 27) { if (!self.$search.hasClass('wcPlayHidden')) { self.$search.addClass('wcPlayHidden'); } } // Return, Down arrow, or Tab to cycle next item. else if (event.keyCode === 13 || event.keyCode === 40 || event.keyCode === 9) { __searchNext(); event.stopPropagation(); event.preventDefault(); return true; } // Up arrow to cycle previous item. else if (event.keyCode === 38) { __searchPrev(); event.stopPropagation(); event.preventDefault(); return true; } }); this.$search.keyup(function(event) { // Re-perform the search when the search value has changed. var val = $field.val().toLowerCase(); if (searchValue !== val) { searchIndex = 0; searchParent = self._parent; searchValue = val; __searchNodes(); } }); // View -&gt; Search... this._menu.addOption('View', 'Search...', { hotkeys: 'Ctrl+F', icon: &quot;fa fa-search fa-lg&quot;, toolbarIndex: -1, description: &quot;Toggle the visual style of the chains.&quot;, onActivated: function(editor) { editor.$search.removeClass('wcPlayHidden'); $field.focus(); $field.select(); if (searchResults.length) { __searchNodes(); } } }); // Help -&gt; Documentation... this._menu.addOption('Help', 'Documentation...', { icon: &quot;fa fa-file-pdf-o fa-lg&quot;, description: &quot;Open the documentation for wcPlay in another window.&quot;, onActivated: function(editor) { window.open('http://play.api.webcabin.org/', '_blank'); } }); this._menu.addSpacer('File', 'Save Script'); this._menu.addSpacer('File', 'Import...'); this._menu.addSpacer('Edit', 'Redo'); this._menu.addSpacer('Edit', 'Delete'); this._menu.addSpacer('View', 'Enter Composite'); this._menu.addSpacer('View', 'Chain Style'); this._menu.addSpacer('Debugging', 'Toggle Silence Mode'); this._menu.addToolbarSpacer('File', 'Save Script'); this._menu.addToolbarSpacer('File', 'Import...'); this._menu.addToolbarSpacer('Edit', 'Redo'); this._menu.addToolbarSpacer('Edit', 'Delete'); this._menu.addToolbarSpacer('Edit', 'Create Composite'); this._menu.addToolbarSpacer('View', 'Enter Composite'); this._menu.addToolbarSpacer('View', 'Chain Style'); this._menu.addToolbarSpacer('Debugging', 'Toggle Silence Mode'); this._menu.addToolbarSpacer('Debugging', 'Step Script'); }, /** * Initializes the palette view. * @function wcPlayEditor#__setupPalette * @private */ __setupPalette: function() { if (!this._engine) { return; } this._paletteSize = this._options.readOnly? 0: this._drawStyle.palette.width; this.onResized(); if (this.$typeButton.length == 0) { // Create our top bar with buttons for each node type. this.$typeButton.push($('&lt;button class=&quot;wcPlayEditorButton wcToggled&quot; title=&quot;Show Entry Nodes.&quot;&gt;Entry&lt;/button&gt;')); this.$typeButton.push($('&lt;button class=&quot;wcPlayEditorButton&quot; title=&quot;Show Process Nodes.&quot;&gt;Process&lt;/button&gt;')); this.$typeButton.push($('&lt;button class=&quot;wcPlayEditorButton&quot; title=&quot;Show Storage Nodes.&quot;&gt;Storage&lt;/button&gt;')); this.$typeButton.push($('&lt;button class=&quot;wcPlayEditorButton&quot; title=&quot;Show Composite Nodes.&quot;&gt;Composite&lt;/button&gt;')); this.$palette.append(this.$typeButton[0]); this.$palette.append(this.$typeButton[1]); this.$palette.append(this.$typeButton[2]); this.$palette.append(this.$typeButton[3]); this.$typeArea.push($('&lt;div class=&quot;wcPlayTypeArea&quot;&gt;')); this.$typeArea.push($('&lt;div class=&quot;wcPlayTypeArea wcPlayHidden&quot;&gt;')); this.$typeArea.push($('&lt;div class=&quot;wcPlayTypeArea wcPlayHidden&quot;&gt;')); this.$typeArea.push($('&lt;div class=&quot;wcPlayTypeArea wcPlayHidden&quot;&gt;')); this.$paletteInner.append(this.$typeArea[0]); this.$paletteInner.append(this.$typeArea[1]); this.$paletteInner.append(this.$typeArea[2]); this.$paletteInner.append(this.$typeArea[3]); } // Empty out our current node library. if (this._nodeLibrary) { for (var cat in this._nodeLibrary) { for (var type in this._nodeLibrary[cat]) { var typeData = this._nodeLibrary[cat][type]; typeData.$button.remove(); typeData.$canvas.remove(); typeData.$category.remove(); for (var i = 0; i &lt; typeData.nodes.length; ++i) { typeData.nodes[i].destroy(); } } } this._nodeLibrary = {}; } function __organize(data) { // Initialize the node category if it is new. if (!this._nodeLibrary.hasOwnProperty(data.category)) { this._nodeLibrary[data.category] = {}; } // Further categorize the node by its type. if (!this._nodeLibrary[data.category].hasOwnProperty(data.nodeType)) { var typeData = { $category: $('&lt;div class=&quot;wcPlayTypeCategory&quot;&gt;'), $button: $('&lt;button class=&quot;wcPlayCategoryButton&quot; title=&quot;Toggle visibility of this category.&quot;&gt;' + data.category + '&lt;/button&gt;'), $canvas: $('&lt;canvas class=&quot;wcPlayTypeCategoryArea&quot;&gt;'), context: null, nodes: [], }; typeData.context = typeData.$canvas[0].getContext('2d'); typeData.$category.append(typeData.$button); typeData.$category.append(typeData.$canvas); this.$typeArea[this.__typeIndex(data.nodeType)].append(typeData.$category); (function __setupCollapseHandler(d) { d.$button.click(function() { if (!d.$button.hasClass('wcToggled')) { d.$button.addClass('wcToggled'); d.$canvas.addClass('wcPlayHidden'); } else { d.$button.removeClass('wcToggled'); d.$canvas.removeClass('wcPlayHidden'); } }); })(typeData); this._nodeLibrary[data.category][data.nodeType] = typeData; } } // Initialize our node library. for (var i = 0; i &lt; wcPlay.NODE_LIBRARY.length; ++i) { var data = wcPlay.NODE_LIBRARY[i]; // Skip categories we are not showing. if (data.className !== 'wcNodeCompositeScript') { var catIndex = this._options.category.items.indexOf(data.category); if ((!this._options.category.isBlacklist &amp;&amp; catIndex === -1) || (this._options.category.isBlacklist &amp;&amp; catIndex &gt; -1)) { continue; } } else { continue; } __organize.call(this, data); // Now create an instance of the node. var node = new window[data.className](null); this._nodeLibrary[data.category][data.nodeType].nodes.push(node); } // Load our imported composite nodes as well. var composites = this._engine.importedComposites(); for (var i = 0; i &lt; composites.length; ++i) { var node = composites[i]; __organize.call(this, node); this._nodeLibrary[node.category][node.nodeType].nodes.push(node); } // Now draw each of our palette nodes once so we can configure the size of the canvases. for (var cat in this._nodeLibrary) { for (var type in this._nodeLibrary[cat]) { var typeData = this._nodeLibrary[cat][type]; typeData.$canvas.attr('width', this.$paletteInner.width()); var yPos = this._drawStyle.palette.spacing; var xPos = this.$paletteInner.width() / 2; for (var i = 0; i &lt; typeData.nodes.length; ++i) { this.__updateNode(typeData.nodes[i], 0, typeData.context); typeData.nodes[i].pos.x = xPos; typeData.nodes[i].pos.y = yPos; this.__drawNode(typeData.nodes[i], typeData.context); yPos += (typeData.nodes[i]._meta.bounds.rect.height * this._drawStyle.palette.scale) + this._drawStyle.palette.spacing; } typeData.$canvas.attr('height', yPos); } } var self = this; this.$typeButton[0].click(function() { self.$typeButton[0].addClass('wcToggled'); self.$typeButton[1].removeClass('wcToggled'); self.$typeButton[2].removeClass('wcToggled'); self.$typeButton[3].removeClass('wcToggled'); self.$typeArea[0].removeClass('wcPlayHidden'); self.$typeArea[1].addClass('wcPlayHidden'); self.$typeArea[2].addClass('wcPlayHidden'); self.$typeArea[3].addClass('wcPlayHidden'); }); this.$typeButton[1].click(function() { self.$typeButton[0].removeClass('wcToggled'); self.$typeButton[1].addClass('wcToggled'); self.$typeButton[2].removeClass('wcToggled'); self.$typeButton[3].removeClass('wcToggled'); self.$typeArea[0].addClass('wcPlayHidden'); self.$typeArea[1].removeClass('wcPlayHidden'); self.$typeArea[2].addClass('wcPlayHidden'); self.$typeArea[3].addClass('wcPlayHidden'); }); this.$typeButton[2].click(function() { self.$typeButton[0].removeClass('wcToggled'); self.$typeButton[1].removeClass('wcToggled'); self.$typeButton[2].addClass('wcToggled'); self.$typeButton[3].removeClass('wcToggled'); self.$typeArea[0].addClass('wcPlayHidden'); self.$typeArea[1].addClass('wcPlayHidden'); self.$typeArea[2].removeClass('wcPlayHidden'); self.$typeArea[3].addClass('wcPlayHidden'); }); this.$typeButton[3].click(function() { self.$typeButton[0].removeClass('wcToggled'); self.$typeButton[1].removeClass('wcToggled'); self.$typeButton[2].removeClass('wcToggled'); self.$typeButton[3].addClass('wcToggled'); self.$typeArea[0].addClass('wcPlayHidden'); self.$typeArea[1].addClass('wcPlayHidden'); self.$typeArea[2].addClass('wcPlayHidden'); self.$typeArea[3].removeClass('wcPlayHidden'); }); }, /** * Draws each node in the palette view. * @function wcPlayEditor#__drawPalette * @private * @param {Number} elapsed - Elapsed time since last update. */ __drawPalette: function(elapsed) { for (var cat in this._nodeLibrary) { for (var type in this._nodeLibrary[cat]) { // Ignore types that are not visible. if (!this.$typeButton[this.__typeIndex(type)].hasClass('wcToggled')) continue; var typeData = this._nodeLibrary[cat][type]; // Ignore categories that are not visible. if (typeData.$button.hasClass('wcToggled')) continue; var yPos = this._drawStyle.palette.spacing; var xPos = this.$paletteInner.width() / 2 / this._drawStyle.palette.scale; typeData.$canvas.attr('width', this.$paletteInner.width()); typeData.context.clearRect(0, 0, typeData.$canvas.width(), typeData.$canvas.height()); typeData.context.save(); typeData.context.scale(this._drawStyle.palette.scale, this._drawStyle.palette.scale); for (var i = 0; i &lt; typeData.nodes.length; ++i) { this.__updateNode(typeData.nodes[i], 0, typeData.context); typeData.nodes[i].pos.x = xPos; typeData.nodes[i].pos.y = yPos; this.__drawNode(typeData.nodes[i], typeData.context, true); yPos += typeData.nodes[i]._meta.bounds.rect.height + this._drawStyle.palette.spacing; } typeData.context.restore(); } } }, /** * Draws a list of nodes on the canvas. * @function wcPlayEditor#__drawNodes * @private * @param {wcNode[]} nodes - The node to render. * @param {external:Canvas~Context} context - The canvas context to render on. */ __drawNodes: function(nodes, context) { for (var i = 0; i &lt; nodes.length; ++i) { this.__drawNode(nodes[i], context); } }, /** * Draws a single node on the canvas at a given position. * @function wcPlayEditor#__drawNode * @private * @param {wcNode} node - The node to render. * @param {external:Canvas~Context} context - The canvas context to render on. * @param {Boolean} [isPalette] - If true, this node will be rendered for the palette view. */ __drawNode: function(node, context, isPalette) { // Ignore drawing if the node is outside of view. if (!isPalette &amp;&amp; !this.__rectOnRect(node._meta.bounds.farRect, this._viewportBounds, node.pos)) { node._meta.visible = false; return; } node._meta.visible = true; // this._nodeDrawCount += 1; // Show an additional bounding rect around selected nodes. if (this._selectedNodes.indexOf(node) &gt; -1) { this.__drawRoundedRect(node._meta.bounds.rect, &quot;rgba(0, 255, 255, 0.25)&quot;, -1, 10, context, node.pos); this.__drawRoundedRect(node._meta.bounds.rect, &quot;darkcyan&quot;, 2, 10, context, node.pos); } // Now use our measurements to draw our node. this.__drawCenter(node, context, isPalette); this.__drawEntryLinks(node, context, node._meta.bounds.entryOuter.width); this.__drawExitLinks(node, context, node._meta.bounds.entryOuter.height + node._meta.bounds.centerOuter.height, node._meta.bounds.exitOuter.width); // Add a collapse button to the node in the left margin of the title. context.save(); context.fillStyle = (this._highlightDebugLog &amp;&amp; this._highlightNode === node? &quot;black&quot;: &quot;white&quot;); context.strokeStyle = &quot;black&quot;; context.lineWidth = 1; context.fillRect(node.pos.x + node._meta.bounds.debugLog.left, node.pos.y + node._meta.bounds.debugLog.top, node._meta.bounds.debugLog.width, node._meta.bounds.debugLog.height); context.strokeRect(node.pos.x + node._meta.bounds.debugLog.left, node.pos.y + node._meta.bounds.debugLog.top, node._meta.bounds.debugLog.width, node._meta.bounds.debugLog.height); context.strokeStyle = (node._log? &quot;red&quot;: (this._highlightDebugLog &amp;&amp; this._highlightNode === node? &quot;white&quot;: &quot;black&quot;)); context.lineWidth = 2; context.beginPath(); context.moveTo(node.pos.x + node._meta.bounds.debugLog.left + 1, node.pos.y + node._meta.bounds.debugLog.top + 1); context.lineTo(node.pos.x + node._meta.bounds.debugLog.left + node._meta.bounds.debugLog.width/2, node.pos.y + node._meta.bounds.debugLog.top + node._meta.bounds.debugLog.height/2); context.lineTo(node.pos.x + node._meta.bounds.debugLog.left + 1, node.pos.y + node._meta.bounds.debugLog.top + node._meta.bounds.debugLog.height - 1); context.moveTo(node.pos.x + node._meta.bounds.debugLog.left + node._meta.bounds.debugLog.width/2, node.pos.y + node._meta.bounds.debugLog.top + node._meta.bounds.debugLog.height - 2); context.lineTo(node.pos.x + node._meta.bounds.debugLog.left + node._meta.bounds.debugLog.width, node.pos.y + node._meta.bounds.debugLog.top + node._meta.bounds.debugLog.height - 2); context.stroke(); context.restore(); // Add breakpoint button to the node in the right margin of the title. context.save(); context.fillStyle = (this._highlightBreakpoint &amp;&amp; this._highlightNode === node? &quot;black&quot;: &quot;white&quot;); context.fillRect(node.pos.x + node._meta.bounds.breakpoint.left, node.pos.y + node._meta.bounds.breakpoint.top, node._meta.bounds.breakpoint.width, node._meta.bounds.breakpoint.height); context.strokeStyle = (node._break? &quot;red&quot;: (this._highlightBreakpoint &amp;&amp; this._highlightNode === node? &quot;white&quot;: &quot;black&quot;)); context.fillStyle = &quot;red&quot;; context.lineWidth = 2; context.beginPath(); context.arc(node.pos.x + node._meta.bounds.breakpoint.left + node._meta.bounds.breakpoint.width/2, node.pos.y + node._meta.bounds.breakpoint.top + node._meta.bounds.breakpoint.height/2, Math.min(node._meta.bounds.breakpoint.width/2-2, node._meta.bounds.breakpoint.height/2-2), 0, 2 * Math.PI); node._break &amp;&amp; context.fill(); context.stroke(); context.strokeStyle = &quot;black&quot;; context.lineWidth = 1; context.strokeRect(node.pos.x + node._meta.bounds.breakpoint.left, node.pos.y + node._meta.bounds.breakpoint.top, node._meta.bounds.breakpoint.width, node._meta.bounds.breakpoint.height); context.restore(); // Increase the nodes border thickness when flashing. if (node.isBroken()) { this.__drawRoundedRect(node._meta.bounds.inner, &quot;#CC0000&quot;, 5, this._drawStyle.node.radius, context, node.pos); } else if (node._meta.flashDelta) { this.__drawRoundedRect(node._meta.bounds.inner, &quot;yellow&quot;, 2, this._drawStyle.node.radius, context, node.pos); } }, /** * Measures the space to render entry links for a node. * @function wcPlayEditor#__measureEntryLinkOuter * @private * @param {wcNode} node - The node to measure. * @param {external:Canvas~Context} context - The canvas context. * @returns {wcPlayEditor~Rect} - A bounding rectangle. */ __measureEntryLinkOuter: function(node, context) { var bounds = { top: 0, left: 0, width: 0, height: 0, }; this.__setCanvasFont(this._font.links, context); var links = node.chain.entry; for (var i = 0; i &lt; links.length; ++i) { bounds.width += context.measureText(links[i].name).width + this._drawStyle.links.spacing; } bounds.left -= bounds.width/2 + this._drawStyle.links.margin; bounds.width += this._drawStyle.links.margin * 2; if (node.chain.entry.length) { bounds.height = this._font.links.size + this._drawStyle.links.padding + this._drawStyle.links.length; } return bounds; }, /** * Measures the space to render exit links for a node. * @function wcPlayEditor#__measureExitLinkOuter * @private * @param {wcNode} node - The node to measure. * @param {external:Canvas~Context} context - The canvas context. * @param {Number} offset - The top position to measure the links. * @returns {wcPlayEditor~Rect} - A bounding rectangle. */ __measureExitLinkOuter: function(node, context, offset) { var bounds = { top: offset, left: 0, width: 0, height: 0, }; this.__setCanvasFont(this._font.links, context); var links = node.chain.exit; for (var i = 0; i &lt; links.length; ++i) { bounds.width += context.measureText(links[i].name).width + this._drawStyle.links.spacing; } bounds.left -= bounds.width/2 + this._drawStyle.links.margin; bounds.width += this._drawStyle.links.margin * 2; if (node.chain.exit.length) { bounds.height = this._font.links.size + this._drawStyle.links.padding + this._drawStyle.links.length; } return bounds; }, /** * Measures the space to render the center area for a node. * @function wcPlayEditor#__measureOuter * @private * @param {wcNode} node - The node to measure. * @param {external:Canvas~Context} context - The canvas context. * @param {Number} offset - The upper offset. * @returns {wcPlayEditor~Rect} - A bounding rectangle. The height is only the amount of space rendered within the node bounds (links stick out). */ __measureOuter: function(node, context, offset) { var bounds = { top: offset, left: 0, width: 0, height: this._font.title.size + this._drawStyle.title.spacing + this._drawStyle.links.padding, }; // Measure the title bar area. this.__setCanvasFont(this._font.title, context); bounds.width = context.measureText(this._drawStyle.title.wrapL + node.type + ': ' + this._drawStyle.title.wrapR).width; this.__setCanvasFont(this._font.titleDesc, context); bounds.width += context.measureText(this._drawStyle.title.nameWrapL + (node.name || this._drawStyle.title.placeholder) + this._drawStyle.title.nameWrapR).width; if (node.description() || node.details()) { this.__setCanvasFont(this._font.details, context); bounds.width += context.measureText(this._drawStyle.title.details).width; } // Measure the node's viewport. if (node._viewportSize) { bounds.width = Math.max(bounds.width, node._viewportSize.x); bounds.height += node._viewportSize.y + this._drawStyle.property.spacing; } // Measure the property headers. bounds.height += this._font.property.size + this._drawStyle.property.spacing; // Measure properties. var propWidth = 0; var valueWidth = 0; var initialWidth = 0; var joinedWidth = 0; var props = node.properties; for (var i = 0; i &lt; props.length; ++i) { bounds.height += this._font.property.size + this._drawStyle.property.spacing; // Property name. this.__setCanvasFont(this._font.property, context); propWidth = Math.max(context.measureText(props[i].name + ': ').width, propWidth); var showValue = this._engine.isRunning() &amp;&amp; !props[i].options.linked; // Property value. if (showValue) { this.__setCanvasFont(this._font.value, context); valueWidth = Math.max(context.measureText(this._drawStyle.property.valueWrapL + this.__drawPropertyValue(node, props[i]) + this._drawStyle.property.valueWrapR).width, this._drawStyle.property.minLength, valueWidth); // Property initial value. this.__setCanvasFont(this._font.initialValue, context); initialWidth = Math.max(context.measureText(this._drawStyle.property.initialWrapL + this.__drawPropertyValue(node, props[i], true) + this._drawStyle.property.initialWrapR).width, this._drawStyle.property.minLength, initialWidth); } else { // Property initial value. this.__setCanvasFont(this._font.initialValue, context); joinedWidth = Math.max(context.measureText(this._drawStyle.property.initialWrapL + this.__drawPropertyValue(node, props[i], true, true) + this._drawStyle.property.initialWrapR).width, this._drawStyle.property.minLength, initialWidth); } } joinedWidth = Math.max(joinedWidth, valueWidth + initialWidth); bounds.width = Math.max(propWidth + joinedWidth, bounds.width) + this._drawStyle.node.margin * 2; bounds.left -= bounds.width/2; bounds.propWidth = propWidth; bounds.valueWidth = valueWidth; bounds.initialWidth = initialWidth; return bounds; }, /** * Measures the space to render the center area for a node. * @function wcPlayEditor#__measureCenter * @private * @param {wcNode} node - The node to draw. * @param {external:Canvas~Context} context - The canvas context. * @param {wcPlayEditor~Rect} rect - The bounding area to draw in. */ __measureCenter: function(node, context, rect) { var upper = node.chain.entry.length? this._font.links.size + this._drawStyle.links.padding: 0; var lower = node.chain.exit.length? this._font.links.size + this._drawStyle.links.padding: 0; node._meta.bounds.center = rect; node._meta.bounds.inputBounds = []; node._meta.bounds.outputBounds = []; node._meta.bounds.propertyBounds = []; node._meta.bounds.valueBounds = []; node._meta.bounds.initialBounds = []; context.save(); // Measure the title bar area. this.__setCanvasFont(this._font.title, context); var titleTypeWidth = context.measureText(this._drawStyle.title.wrapL + node.type + ': ').width; var titleWrapRWidth = context.measureText(this._drawStyle.title.wrapR).width; this.__setCanvasFont(this._font.titleDesc, context); var titleTextWidth = context.measureText(this._drawStyle.title.nameWrapL + (node.name || this._drawStyle.title.placeholder) + this._drawStyle.title.nameWrapR).width; var titleDetailsWidth = 0; if (node.description() || node.details()) { this.__setCanvasFont(this._font.details, context); titleDetailsWidth = context.measureText(this._drawStyle.title.details).width; } node._meta.bounds.titleBounds = { top: rect.top, left: rect.left + titleTypeWidth + (rect.width - (titleTypeWidth + titleWrapRWidth + titleTextWidth + titleDetailsWidth))/2, width: titleTextWidth, height: this._font.title.size + this._drawStyle.title.spacing - 1, typeWidth: titleTypeWidth, wrapRWidth: titleWrapRWidth, textWidth: titleTextWidth, }; node._meta.bounds.detailsBounds = { top: rect.top, left: rect.left + rect.width - this._drawStyle.node.margin - titleDetailsWidth, width: titleDetailsWidth, height: this._font.details.size + this._drawStyle.title.spacing - 1, }; // Title Lower Bar upper = this._font.title.size; upper += this._drawStyle.title.spacing; // Draw the node's viewport. if (node._viewportSize) { // Calculate the translation to make the viewport 0,0. node._meta.bounds.viewportBounds = { top: rect.top + upper, left: rect.left + (rect.width/2 - node._viewportSize.x/2), width: node._viewportSize.x, height: node._viewportSize.y, }; upper += node._viewportSize.y + this._drawStyle.property.spacing; } // Measure the property headers. upper += this._font.property.size + this._drawStyle.property.spacing; var linkRect; var props = node.properties; for (var i = 0; i &lt; props.length; ++i) { upper += this._font.property.size; // Property name. var propertyBound = { rect: { top: rect.top + upper - this._font.property.size, left: rect.left + this._drawStyle.node.margin, width: rect.width - this._drawStyle.node.margin * 2, height: this._font.property.size + this._drawStyle.property.spacing, }, name: props[i].name, }; node._meta.bounds.propertyBounds.push(propertyBound); var showValue = this._engine.isRunning() &amp;&amp; !props[i].options.linked; // Initial property value. var initialBound = { rect: { top: rect.top + upper - this._font.property.size, left: rect.left + rect.width - this._drawStyle.node.margin - rect.initialWidth - (showValue? 0: rect.valueWidth), width: rect.initialWidth + (showValue? 0: rect.valueWidth), height: this._font.property.size + this._drawStyle.property.spacing, }, name: props[i].name, }; node._meta.bounds.initialBounds.push(initialBound); // Property value. var valueBound = { rect: { top: rect.top + upper - this._font.property.size, left: rect.left + rect.width - this._drawStyle.node.margin - rect.valueWidth - rect.initialWidth, width: (showValue? rect.valueWidth: 0), height: this._font.property.size + this._drawStyle.property.spacing, }, name: props[i].name, }; node._meta.bounds.valueBounds.push(valueBound); // Property input. linkRect = { top: rect.top + upper - this._font.property.size/3 - this._drawStyle.links.width/2 - 5, left: rect.left - this._drawStyle.links.length, width: this._drawStyle.links.length, height: (props[i].options &amp;&amp; props[i].options.input)? this._drawStyle.links.width + 10: 0, }; node._meta.bounds.inputBounds.push({ rect: linkRect, point: { x: linkRect.left + linkRect.width/3 - 2, y: linkRect.top + linkRect.height/2, }, name: props[i].name, }); // Property output. linkRect = { top: rect.top + upper - this._font.property.size/3 - this._drawStyle.links.width/2 - 5, left: rect.left + rect.width, width: this._drawStyle.links.length, height: (props[i].options &amp;&amp; props[i].options.output)? this._drawStyle.links.width + 10: 0, } node._meta.bounds.outputBounds.push({ rect: linkRect, point: { x: linkRect.left + linkRect.width + 1, y: linkRect.top + linkRect.height/2, }, name: props[i].name, }); upper += this._drawStyle.property.spacing; } context.restore(); }, /** * Draws the entry links of a node. * @function wcPlayEditor#__measureEntryLinks * @private * @param {wcNode} node - The node to draw. * @param {external:Canvas~Context} context - The canvas context. * @param {Number} width - The width of the area to draw in. */ __measureEntryLinks: function(node, context, width) { node._meta.bounds.entryBounds = []; var xPos = -width/2 + this._drawStyle.links.margin; var yPos = this._drawStyle.links.length + this._font.links.size; context.save(); this.__setCanvasFont(this._font.links, context); var links = node.chain.entry; for (var i = 0; i &lt; links.length; ++i) { // Link label var w = context.measureText(links[i].name).width + this._drawStyle.links.spacing; // Link connector var rect = { top: yPos - this._drawStyle.links.length - this._font.links.size, left: xPos + w/2 - this._drawStyle.links.width/2, width: this._drawStyle.links.width, height: this._drawStyle.links.length, }; // Expand the bounding rect just a little so it is easier to click. rect.left -= 5; rect.width += 10; node._meta.bounds.entryBounds.push({ rect: rect, point: { x: rect.left + rect.width/2, y: rect.top + rect.height/3 - 2, }, name: links[i].name, }); xPos += w; } context.restore(); }, /** * Draws the exit links of a node. * @function wcPlayEditor#__measureExitLinks * @private * @param {wcNode} node - The node to draw. * @param {external:Canvas~Context} context - The canvas context. * @param {Number} offset - The upper offset. * @param {Number} width - The width of the area to draw in. */ __measureExitLinks: function(node, context, offset, width) { node._meta.bounds.exitBounds = []; var xPos = -width/2 + this._drawStyle.links.margin; var yPos = offset + this._font.links.size; context.save(); this.__setCanvasFont(this._font.links, context); var links = node.chain.exit; for (var i = 0; i &lt; links.length; ++i) { // Link label var w = context.measureText(links[i].name).width + this._drawStyle.links.spacing; // Link connector var rect = { top: yPos + this._drawStyle.links.padding, left: xPos + w/2 - this._drawStyle.links.width/2, width: this._drawStyle.links.width, height: this._drawStyle.links.length, }; // Expand the bounding rect just a little so it is easier to click. rect.left -= 5; rect.width += 10; node._meta.bounds.exitBounds.push({ rect: rect, point: { x: rect.left + rect.width/2, y: rect.top + rect.height + 1, }, name: links[i].name, }); xPos += w; } context.restore(); }, /** * Measures the space to render the center area for a node. * @function wcPlayEditor#__drawCenter * @private * @param {wcNode} node - The node to draw. * @param {external:Canvas~Context} context - The canvas context. * @param {Boolean} [isPalette] - If true, this node will be rendered for the palette view. * @returns {wcPlayEditor~DrawPropertyData} - Contains bounding rectangles for various drawings. */ __drawCenter: function(node, context, isPalette) { var upper = node.chain.entry.length? this._font.links.size + this._drawStyle.links.padding: 0; var lower = node.chain.exit.length? this._font.links.size + this._drawStyle.links.padding: 0; // Node background context.save(); var left = node.pos.x + node._meta.bounds.center.left + node._meta.bounds.center.width/2; var top = node.pos.y + node._meta.bounds.center.top + (node._meta.bounds.center.height)/2; var gradient = context.createRadialGradient(left, top, 10, left, top, Math.max(node._meta.bounds.center.width, node._meta.bounds.center.height)); gradient.addColorStop(0, (node.enabled()? node._meta.color: '#555')); gradient.addColorStop(1, &quot;white&quot;); context.fillStyle = context.strokeStyle = gradient; context.lineJoin = &quot;round&quot;; var diameter = this._drawStyle.node.radius*2; context.lineWidth = diameter; context.fillRect(node.pos.x + node._meta.bounds.center.left + diameter/2, node.pos.y + node._meta.bounds.center.top - upper + diameter/2, node._meta.bounds.center.width - diameter, node._meta.bounds.center.height + upper + lower - diameter); context.strokeRect(node.pos.x + node._meta.bounds.center.left + diameter/2, node.pos.y + node._meta.bounds.center.top - upper + diameter/2, node._meta.bounds.center.width - diameter, node._meta.bounds.center.height + upper + lower - diameter); context.restore(); this.__drawRoundedRect({ left: node._meta.bounds.center.left, top: node._meta.bounds.center.top - upper, width: node._meta.bounds.center.width, height: node._meta.bounds.center.height + upper + lower }, node._meta.color, 3, this._drawStyle.node.radius, context, node.pos); // Title Upper Bar upper = 0; if (node.chain.entry.length) { context.strokeStyle = node._meta.color; context.beginPath(); context.moveTo(node.pos.x + node._meta.bounds.center.left, node.pos.y + node._meta.bounds.center.top + upper); context.lineTo(node.pos.x + node._meta.bounds.center.left + node._meta.bounds.center.width, node.pos.y + node._meta.bounds.center.top + upper); context.stroke(); } // Highlight title text. if (!this._options.readOnly &amp;&amp; !isPalette) { if (this._highlightTitle &amp;&amp; this._highlightNode === node) { this.__drawRoundedRect(node._meta.bounds.titleBounds, this._drawStyle.property.highlightColor, this._drawStyle.property.highlightBorder, this._font.title.size/2, context, node.pos); } else if (this._highlightNode === node) { this.__drawRoundedRect(node._meta.bounds.titleBounds, this._drawStyle.property.normalColor, this._drawStyle.property.normalBorder, this._font.title.size/2, context, node.pos); } } // Highlight details button. if (!this._options.readOnly &amp;&amp; node._meta.bounds.detailsBounds.width &gt; 0 &amp;&amp; !isPalette) { if (this._highlightDetails &amp;&amp; this._highlightNode === node) { this.__drawRoundedRect(node._meta.bounds.detailsBounds, this._drawStyle.property.highlightColor, this._drawStyle.property.highlightBorder, this._font.title.size/2, context, node.pos); } else if (this._highlightNode === node) { this.__drawRoundedRect(node._meta.bounds.detailsBounds, this._drawStyle.property.normalColor, this._drawStyle.property.normalBorder, this._font.title.size/2, context, node.pos); } } // Title Text context.save(); upper += this._font.title.size; context.fillStyle = &quot;black&quot;; context.strokeStyle = &quot;black&quot;; context.textAlign = &quot;left&quot;; this.__setCanvasFont(this._font.title, context); context.fillText(this._drawStyle.title.wrapL + node.type + ': ', node.pos.x + node._meta.bounds.titleBounds.left - node._meta.bounds.titleBounds.typeWidth, node.pos.y + node._meta.bounds.titleBounds.top + upper); this.__setCanvasFont(this._font.titleDesc, context); context.fillText(this._drawStyle.title.nameWrapL + (node.name || this._drawStyle.title.placeholder) + this._drawStyle.title.nameWrapR, node.pos.x + node._meta.bounds.titleBounds.left, node.pos.y + node._meta.bounds.titleBounds.top + upper); context.textAlign = &quot;right&quot;; this.__setCanvasFont(this._font.title, context); context.fillText(this._drawStyle.title.wrapR, node.pos.x + node._meta.bounds.titleBounds.left, node.pos.y + node._meta.bounds.titleBounds.top + upper); if (node.description() || node.details()) { this.__setCanvasFont(this._font.details, context); context.fillText(this._drawStyle.title.details, node.pos.x + node._meta.bounds.detailsBounds.left + node._meta.bounds.detailsBounds.width, node.pos.y + node._meta.bounds.detailsBounds.top + this._font.details.size); } context.restore(); // Title Lower Bar upper += this._drawStyle.title.spacing; // Draw the node's viewport. if (node._meta.bounds.viewportBounds) { context.save(); // Translate the canvas so 0,0 is the beginning of the viewport. context.translate(node.pos.x + node._meta.bounds.viewportBounds.left, node.pos.y + node._meta.bounds.viewportBounds.top); // Draw the viewport. node.onViewportDraw(context, this._options.readOnly); // Now revert the translation. context.translate(-node.pos.x - node._meta.bounds.viewportBounds.left, -node.pos.y - node._meta.bounds.viewportBounds.top); context.restore(); upper += node._viewportSize.y + this._drawStyle.property.spacing; } // Draw the property headers. upper += this._font.property.size; context.save(); // Display the Current and Initial column headers. var headerBounds = { top: node._meta.bounds.center.top + upper - this._font.property.size, left: node._meta.bounds.center.left + this._drawStyle.node.margin, height: this._font.property.size + this._drawStyle.property.spacing/2, width: node._meta.bounds.center.width - this._drawStyle.node.margin*2 }; this.__drawRoundedRect(headerBounds, this._drawStyle.property.headerColor, this._drawStyle.property.headerBorder, this._font.property.size/2, context, node.pos); if (node._meta.bounds.centerOuter.valueWidth) { context.fillStyle = &quot;black&quot;; context.textAlign = &quot;center&quot;; this.__setCanvasFont(this._font.propertyHeader, context); context.fillText(&quot;Initial&quot;, node.pos.x + node._meta.bounds.center.left + node._meta.bounds.center.width - this._drawStyle.node.margin - node._meta.bounds.center.initialWidth/2, node.pos.y + node._meta.bounds.center.top + upper); context.fillStyle = &quot;#444444&quot;; this.__setCanvasFont(this._font.propertyHeader, context); context.fillText(&quot;Current&quot;, node.pos.x + node._meta.bounds.center.left + node._meta.bounds.center.width - this._drawStyle.node.margin - node._meta.bounds.center.initialWidth - node._meta.bounds.center.valueWidth/2, node.pos.y + node._meta.bounds.center.top + upper); } else { context.fillStyle = &quot;black&quot;; context.textAlign = &quot;center&quot;; this.__setCanvasFont(this._font.propertyHeader, context); context.fillText(&quot;Initial&quot;, node.pos.x + node._meta.bounds.center.left + node._meta.bounds.center.width - this._drawStyle.node.margin - (node._meta.bounds.center.initialWidth + node._meta.bounds.center.valueWidth)/2, node.pos.y + node._meta.bounds.center.top + upper); } upper += this._drawStyle.property.spacing; var props = node.properties; for (var i = 0; i &lt; props.length; ++i) { upper += this._font.property.size; var propertyBound = null; for (var a = 0; a &lt; node._meta.bounds.propertyBounds.length; ++a) { if (node._meta.bounds.propertyBounds[a].name === props[i].name) { propertyBound = node._meta.bounds.propertyBounds[a]; break; } } // Initial property value. var initialBound = null; for (var a = 0; a &lt; node._meta.bounds.initialBounds.length; ++a) { if (node._meta.bounds.initialBounds[a].name === props[i].name) { initialBound = node._meta.bounds.initialBounds[a]; break; } } // Property value. var valueBound = null; for (var a = 0; a &lt; node._meta.bounds.valueBounds.length; ++a) { if (node._meta.bounds.valueBounds[a].name === props[i].name) { valueBound = node._meta.bounds.valueBounds[a]; break; } } var showValue = this._engine.isRunning() &amp;&amp; !props[i].options.linked; // Highlight hovered values. if (!this._options.readOnly &amp;&amp; !isPalette) { if (this._engine &amp;&amp; showValue) { if (this._highlightNode === node &amp;&amp; this._highlightPropertyValue &amp;&amp; this._highlightPropertyValue.name === props[i].name) { this.__drawRoundedRect(valueBound.rect, this._drawStyle.property.highlightColor, this._drawStyle.property.highlightBorder, this._font.property.size/2, context, node.pos); } else if (this._highlightNode === node) { this.__drawRoundedRect(valueBound.rect, this._drawStyle.property.normalColor, this._drawStyle.property.normalBorder, this._font.property.size/2, context, node.pos); } } if (this._highlightNode === node &amp;&amp; this._highlightPropertyInitialValue &amp;&amp; this._highlightPropertyInitialValue.name === props[i].name) { this.__drawRoundedRect(initialBound.rect, this._drawStyle.property.highlightColor, this._drawStyle.property.highlightBorder, this._font.property.size/2, context, node.pos); } else if (this._highlightNode === node) { this.__drawRoundedRect(initialBound.rect, this._drawStyle.property.normalColor, this._drawStyle.property.normalBorder, this._font.property.size/2, context, node.pos); } } context.fillStyle = &quot;black&quot;; context.textAlign = &quot;left&quot;; this.__setCanvasFont(this._font.property, context); context.fillText(props[i].name + ': ', node.pos.x + node._meta.bounds.center.left + this._drawStyle.node.margin, node.pos.y + node._meta.bounds.center.top + upper); context.fillStyle = &quot;black&quot;; context.textAlign = &quot;right&quot;; this.__setCanvasFont(this._font.initialValue, context); context.fillText(this._drawStyle.property.initialWrapL + this.__drawPropertyValue(node, props[i], true, !showValue) + this._drawStyle.property.initialWrapR, node.pos.x + node._meta.bounds.center.left + node._meta.bounds.center.width - this._drawStyle.node.margin, node.pos.y + node._meta.bounds.center.top + upper); if (this._engine &amp;&amp; showValue) { context.fillStyle = &quot;#444444&quot;; this.__setCanvasFont(this._font.value, context); context.fillText(this._drawStyle.property.valueWrapL + this.__drawPropertyValue(node, props[i]) + this._drawStyle.property.valueWrapR, node.pos.x + node._meta.bounds.center.left + node._meta.bounds.center.width - this._drawStyle.node.margin - node._meta.bounds.center.initialWidth, node.pos.y + node._meta.bounds.center.top + upper); } // Property input. var linkRect = null; for (var a = 0; a &lt; node._meta.bounds.inputBounds.length; ++a) { if (node._meta.bounds.inputBounds[a].name === props[i].name) { linkRect = node._meta.bounds.inputBounds[a].rect; break; } } if (props[i].options &amp;&amp; props[i].options.input) { context.fillStyle = (this._highlightInputLink &amp;&amp; this._highlightInputLink.name === props[i].name &amp;&amp; this._highlightNode === node? &quot;cyan&quot;: props[i].inputMeta.color); context.strokeStyle = &quot;black&quot;; context.beginPath(); context.moveTo(node.pos.x + linkRect.left, node.pos.y + linkRect.top + 5); context.lineTo(node.pos.x + linkRect.left + linkRect.width, node.pos.y + linkRect.top + 5); context.lineTo(node.pos.x + linkRect.left + linkRect.width, node.pos.y + linkRect.top + linkRect.height - 5); context.lineTo(node.pos.x + linkRect.left, node.pos.y + linkRect.top + linkRect.height - 5); context.lineTo(node.pos.x + linkRect.left + linkRect.width/3, node.pos.y + linkRect.top + linkRect.height/2); context.closePath(); context.stroke(); context.fill(); } // Property output. var linkRect = null; for (var a = 0; a &lt; node._meta.bounds.outputBounds.length; ++a) { if (node._meta.bounds.outputBounds[a].name === props[i].name) { linkRect = node._meta.bounds.outputBounds[a].rect; break; } } if (props[i].options &amp;&amp; props[i].options.output) { context.fillStyle = (this._highlightOutputLink &amp;&amp; this._highlightOutputLink.name === props[i].name &amp;&amp; this._highlightNode === node? &quot;cyan&quot;: props[i].outputMeta.color); context.strokeStyle = &quot;black&quot;; context.beginPath(); context.moveTo(node.pos.x + linkRect.left, node.pos.y + linkRect.top + 5); context.lineTo(node.pos.x + linkRect.left + linkRect.width/2, node.pos.y + linkRect.top + 5); context.lineTo(node.pos.x + linkRect.left + linkRect.width, node.pos.y + linkRect.top + linkRect.height/2); context.lineTo(node.pos.x + linkRect.left + linkRect.width/2, node.pos.y + linkRect.top + linkRect.height - 5); context.lineTo(node.pos.x + linkRect.left, node.pos.y + linkRect.top + linkRect.height - 5); context.closePath(); context.stroke(); context.fill(); } upper += this._drawStyle.property.spacing; } // Lower Bar if (node.chain.exit.length) { context.strokeStyle = node._meta.color; context.beginPath(); context.moveTo(node.pos.x + node._meta.bounds.center.left, node.pos.y + node._meta.bounds.center.top + node._meta.bounds.center.height); context.lineTo(node.pos.x + node._meta.bounds.center.left + node._meta.bounds.center.width, node.pos.y + node._meta.bounds.center.top + node._meta.bounds.center.height); context.stroke(); } context.restore(); }, /** * Draws the entry links of a node. * @function wcPlayEditor#__drawEntryLinks * @private * @param {wcNode} node - The node to draw. * @param {external:Canvas~Context} context - The canvas context. * @param {Number} width - The width of the area to draw in. */ __drawEntryLinks: function(node, context, width) { var xPos = node.pos.x - width/2 + this._drawStyle.links.margin; var yPos = node.pos.y + this._drawStyle.links.length + this._font.links.size; context.save(); this.__setCanvasFont(this._font.links, context); var links = node.chain.entry; for (var i = 0; i &lt; links.length; ++i) { // Link label context.fillStyle = &quot;black&quot;; var w = context.measureText(links[i].name).width + this._drawStyle.links.spacing; context.fillText(links[i].name, xPos + this._drawStyle.links.spacing/2, yPos); // Link connector var rect = null; for (var a = 0; a &lt; node._meta.bounds.entryBounds.length; ++a) { if (node._meta.bounds.entryBounds[a].name === links[i].name) { rect = node._meta.bounds.entryBounds[a].rect; break; } } context.fillStyle = (this._highlightEntryLink &amp;&amp; this._highlightEntryLink.name === links[i].name &amp;&amp; this._highlightNode === node? &quot;cyan&quot;: links[i].meta.color); context.strokeStyle = &quot;black&quot;; context.beginPath(); context.moveTo(node.pos.x + rect.left + 5, node.pos.y + rect.top); context.lineTo(node.pos.x + rect.left + rect.width/2, node.pos.y + rect.top + rect.height/3); context.lineTo(node.pos.x + rect.left + rect.width - 5, node.pos.y + rect.top); context.lineTo(node.pos.x + rect.left + rect.width - 5, node.pos.y + rect.top + rect.height); context.lineTo(node.pos.x + rect.left + 5, node.pos.y + rect.top + rect.height); context.closePath(); context.stroke(); context.fill(); xPos += w; } context.restore(); }, /** * Draws the exit links of a node. * @function wcPlayEditor#__drawExitLinks * @private * @param {wcNode} node - The node to draw. * @param {external:Canvas~Context} context - The canvas context. * @param {Number} offset - An offset height. * @param {Number} width - The width of the area to draw in. */ __drawExitLinks: function(node, context, offset, width) { var xPos = node.pos.x - width/2 + this._drawStyle.links.margin; var yPos = node.pos.y + offset + this._font.links.size; context.save(); this.__setCanvasFont(this._font.links, context); var links = node.chain.exit; for (var i = 0; i &lt; links.length; ++i) { // Link label context.fillStyle = &quot;black&quot;; var w = context.measureText(links[i].name).width + this._drawStyle.links.spacing; context.fillText(links[i].name, xPos + this._drawStyle.links.spacing/2, yPos); // Link connector var rect = null; for (var a = 0; a &lt; node._meta.bounds.exitBounds.length; ++a) { if (node._meta.bounds.exitBounds[a].name === links[i].name) { rect = node._meta.bounds.exitBounds[a].rect; break; } } context.fillStyle = (this._highlightExitLink &amp;&amp; this._highlightExitLink.name === links[i].name &amp;&amp; this._highlightNode === node? &quot;cyan&quot;: links[i].meta.color); context.strokeStyle = &quot;black&quot;; context.beginPath(); context.moveTo(node.pos.x + rect.left + 5, node.pos.y + rect.top); context.lineTo(node.pos.x + rect.left + rect.width - 5, node.pos.y + rect.top); context.lineTo(node.pos.x + rect.left + rect.width - 5, node.pos.y + rect.top + rect.height/2); context.lineTo(node.pos.x + rect.left + rect.width/2, node.pos.y + rect.top + rect.height); context.lineTo(node.pos.x + rect.left + 5, node.pos.y + rect.top + rect.height/2); context.closePath(); context.stroke(); context.fill(); xPos += w; } context.restore(); }, /** * Draws connection chains for a list of nodes. * @function wcPlayEditor#__drawChains * @private * @param {wcNode[]} nodes - A list of nodes to render chains for. * @param {external:Canvas~Context} context - The canvas context. */ __drawChains: function(nodes, context) { for (var i = 0; i &lt; nodes.length; ++i) { this.__drawNodeChains(nodes[i], context); } }, /** * Draws connection chains for a single node. * @function wcPlayEditor#__drawNodeChains * @private * @param {wcNode} node - A node to render chains for. * @param {external:Canvas~Context} context - The canvas context. */ __drawNodeChains: function(node, context) { for (var i = 0; i &lt; node.chain.exit.length; ++i) { var exitLink = node.chain.exit[i]; // Skip links that are not chained with anything. if (!exitLink.links.length) { continue; } var exitPoint; // Find the corresponding meta data for this link. for (var a = 0; a &lt; node._meta.bounds.exitBounds.length; ++a) { if (node._meta.bounds.exitBounds[a].name === exitLink.name) { exitPoint = node._meta.bounds.exitBounds[a].point; break; } } // Skip links that do not contain meta data (should not happen). if (!exitPoint) { console.log('ERROR: Attempted to draw chains for an exit link that has no meta data.'); continue; } // Follow each chain to their entry links. for (var a = 0; a &lt; exitLink.links.length; ++a) { var targetNode = exitLink.links[a].node; var targetName = exitLink.links[a].name; var entryLink; // Skip pairs of nodes that are not visible. if (!node._meta.visible &amp;&amp; !targetNode._meta.visible) { continue; } for (var b = 0; b &lt; targetNode.chain.entry.length; ++b) { if (targetNode.chain.entry[b].name === targetName) { entryLink = targetNode.chain.entry[b]; break; } } // The link for this chain was not found. if (!entryLink) { console.log('ERROR: Attempted to chain an exit link to an entry link that was not found.'); continue; } // Find the corresponding meta data for this link. var entryPoint; for (var b = 0; b &lt; targetNode._meta.bounds.entryBounds.length; ++b) { if (targetNode._meta.bounds.entryBounds[b].name === entryLink.name) { entryPoint = targetNode._meta.bounds.entryBounds[b].point; break; } } // Could not find meta data for this link. if (!entryPoint) { console.log('ERROR: Attempted to draw chains to an entry link that has no meta data.'); continue; } var flash = (exitLink.meta.flashDelta &gt; 0 &amp;&amp; entryLink.meta.flashDelta &gt; 0); var highlight = (this._highlightNode === targetNode &amp;&amp; this._highlightEntryLink &amp;&amp; this._highlightEntryLink.name === entryLink.name) || (this._highlightNode === node &amp;&amp; this._highlightExitLink &amp;&amp; this._highlightExitLink.name === exitLink.name); // Now we have both our links, lets chain them together! this.__drawChain(node.pos, targetNode.pos, exitPoint, entryPoint, node._meta.bounds.rect, targetNode._meta.bounds.rect, context, flash, highlight); } } for (var i = 0; i &lt; node.properties.length; ++i) { var outputProp = node.properties[i]; // Skip properties with no output links. if (!outputProp.outputs.length) { continue; } // Find the corresponding meta data for this link. var outputPoint; for (var a = 0; a &lt; node._meta.bounds.outputBounds.length; ++a) { if (node._meta.bounds.outputBounds[a].name === outputProp.name) { outputPoint = node._meta.bounds.outputBounds[a].point; break; } } // Failed to find bounds for the output link. if (!outputPoint) { console.log('ERROR: Attempted to draw chains for an output link that has no meta data.'); continue; } // Follow each chain to their input links. for (var a = 0; a &lt; outputProp.outputs.length; ++a) { var targetNode = outputProp.outputs[a].node; var targetName = outputProp.outputs[a].name; var inputProp; // Skip pairs of nodes that are not visible. if (!node._meta.visible &amp;&amp; !targetNode._meta.visible) { continue; } for (var b = 0; b &lt; targetNode.properties.length; ++b) { if (targetNode.properties[b].name === targetName) { inputProp = targetNode.properties[b]; } } // Failed to find the input property to link with. if (!inputProp) { console.log('ERROR: Attempted to chain a property link to a property that was not found.'); continue; } // Find the corresponding meta data for this link. var inputPoint; for (var b = 0; b &lt; targetNode._meta.bounds.inputBounds.length; ++b) { if (targetNode._meta.bounds.inputBounds[b].name === inputProp.name) { inputPoint = targetNode._meta.bounds.inputBounds[b].point; break; } } // Failed to find the meta data for a property input link. if (!inputPoint) { console.log('ERROR: Attempted to draw chains to a property input link that has no meta data.'); continue; } var flash = (outputProp.outputMeta.flashDelta &gt; 0 || inputProp.inputMeta.flashDelta &gt; 0); var highlight = (this._highlightNode === targetNode &amp;&amp; this._highlightInputLink &amp;&amp; this._highlightInputLink.name === inputProp.name) || (this._highlightNode === node &amp;&amp; this._highlightOutputLink &amp;&amp; this._highlightOutputLink.name === outputProp.name); // Now we have both our links, lets chain them together! this.__drawChain(node.pos, targetNode.pos, outputPoint, inputPoint, node._meta.bounds.rect, targetNode._meta.bounds.rect, context, flash, highlight, true); } } // Draw a link to the mouse cursor if we are making a connection. if (this._selectedNode === node &amp;&amp; this._selectedEntryLink) { var targetPos; var targetRect = null; var targetOffset = null; var highlight = false; if (this._highlightNode &amp;&amp; this._highlightExitLink) { targetPos = this._highlightExitLink.point; targetRect = this._highlightExitLink.rect; targetOffset = this._highlightNode.pos; highlight = true; } else { targetPos = { x: (this._mouse.x - this._viewportCamera.x) / this._viewportCamera.z, y: (this._mouse.y - this._viewportCamera.y) / this._viewportCamera.z, }; targetRect = { left: targetPos.x, top: targetPos.y, width: 1, height: 1, }; targetOffset = {x: 0, y: 0}; } var point; for (var i = 0; i &lt; node._meta.bounds.entryBounds.length; ++i) { if (node._meta.bounds.entryBounds[i].name === this._selectedEntryLink.name) { point = node._meta.bounds.entryBounds[i].point; } } this.__drawChain(targetOffset, node.pos, targetPos, point, targetRect, node._meta.bounds.rect, context, highlight); } if (this._selectedNode === node &amp;&amp; this._selectedExitLink) { var targetPos; var targetRect = null; var targetOffset = null; var highlight = false; if (this._highlightNode &amp;&amp; this._highlightEntryLink) { targetPos = this._highlightEntryLink.point; targetRect = this._highlightEntryLink.rect; targetOffset = this._highlightNode.pos; highlight = true; } else { targetPos = { x: (this._mouse.x - this._viewportCamera.x) / this._viewportCamera.z, y: (this._mouse.y - this._viewportCamera.y) / this._viewportCamera.z, }; targetRect = { left: targetPos.x, top: targetPos.y, width: 1, height: 1, }; targetOffset = {x: 0, y: 0}; } var point; for (var i = 0; i &lt; node._meta.bounds.exitBounds.length; ++i) { if (node._meta.bounds.exitBounds[i].name === this._selectedExitLink.name) { point = node._meta.bounds.exitBounds[i].point; } } this.__drawChain(node.pos, targetOffset, point, targetPos, node._meta.bounds.rect, targetRect, context, highlight); } if (this._selectedNode === node &amp;&amp; this._selectedInputLink) { var targetPos; var targetRect = null; var targetOffset = null; var highlight = false; if (this._highlightNode &amp;&amp; this._highlightOutputLink) { targetPos = this._highlightOutputLink.point; targetRect = this._highlightOutputLink.rect; targetOffset = this._highlightNode.pos; highlight = true; } else { targetPos = { x: (this._mouse.x - this._viewportCamera.x) / this._viewportCamera.z, y: (this._mouse.y - this._viewportCamera.y) / this._viewportCamera.z, }; targetRect = { left: targetPos.x, top: targetPos.y, width: 1, height: 1, }; targetOffset = {x: 0, y: 0}; } var point; for (var i = 0; i &lt; node._meta.bounds.inputBounds.length; ++i) { if (node._meta.bounds.inputBounds[i].name === this._selectedInputLink.name) { point = node._meta.bounds.inputBounds[i].point; } } this.__drawChain(targetOffset, node.pos, targetPos, point, targetRect, node._meta.bounds.rect, context, highlight, false, true); } if (this._selectedNode === node &amp;&amp; this._selectedOutputLink) { var targetPos; var targetRect = null; var targetOffset = null; var highlight = false; if (this._highlightNode &amp;&amp; this._highlightInputLink) { targetPos = this._highlightInputLink.point; targetRect = this._highlightInputLink.rect; targetOffset = this._highlightNode.pos; highlight = true; } else { targetPos = { x: (this._mouse.x - this._viewportCamera.x) / this._viewportCamera.z, y: (this._mouse.y - this._viewportCamera.y) / this._viewportCamera.z, }; targetRect = { left: targetPos.x, top: targetPos.y, width: 1, height: 1, }; targetOffset = {x: 0, y: 0}; } var point; for (var i = 0; i &lt; node._meta.bounds.outputBounds.length; ++i) { if (node._meta.bounds.outputBounds[i].name === this._selectedOutputLink.name) { point = node._meta.bounds.outputBounds[i].point; } } this.__drawChain(node.pos, targetOffset, point, targetPos, node._meta.bounds.rect, targetRect, context, highlight, false, true); } }, /** * Generic draw chain function, you can flip the x and y axes to achieve either a flow or property chain orientation. * @function wcPlayEditor#__drawChain * @private * @param {wcPlay~Coordinates} startOffset - The offset for the start position and rect. * @param {wcPlay~Coordinates} endOffset - The offset for the end position and rect. * @param {wcPlay~Coordinates} startPos - The start position (the exit link). * @param {wcPlay~Coordinates} endPos - The end position (the entry link). * @param {wcPlayEditor~Rect} startRect - The start node's bounding rect to avoid. * @param {wcPlayEditor~Rect} endPos - The end node's bounding rect to avoid. * @param {Boolean} [flash] - If true, will flash the link. * @param {Boolean} [isProperty] - If true, will render property chain orientation. * @param {external:Canvas~Context} context - The canvas context. */ __drawChain: function(startOffset, endOffset, startPos, endPos, startRect, endRect, context, flash, highlight, isProperty) { context.save(); context.lineWidth = 2; context.lineCap = &quot;round&quot;; context.lineJoin = &quot;round&quot;; context.beginPath(); context.moveTo((startOffset.x + startPos.x), (startOffset.y + startPos.y)); // this._chainDrawCount += 1; // Do some preparation to make the orientation invisible. function __lineTo(x, y) { if (isProperty) { context.lineTo(y, x); } else { context.lineTo(x, y); } }; function __arcTo(x1, y1, x2, y2, radius) { if (isProperty) { context.arcTo(y1, x1, y2, x2, radius); } else { context.arcTo(x1, y1, x2, y2, radius); } }; function __curveTo(x1, y1, x2, y2, x3, y3) { if (isProperty) { context.bezierCurveTo(y1, x1, y2, x2, y3, x3); } else { context.bezierCurveTo(x1, y1, x2, y2, x3, y3); } }; var start, end, startBounds, endBounds; if (isProperty) { start = { x: startOffset.y + startPos.y, y: startOffset.x + startPos.x, }; end = { x: endOffset.y + endPos.y, y: endOffset.x + endPos.x, }; startBounds = { top: startRect.left + startOffset.x, left: startRect.top + startOffset.y, width: startRect.height, height: startRect.width, }; endBounds = { top: endRect.left + endOffset.x, left: endRect.top + endOffset.y, width: endRect.height, height: endRect.width, }; context.strokeStyle = (highlight? 'cyan': (flash? '#CCCC00': '#33CC33')); } else { start = { x: startOffset.x + startPos.x, y: startOffset.y + startPos.y, }; end = { x: endOffset.x + endPos.x, y: endOffset.y + endPos.y, }; startBounds = { top: startRect.top + startOffset.y, left: startRect.left + startOffset.x, width: startRect.width, height: startRect.height, }; endBounds = { top: endRect.top + endOffset.y, left: endRect.left + endOffset.x, width: endRect.width, height: endRect.height, }; context.strokeStyle = (highlight? 'cyan': (flash? '#CCCC00': '#000000')); } switch (this._chainStyle) { // Squared chains case 0: var coreRadius = 15; // If the exit link is above the entry link if (start.y &lt; end.y) { var midx = (end.x + start.x) / 2; var midy = (end.y + start.y) / 2; var radius = Math.min(coreRadius, Math.abs(end.x - start.x)/2, Math.abs(end.y - start.y)/2); __arcTo(start.x, midy, midx, midy, radius); __arcTo(end.x, midy, end.x, end.y, radius); } // If the start rect is to the left side of the end rect. else if (startBounds.left + startBounds.width &lt; endBounds.left) { var midx = (endBounds.left + startBounds.left + startBounds.width) / 2 - 2; var midy = (end.y + start.y) / 2; var leftx = (midx + start.x) / 2; var rightx = (end.x + midx) / 2; var radius = Math.min(coreRadius, Math.abs(end.y - start.y)/4, Math.abs(midx - leftx), Math.abs(midx - rightx)); __arcTo(start.x, start.y + radius, leftx, start.y + radius, radius); __arcTo(midx, start.y + radius, midx, midy, radius); __arcTo(midx, end.y - radius, rightx, end.y - radius, radius); __arcTo(end.x, end.y - radius, end.x, end.y, radius); } // If the start rect is to the right side of the end rect. else if (startBounds.left &gt; endBounds.left + endBounds.width) { var midx = (startBounds.left + endBounds.left + endBounds.width) / 2 + 2; var midy = (end.y + start.y) / 2; var leftx = (midx + end.x) / 2; var rightx = (start.x + midx) / 2; var radius = Math.min(coreRadius, Math.abs(end.y - start.y)/4, Math.abs(midx - leftx), Math.abs(midx - rightx)); __arcTo(start.x, start.y + radius, rightx, start.y + radius, radius); __arcTo(midx, start.y + radius, midx, midy, radius); __arcTo(midx, end.y - radius, leftx, end.y - radius, radius); __arcTo(end.x, end.y - radius, end.x, end.y, radius); } // If the start link is below the end link. Makes a loop around the nodes. else if (start.y &gt; end.y &amp;&amp; Math.abs(start.y - end.y) &gt; this._drawStyle.links.length) { var a = start.x; var top = Math.min(startBounds.top - coreRadius, endBounds.top - coreRadius); var bottom = Math.max(startBounds.top + startBounds.height + coreRadius, endBounds.top + endBounds.height + coreRadius); var midy = (start.y + end.y) / 2; // Choose left or right. if (Math.abs(Math.min(startBounds.left, endBounds.left) - start.x) &lt;= Math.abs(Math.max(startBounds.left + startBounds.width, endBounds.left + endBounds.width) - end.x)) { // Left a = Math.min(startBounds.left - coreRadius, endBounds.left - coreRadius); bottom -= 2; } else { // Right a = Math.max(startBounds.left + startBounds.width + coreRadius, endBounds.left + endBounds.width + coreRadius); bottom += 2; } var midx = (start.x + a) / 2; var radius = Math.min(coreRadius, Math.abs(a - (start.x))/2, Math.abs(a - (end.x))/2); __arcTo(start.x, bottom, midx, bottom, radius); __arcTo(a, bottom, a, midy, radius); __arcTo(a, top, midx, top, radius); __arcTo(end.x, top, end.x, end.y, radius); } break; // Splined chains. case 1: // If the Exit link is right above the Entry link target. if (start.y &lt; end.y) { var midy = (start.y + end.y) / 2; var midx = (start.x + end.x) / 2; __curveTo(start.x, midy, end.x, midy, end.x, end.y); } // If the start rect is to the left or right side of the end rect. else if (startBounds.left + startBounds.width &lt; endBounds.left || startBounds.left &gt; endBounds.left + endBounds.width) { var radius = Math.abs(start.y - end.y) / 2; var top = endBounds.top - radius; var bottom = startBounds.top + startBounds.height + radius; __curveTo(start.x, bottom, end.x, top, end.x, end.y); } // If the start link is below the end link. Makes a loop around the nodes. else if (start.y &gt; end.y &amp;&amp; Math.abs(start.y - end.y) &gt; this._drawStyle.links.length) { var sidex = start.x; // Choose left or right. if (Math.abs(Math.min(startBounds.left, endBounds.left) - start.x) &lt;= Math.abs(Math.max(startBounds.left + startBounds.width, endBounds.left + endBounds.width) - end.x)) { // Left sidex = Math.min(startBounds.left, endBounds.left) - 15; } else { // Right sidex = Math.max(startBounds.left + startBounds.width, endBounds.left + endBounds.width) + 15; } var top = endBounds.top - 30; var bottom = Math.max(startBounds.top + startBounds.height + 30, endBounds.top + endBounds.height + 30); var midy = (start.y + end.y)/2; __curveTo(start.x, bottom, sidex, bottom, sidex, midy); __curveTo(sidex, top, end.x, top, end.x, end.y); // var top = endBounds.top - Math.abs(end.x - sidex)/2; // var bottom = Math.max(startBounds.top + startBounds.height + Math.abs(start.x - sidex)/2, endBounds.top + endBounds.height + Math.abs(end.x - sidex)/2); // __curveTo(start.x, bottom, sidex, bottom, sidex, start.y); // __lineTo(sidex, end.y); // __curveTo(sidex, top, end.x, top, end.x, end.y); } break; } // Finish our line to the end position. context.lineTo((endOffset.x + endPos.x), (endOffset.y + endPos.y)); context.stroke(); context.restore(); }, /** * Draws the value of a property embedded on the node. * @function wcPlayEditor#__drawPropertyValue * @private * @param {wcNode} node - The node that owns this property. * @param {Object} property - The property data. * @param {Boolean} [initial] - Set true if the property being viewed is the initial value. * @param {Boolean} [expanded] - For initial values, if we are not displaying the current value then we should expand the display * @returns {String} - A string value to print as the value. * * @see {wcNode~wcNode~PropertyOptions} * @see {wcNode~PropertyDisplay} */ __drawPropertyValue: function(node, property, initial, expanded) { var value; if (initial) { value = node.initialProperty(property.name); } else { value = node.property(property.name); } if (typeof property.options.display === 'function') { value = property.options.display(value); } else { // Handle custom display of certain property types. switch (property.type) { case wcPlay.PROPERTY.TOGGLE: // Display toggle buttons as 'yes', 'no' return (value? 'yes': 'no'); case wcPlay.PROPERTY.SELECT: var noneValue = ''; if (property.options.hasOwnProperty('noneValue')) { noneValue = property.options.noneValue; } // Display none only if we allow none. if ((!property.options.hasOwnProperty('allowNone') || property.options.allowNone) &amp;&amp; value == noneValue) { return '&lt;none&gt;'; } var items = property.options.items; if ($.isFunction(items)) { items = items.call(node); } if ($.isArray(items)) { var found = false; for (var i = 0; i &lt; items.length; ++i) { if (typeof items[i] === 'object') { if (items[i].value == value) { value = items[i].name; found = true; break; } } else if (typeof items[i] === 'string') { if (items[i] == value) { found = true; break; } } } if (!found) { value = '&lt;unknown&gt;'; } } break; } } return this.__clampString(String(value), (expanded? this._drawStyle.property.longStrLen: this._drawStyle.property.strLen)); }, /** * Draws the detail popup box for the node. * @function wcPlayEditor#__drawDetailsPopup * @param {wcNode} node - The node to draw for. */ __drawDetailsPopup: function(node) { var displayTitle = node.type + ' Node'; var displayInfo = node.description(); if (displayInfo) { displayInfo += '\\n\\n'; } displayInfo += node.details(); var $blocker = $('&lt;div class=&quot;wcPlayDetailsPopupBlocker&quot;&gt;'); var $popup = $('&lt;div class=&quot;wcPlayDetailsPopup&quot;&gt;'); var $title = $('&lt;h3&gt;' + displayTitle + '&lt;/h3&gt;'); var $info = $('&lt;pre class=&quot;wcPlayDetailsPopupText&quot;&gt;' + displayInfo + '&lt;/pre&gt;'); $popup.append($title); $popup.append($info); $blocker.append($popup); $('body').append($blocker); $blocker.click(function() { $(this).remove(); }); }, /** * Draws the editor control for the title of the node. * @function wcPlayEditor#__drawTitleEditor * @private * @param {wcNode} node - The node to draw for. * @param {wcPlayEditor~BoundingData} bounds - The bounding data for the title. */ __drawTitleEditor: function(node, bounds) { if (this._options.readOnly) { return; } var self = this; var cancelled = false; var $control = $('&lt;input type=&quot;text&quot;&gt;'); $control.val(node.name); $control.change(function() { if (!cancelled) { self._undoManager &amp;&amp; self._undoManager.addEvent('Title changed for Node &quot;' + node.category + '.' + node.type + '&quot;', { id: node.id, oldValue: node.name, newValue: $control.val(), engine: self._engine, }, // Undo function() { var myNode = this.engine.nodeById(this.id); var oldName = myNode.name; var newName = myNode.onNameChanging(oldName, this.oldValue); if (newName === undefined) { newName = this.oldValue; } myNode.name = newName; myNode.onNameChanged(oldName, newName); }, // Redo function() { var myNode = this.engine.nodeById(this.id); var oldName = myNode.name; var newName = myNode.onNameChanging(oldName, this.newValue); if (newName === undefined) { newName = this.newValue; } myNode.name = newName; myNode.onNameChanged(oldName, newName); }); var oldName = node.name; var newName = node.onNameChanging(oldName, $control.val()); if (newName === undefined) { newName = $control.val(); } node.name = newName; node.onNameChanged(oldName, newName); } }); var offset = { top: 0, left: this.$palette.width(), }; this.$main.append($control); $control.addClass('wcPlayEditorControl'); $control.focus(); $control.select(); // Clicking away will close the editor control. $control.blur(function() { $(this).remove(); }); $control.keydown(function(event) { event.stopPropagation(); }); $control.keyup(function(event) { switch (event.keyCode) { case 13: // Enter to confirm. $control.blur(); break; case 27: // Escape to cancel. cancelled = true; $control.blur(); break; } return false; }); $control.css('top', offset.top + (node.pos.y + bounds.top) * this._viewportCamera.z + this._viewportCamera.y) .css('left', offset.left + (node.pos.x + bounds.left) * this._viewportCamera.z + this._viewportCamera.x) .css('width', Math.max(bounds.width * this._viewportCamera.z, 200)) .css('height', Math.max(bounds.height * this._viewportCamera.z, 15)); }, /** * Draws the editor control for a property. * @function wcPlayEditor#__drawPropertyEditor * @private * @param {wcNode} node - The node to draw for. * @param {Object} property - The property data. * @param {wcPlayEditor~BoundingData} bounds - The bounding data for this property. * @param {Boolean} [initial] - Set true if the property being changed is the initial value. */ __drawPropertyEditor: function(node, property, bounds, initial) { if (this._options.readOnly) { return; } var $control = null; var cancelled = false; var enterConfirms = true; var propFn = (initial? 'initialProperty': 'property'); var self = this; function undoChange(node, name, oldValue, newValue) { self._undoManager &amp;&amp; self._undoManager.addEvent('Property &quot;' + name + '&quot; changed for Node &quot;' + node.category + '.' + node.type + '&quot;', { id: node.id, name: name, propFn: propFn, oldValue: oldValue, newValue: newValue, engine: self._engine, }, // Undo function() { var myNode = this.engine.nodeById(this.id); if (myNode) { myNode[this.propFn](this.name, this.oldValue, true, true); } }, // Redo function() { var myNode = this.engine.nodeById(this.id); if (myNode) { myNode[this.propFn](this.name, this.newValue, true, true); } }); }; var $blocker = $('&lt;div class=&quot;wcPlayEditorBlocker&quot;&gt;'); // Determine what editor to use for the property. switch (property.type) { case wcPlay.PROPERTY.TOGGLE: // Toggles do not show an editor, instead, they just toggle their state. var state = node[propFn](property.name); node[propFn](property.name, !state, true, true); undoChange(node, property.name, state, !state); break; case wcPlay.PROPERTY.NUMBER: $control = $('&lt;input type=&quot;number&quot;' + (property.options.min? ' min=&quot;' + property.options.min + '&quot;': '') + (property.options.max? ' max=&quot;' + property.options.max + '&quot;': '') + (property.options.step? ' step=&quot;' + property.options.step + '&quot;': '') + '&gt;'); $control.val(parseFloat(node[propFn](property.name))); $control.change(function() { if (!cancelled) { var min = $(this).attr('min') !== undefined? parseFloat($(this).attr('min')): -Infinity; var max = $(this).attr('max') !== undefined? parseFloat($(this).attr('max')): Infinity; value = Math.min(max, Math.max(min, parseFloat($control.val()))); node[propFn](property.name, value, true, true); undoChange(node, property.name, value, node[propFn](property.name)); // $blocker.click(); } }); $control.keyup(function(event) { if (event.keyCode === 13) { $blocker.click(); } }); break; case wcPlay.PROPERTY.STRING: case wcPlay.PROPERTY.DYNAMIC: var datalistProp = ''; var items = property.options.items; if ($.isFunction(items)) { items = items.call(node); } if (Array.isArray(items)) { datalistProp = ' list=&quot;wcDynamicSuggestionList&quot;'; var $dataList = $('&lt;datalist id=&quot;wcDynamicSuggestionList&quot;/&gt;'); for (var i = 0; i &lt; items.length; ++i) { if (typeof items[i] === 'object') { $dataList.append($('&lt;option value=&quot;' + items[i].value + '&quot;&gt;' + items[i].name + '&lt;/option&gt;')); } else { $dataList.append($('&lt;option value=&quot;' + items[i] + '&quot;&gt;' + items[i] + '&lt;/option&gt;')); } } $('body').append($dataList); } if (property.options.multiline) { $control = $('&lt;textarea' + (property.options.maxlength? ' maxlength=&quot;' + property.options.maxlength + '&quot;': '') + datalistProp + '/&gt;'); enterConfirms = false; } else { $control = $('&lt;input type=&quot;text&quot; maxlength=&quot;' + (property.options.maxlength || 524288) + '&quot;' + datalistProp + '/&gt;'); } $control.val(node[propFn](property.name).toString()); $control.change(function() { if (!cancelled) { value = node[propFn](property.name); node[propFn](property.name, $control.val(), true, true); undoChange(node, property.name, value, node[propFn](property.name)); $blocker.click(); } }); break; case wcPlay.PROPERTY.SELECT: var value = node[propFn](property.name); $control = $('&lt;select&gt;'); var items = property.options.items; if ($.isFunction(items)) { items = items.call(node); } if (Array.isArray(items)) { var noneValue = ''; if (property.options.hasOwnProperty('noneValue')) { noneValue = property.options.noneValue; } var found = false; if (!property.options.hasOwnProperty('allowNone') || property.options.allowNone) { $control.append($('&lt;option value=&quot;&quot;' + (noneValue == value? ' selected': '') + '&gt;&amp;lt;none&amp;gt;&lt;/option&gt;')); if (noneValue == value) found = true; } for (var i = 0; i &lt; items.length; ++i) { if (typeof items[i] === 'object') { $control.append($('&lt;option value=&quot;' + items[i].value + '&quot;' + (items[i].value == value? ' selected': '') + '&gt;' + items[i].name + '&lt;/option&gt;')); if (items[i].value == value) found = true; } else { $control.append($('&lt;option value=&quot;' + items[i] + '&quot;' + (items[i] == value? ' selected': '') + '&gt;' + items[i] + '&lt;/option&gt;')); if (items[i] == value) found = true; } } // We did not find the current item, prepend an 'unknown' entry and select that instead. if (!found) { $control.prepend($('&lt;option value=&quot;' + value + '&quot; selected&gt;&amp;lt;unknown&amp;gt;&lt;/option&gt;')); } } else { console.log(&quot;ERROR: Tried to display a Select type property when no selection list was provided.&quot;); return; } $control.change(function() { if (!cancelled) { value = node[propFn](property.name); var newValue = $control.val(); if (newValue == '' &amp;&amp; property.options.hasOwnProperty('noneValue')) { newValue = property.options.noneValue; } node[propFn](property.name, newValue, true, true); undoChange(node, property.name, value, node[propFn](property.name)); $blocker.click(); } }); break; case wcPlay.PROPERTY.CUSTOM: if (typeof property.options.onCreate === 'function') { var value = node[propFn](property.name); $control = $(property.options.onCreate(node, property.name, value, initial, function(newValue) { if (!cancelled) { value = node[propFn](property.name); node[propFn](property.name, newValue, true, true); undoChange(node, property.name, value, node[propFn](property.name)); $blocker.click(); } })); } break; } if ($control) { var offset = { top: 0, left: this.$palette.width(), }; this.$main.append($blocker); this.$main.append($control); $control.addClass('wcPlayEditorControl'); $control.focus(); $control.select(); // Clicking away will close the editor control. $blocker.click(function(event) { event.stopPropagation(); $blocker.remove(); $control.remove(); }); $control.keydown(function(event) { event.stopPropagation(); }); $control.keyup(function(event) { switch (event.keyCode) { case 13: // Enter to confirm. if (enterConfirms || event.ctrlKey) { $control.blur(); } break; case 27: // Escape to cancel. cancelled = true; $control.blur(); break; } return false; }); $control.css('top', offset.top + (node.pos.y + bounds.rect.top) * this._viewportCamera.z + this._viewportCamera.y) .css('left', offset.left + (node.pos.x + bounds.rect.left) * this._viewportCamera.z + this._viewportCamera.x) .css('width', Math.max(bounds.rect.width * this._viewportCamera.z, 200)) .css('height', Math.max(bounds.rect.height * this._viewportCamera.z, 15)); } }, /** * Generates an undo event for a node that was created. * @function wcPlayEditor#__onCreateNode * @param {wcNode} node - The node that was created. */ __onCreateNode: function(node) { this._undoManager &amp;&amp; this._undoManager.addEvent('Created Node &quot;' + node.category + '.' + node.type + '&quot;', { id: node.id, className: node.className, data: node.export(), engine: this._engine, parent: this._parent.id || this._parent, }, // Undo function() { var myNode = this.engine.nodeById(this.id); // If we are viewing a script inside the node that is being removed, re-direct our view to its parents. for (var i = 0; i &lt; this.engine._editors.length; ++i) { var parent = this.engine._editors[i]._parent; while (!(parent &amp;&amp; parent.instanceOf('wcPlay'))) { if (parent == myNode) { this.engine._editors[i]._parent = myNode._parent; this.engine._editors[i].center(); break; } parent = parent._parent; } } // Now destroy this node. myNode.destroy(); }, // Redo function() { var parent = this.parent; if (typeof parent === 'number') { parent = this.engine.nodeById(parent); } var myNode = new window[this.className](parent, this.data.pos); myNode.id = this.id; myNode.import(this.data); }); }, /** * Generates an undo event for a node that is destroyed. * @function wcPlayEditor#__onDestroyNode * @param {wcNode} node - the node to destroy. */ __onDestroyNode: function(node) { this._undoManager &amp;&amp; this._undoManager.addEvent('', { data: node.export(), parent: this._parent, engine: this._engine, }, // Undo function() { var myNode = new window[this.data.className](this.parent, this.data.pos); myNode.import(this.data); }, // Redo function() { var myNode = this.engine.nodeById(this.data.id); // If we are viewing a script inside the node that is being removed, re-direct our view to its parents. for (var i = 0; i &lt; this.engine._editors.length; ++i) { var parent = this.engine._editors[i]._parent; while (!(parent &amp;&amp; parent.instanceOf('wcPlay'))) { if (parent == myNode) { this.engine._editors[i]._parent = myNode._parent; this.engine._editors[i].center(); break; } parent = parent._parent; } } // Now destroy this node. myNode.destroy(); }); }, /** * Handles auto scrolling based on mouse position. * @function wcPlayEditor#__handleAutoScroll * @param {Boolean} active - Whether the auto scroll is active. * @param {Boolean} movingNodes - If true, the auto scroll will also move selected nodes. */ __handleAutoScroll: function(active, movingNodes) { var shouldBeActive = false; var width = this.$viewport.width(); var height = this.$viewport.height(); var THRESHOLD = Math.min(50, width/2, height/2); this._autoScrollNodes = movingNodes; if (active) { if (this._mouse.x &gt;= width - THRESHOLD) { shouldBeActive = true; this._autoScrollDirection.x = this._mouse.x - width + THRESHOLD; this._autoScrollDirection.y = 0; } else if (this._mouse.x &lt;= THRESHOLD) { shouldBeActive = true; this._autoScrollDirection.x = this._mouse.x - THRESHOLD; this._autoScrollDirection.y = 0; } if (this._mouse.y &gt;= height - THRESHOLD) { shouldBeActive = true; this._autoScrollDirection.x = 0; this._autoScrollDirection.y = this._mouse.y - height + THRESHOLD; } else if (this._mouse.y &lt;= THRESHOLD) { shouldBeActive = true; this._autoScrollDirection.x = 0; this._autoScrollDirection.y = this._mouse.y - THRESHOLD; } } if (shouldBeActive &amp;&amp; !this._autoScrollInterval) { var self = this; this._autoScrollInterval = setInterval(function() { var moveX = self._autoScrollDirection.x; var moveY = self._autoScrollDirection.y; self._viewportCamera.x -= moveX; self._viewportCamera.y -= moveY; if (self._autoScrollNodes) { for (var i = 0; i &lt; self._selectedNodes.length; ++i) { var node = self._selectedNodes[i]; var oldPos = { x: node.pos.x, y: node.pos.y, }; var newPos = { x: node.pos.x + (moveX / self._viewportCamera.z), y: node.pos.y + (moveY / self._viewportCamera.z), }; var newPos = node.onMoving(oldPos, newPos) || newPos; if (oldPos.x !== newPos.x || oldPos.y !== newPos.y) { node.pos.x = newPos.x; node.pos.y = newPos.y; node.onMoved(oldPos, newPos); } } } }, 10); } else if (this._autoScrollInterval &amp;&amp; !shouldBeActive) { clearInterval(this._autoScrollInterval); this._autoScrollInterval = 0; } }, /** * Initializes user control. * @funciton wcPlayEditor#__setupControls * @private */ __setupControls: function() { var self = this; // Menu this.__bindMenuHandlers(); // Palette this.$palette.on('mousemove', function(event){self.__onPaletteMouseMove(event, this);}); this.$palette.on('mousedown', function(event){self.__onPaletteMouseDown(event, this);}); this.$palette.on('mouseup', function(event){self.__onPaletteMouseUp(event, this);}); // Viewport this.$viewport.on('mousemove', function(event){self.__onViewportMouseMove(event, this);}); this.$viewport.on('mousedown', function(event){self.__onViewportMouseDown(event, this);}); this.$viewport.on('mouseup', function(event){self.__onViewportMouseUp(event, this);}); this.$viewport.on('mouseenter', function(event){self.__onViewportMouseEnter(event, this);}); this.$viewport.on('mouseleave', function(event){self.__onViewportMouseLeave(event, this);}); this.$viewport.on('click', function(event){self.__onViewportMouseClick(event, this);}); this.$viewport.on('dblclick', function(event){self.__onViewportMouseDoubleClick(event, this);}); this.$viewport.on('mousewheel DOMMouseScroll', function(event) {self.__onViewportMouseWheel(event, this);}); }, /** * Binds click event handlers to each of the options in the menu and toolbar. * @function wcPlayEditor#__bindMenuHandlers * @private */ __bindMenuHandlers: function() { var self = this; // Import the contents of a file. function __importScriptFile(file, importing) { if (importing) { self.triggerEvent('onBeforeImport', []); } else { self.triggerEvent('onBeforeLoad', []); } var reader = new FileReader(); reader.onload = function(e) { if (self._engine) { if (importing) { // Import the script as its own Composite node. if (self._engine.import(e.target.result, file.name)) { self.__setupPalette(); self.triggerEvent('onImported', []); self.$typeButton[3].click(); } } else { if (self._engine.load(e.target.result)) { self._parent = self._engine; self._selectedNode = null; self._selectedNodes = []; self._undoManager &amp;&amp; self._undoManager.clear(); self.center(); self.triggerEvent('onLoaded', []); } else { alert('Failed to open file &quot;' + file.name + '&quot;\\nPlease check to ensure it is actually a wcPlay script file.'); } } } }; reader.readAsText(file); } // A hidden file input field that will handle opening the open file dialog for us. $('body').on('change', '#wcPlayEditorHiddenFileLoader', function(event) { if ($(this).hasClass('disabled')) { return; } if (event.target.files.length) { __importScriptFile(event.target.files[0]); $(this).val(''); $(this).remove(); } }); $('body').on('change', '#wcPlayEditorHiddenFileImporter', function(event) { if ($(this).hasClass('disabled')) { return; } if (event.target.files.length) { __importScriptFile(event.target.files[0], true); $(this).val(''); $(this).remove(); } }); // Support drag-drop over the entire window. this.$container.on('dragover', function(event) { event.stopPropagation(); event.preventDefault(); event.originalEvent.dataTransfer.dropEffect = 'copy'; }); this.$container.on('drop', function(event) { event.stopPropagation(); event.preventDefault(); if (event.originalEvent.dataTransfer.files.length) { __importScriptFile(event.originalEvent.dataTransfer.files[0], event.ctrlKey); } }); }, /** * Handle mouse move events over the palette view. * @function wcPlayEditor#__onPaletteMouseMove * @private * @param {Object} event - The mouse event. * @param {Object} elem - The target element. */ __onPaletteMouseMove: function(event, elem) { var mouse = this.__mouse(event); this._highlightTitle = false; this._highlightDetails = false; this._highlightDebugLog = false; this._highlightBreakpoint = false; this._highlightEntryLink = false; this._highlightExitLink = false; this._highlightInputLink = false; this._highlightOutputLink = false; this._highlightPropertyValue = false; this._highlightPropertyInitialValue = false; this._highlightViewport = false; // Dragging a node from the palette view. if (this._draggingNodeData) { var pos = { x: mouse.gx + this._draggingNodeData.offset.x, y: mouse.gy + this._draggingNodeData.offset.y, }; this._draggingNodeData.$canvas.css('left', pos.x).css('top', pos.y); return; } var categoryData = this.__findCategoryAreaAtPos(mouse); if (categoryData) { var offset = categoryData.$canvas.offset(); mouse = this.__mouse(event, offset); var node = this.__findNodeAtPos(mouse, {x:0,y:0,z:this._drawStyle.palette.scale}, categoryData.nodes); if (node) { this._highlightNode = node; this.$palette.addClass('wcClickable'); this.$palette.attr('title', 'Create a new instance of this node by dragging this into your script.'); } else { this._highlightNode = null; this.$palette.removeClass('wcClickable'); this.$palette.attr('title', ''); } } }, /** * Handle mouse down events over the palette view. * @function wcPlayEditor#__onPaletteMouseDown * @private * @param {Object} event - The mouse event. * @param {Object} elem - The target element. */ __onPaletteMouseDown: function(event, elem) { if (this._highlightNode) { this.__onPaletteMouseUp(event, elem); var mouse = this.__mouse(event); var rect = this._highlightNode._meta.bounds.rect; var categoryData = this.__findCategoryAreaAtPos(mouse); if (categoryData) { var offset = categoryData.$canvas.offset(); var screenOffset = this.$container.offset(); this._draggingNodeData = { node: this._highlightNode, $canvas: $('&lt;canvas class=&quot;wcPlayHoverCanvas&quot;&gt;'), offset: {x: 0, y: 0} }; this.$container.append(this._draggingNodeData.$canvas); this.$palette.addClass('wcMoving'); this.$viewport.addClass('wcMoving'); this._draggingNodeData.$canvas.css('left', this._highlightNode.pos.x + rect.left + offset.left - screenOffset.left) .css('top', this._highlightNode.pos.y + rect.top + offset.top - screenOffset.top); this._draggingNodeData.$canvas.attr('width', rect.width).css('width', rect.width); this._draggingNodeData.$canvas.attr('height', rect.height).css('height', rect.height); this._draggingNodeData.offset.x = (this._highlightNode.pos.x * this._drawStyle.palette.scale + rect.left + offset.left - screenOffset.left) - mouse.x; this._draggingNodeData.offset.y = (this._highlightNode.pos.y * this._drawStyle.palette.scale + rect.top + offset.top - screenOffset.top) - mouse.y; var yPos = 0; if (!this._highlightNode.chain.entry.length) { yPos += this._drawStyle.links.length; } this._highlightNode.pos.x = rect.width/2; this._highlightNode.pos.y = yPos+3; this.__drawNode(this._highlightNode, this._draggingNodeData.$canvas[0].getContext('2d'), true); } } }, /** * Handle mouse up events over the palette view. * @function wcPlayEditor#__onPaletteMouseDown * @private * @param {Object} event - The mouse event. * @param {Object} elem - The target element. */ __onPaletteMouseUp: function(event, elem) { if (this._draggingNodeData) { this._draggingNodeData.$canvas.remove(); this._draggingNodeData.$canvas = null; this._draggingNodeData = null; this.$palette.removeClass('wcMoving'); this.$viewport.removeClass('wcMoving'); } }, /** * Handle mouse move events over the viewport canvas. * @function wcPlayEditor#__onViewportMouseMove * @private * @param {Object} event - The mouse event. * @param {Object} elem - The target element. */ __onViewportMouseMove: function(event, elem) { var mouse = this.__mouse(event, this.$viewport.offset()); if (mouse.x !== this._mouse.x || mouse.y !== this._mouse.y) { this._mouseMoved = true; } // Dragging a node from the palette view. if (this._draggingNodeData) { var pos = { x: mouse.gx + this._draggingNodeData.offset.x, y: mouse.gy + this._draggingNodeData.offset.y, }; this._draggingNodeData.$canvas.css('left', pos.x).css('top', pos.y); this._mouse = mouse; this.__handleAutoScroll(true); return; } // Box selection. if (this._highlightRect &amp;&amp; this._parent) { this._highlightRect.x = ((mouse.x - this._viewportCamera.x) / this._viewportCamera.z) - this._highlightRect.ox; this._highlightRect.y = ((mouse.y - this._viewportCamera.y) / this._viewportCamera.z) - this._highlightRect.oy; this._highlightRect.width = this._highlightRect.x; this._highlightRect.height = this._highlightRect.y; if (this._highlightRect.width &lt; 0) { this._highlightRect.left = this._highlightRect.ox + this._highlightRect.width; this._highlightRect.width *= -1; } if (this._highlightRect.height &lt; 0) { this._highlightRect.top = this._highlightRect.oy + this._highlightRect.height; this._highlightRect.height *= -1; } this._selectedNodes = []; var self = this; function __nodesInRect(nodes) { for (var i = 0; i &lt; nodes.length; ++i) { if (self.__rectOnRect(nodes[i]._meta.bounds.inner, self._highlightRect, nodes[i].pos)) { self._selectedNodes.push(nodes[i]); } } }; __nodesInRect(this._parent._storageNodes); __nodesInRect(this._parent._compositeNodes); __nodesInRect(this._parent._processNodes); __nodesInRect(this._parent._entryNodes); this._mouse = mouse; this.__handleAutoScroll(true); return; } // Viewport panning. if (this._viewportMoving) { var moveX = mouse.x - this._mouse.x; var moveY = mouse.y - this._mouse.y; this._viewportCamera.x += moveX; this._viewportCamera.y += moveY; this._mouse = mouse; if (!this._viewportMoved &amp;&amp; this._mouseMoved) { this._viewportMoved = true; this.$viewport.addClass('wcMoving'); } this.__handleAutoScroll(false); return; } // Moving nodes if (this._viewportMovingNode) { var moveX = mouse.x - this._mouse.x; var moveY = mouse.y - this._mouse.y; for (var i = 0; i &lt; this._selectedNodes.length; ++i) { var node = this._selectedNodes[i]; var oldPos = { x: node.pos.x, y: node.pos.y, }; var newPos = { x: node.pos.x + (moveX / this._viewportCamera.z), y: node.pos.y + (moveY / this._viewportCamera.z), }; var newPos = node.onMoving(oldPos, newPos) || newPos; if (oldPos.x !== newPos.x || oldPos.y !== newPos.y) { node.pos.x = newPos.x; node.pos.y = newPos.y; node.onMoved(oldPos, newPos); } } this._mouse = mouse; this.__handleAutoScroll(true, true); return; } this._mouse = mouse; this._highlightNode = null; this._highlightCrumb = -1; this._highlightTitle = false; this._highlightDetails = false; this._highlightDebugLog = false; this._highlightBreakpoint = false; this._highlightEntryLink = false; this._highlightExitLink = false; this._highlightInputLink = false; this._highlightOutputLink = false; this._highlightPropertyValue = false; this._highlightPropertyInitialValue = false; this.__handleAutoScroll(this._selectedEntryLink || this._selectedExitLink || this._selectedInputLink || this._selectedOutputLink); var wasOverViewport = this._highlightViewport; this._highlightViewport = false; this.$viewport.removeClass('wcClickable wcMoving wcGrab'); this.$viewport.attr('title', ''); for (var i = 0; i &lt; this._crumbBounds.length; ++i) { if (this.__inRect(mouse, this._crumbBounds[i].rect)) { this._highlightCrumb = i; this.$viewport.addClass('wcClickable'); this.$viewport.attr('title', 'Click to go to this level in the hierarchy.'); break; } } var node = null; if (this._highlightCrumb === -1) { node = this.__findNodeAtPos(mouse, this._viewportCamera); } if (node) { // Check for main node collision. if (!this._options.readOnly &amp;&amp; this.__inRect(mouse, node._meta.bounds.farRect, node.pos, this._viewportCamera)) { this._highlightNode = node; // if (this.__inRect(mouse, node._meta.bounds.inner, node.pos, this._viewportCamera)) { this.$viewport.attr('title', (node._meta.description? node._meta.description + '\\n': '')); this.$viewport.addClass('wcMoving'); // } } if (!this._selectedEntryLink &amp;&amp; !this._selectedExitLink &amp;&amp; !this._selectedInputLink &amp;&amp; !this._selectedOutputLink) { // Debug Log button. if (this.__inRect(mouse, node._meta.bounds.debugLog, node.pos, this._viewportCamera)) { this._highlightDebugLog = true; this._highlightNode = node; this.$viewport.addClass('wcClickable'); if (node._log) { this.$viewport.attr('title', 'Disable debug logging for this node.'); } else { this.$viewport.attr('title', 'Enable debug logging for this node.'); } } // Breakpoint button. if (this.__inRect(mouse, node._meta.bounds.breakpoint, node.pos, this._viewportCamera)) { this._highlightBreakpoint = true; this._highlightNode = node; this.$viewport.addClass('wcClickable'); this.$viewport.attr('title', 'Toggle debug breakpoint on this node.'); } } // Entry links. if (!this._options.readOnly &amp;&amp; !this._selectedEntryLink &amp;&amp; !this._selectedInputLink &amp;&amp; !this._selectedOutputLink) { for (var i = 0; i &lt; node._meta.bounds.entryBounds.length; ++i) { if (this.__inRect(mouse, node._meta.bounds.entryBounds[i].rect, node.pos, this._viewportCamera)) { this._highlightNode = node; this._highlightEntryLink = node._meta.bounds.entryBounds[i]; var link; for (var a = 0; a &lt; node.chain.entry.length; ++a) { if (node.chain.entry[a].name == this._highlightEntryLink.name) { link = node.chain.entry[a]; break; } } this.$viewport.attr('title', (link.meta.description? link.meta.description + '\\n': '') + 'Click and drag to create a new flow chain from another node. Double click to manually fire this entry link.'); this.$viewport.addClass('wcGrab'); break; } } } // Exit links. if (!this._options.readOnly &amp;&amp; !this._selectedExitLink &amp;&amp; !this._selectedInputLink &amp;&amp; !this._selectedOutputLink) { for (var i = 0; i &lt; node._meta.bounds.exitBounds.length; ++i) { if (this.__inRect(mouse, node._meta.bounds.exitBounds[i].rect, node.pos, this._viewportCamera)) { this._highlightNode = node; this._highlightExitLink = node._meta.bounds.exitBounds[i]; var link; for (var a = 0; a &lt; node.chain.exit.length; ++a) { if (node.chain.exit[a].name == this._highlightExitLink.name) { link = node.chain.exit[a]; break; } } this.$viewport.attr('title', (link.meta.description? link.meta.description + '\\n': '') + 'Click and drag to create a new flow chain to another node. Double click to manually fire this exit link.'); this.$viewport.addClass('wcGrab'); break; } } } // Input links. if (!this._options.readOnly &amp;&amp; !this._selectedEntryLink &amp;&amp; !this._selectedExitLink &amp;&amp; !this._selectedInputLink) { for (var i = 0; i &lt; node._meta.bounds.inputBounds.length; ++i) { if (this.__inRect(mouse, node._meta.bounds.inputBounds[i].rect, node.pos, this._viewportCamera)) { this._highlightNode = node; this._highlightInputLink = node._meta.bounds.inputBounds[i]; this.$viewport.attr('title', 'Click and drag to chain this property to the output of another.'); this.$viewport.addClass('wcGrab'); break; } } } // Output links. if (!this._options.readOnly &amp;&amp; !this._selectedEntryLink &amp;&amp; !this._selectedExitLink &amp;&amp; !this._selectedOutputLink) { for (var i = 0; i &lt; node._meta.bounds.outputBounds.length; ++i) { if (this.__inRect(mouse, node._meta.bounds.outputBounds[i].rect, node.pos, this._viewportCamera)) { this._highlightNode = node; this._highlightOutputLink = node._meta.bounds.outputBounds[i]; this.$viewport.attr('title', 'Click and drag to chain this property to the input of another. Double click to manually propagate this property through the chain.'); this.$viewport.addClass('wcGrab'); break; } } } if (!this._selectedEntryLink &amp;&amp; !this._selectedExitLink &amp;&amp; !this._selectedInputLink &amp;&amp; !this._selectedOutputLink) { if (!this._options.readOnly) { // Title label. if (this.__inRect(this._mouse, node._meta.bounds.titleBounds, node.pos, this._viewportCamera)) { this._highlightNode = node; this._highlightTitle = true; this.$viewport.attr('title', 'Click to add or modify an additional label for this title.'); this.$viewport.addClass('wcClickable'); } // Details button. if (this.__inRect(this._mouse, node._meta.bounds.detailsBounds, node.pos, this._viewportCamera)) { this._highlightNode = node; this._highlightDetails = true; this.$viewport.attr('title', 'Click to see futher details for this node.'); this.$viewport.addClass('wcClickable'); } // Property labels. var propBounds; for (var i = 0; i &lt; node._meta.bounds.propertyBounds.length; ++i) { if (this.__inRect(this._mouse, node._meta.bounds.propertyBounds[i].rect, node.pos, this._viewportCamera)) { propBounds = node._meta.bounds.propertyBounds[i]; break; } } if (propBounds) { for (var i = 0; i &lt; node.properties.length; ++i) { if (node.properties[i].name === propBounds.name) { this.$viewport.attr('title', (node.properties[i].options.description? node.properties[i].options.description + '\\n': '')); this.$viewport.addClass('wcClickable'); break; } } } // Property values. var valueBounds; for (var i = 0; i &lt; node._meta.bounds.valueBounds.length; ++i) { if (this.__inRect(this._mouse, node._meta.bounds.valueBounds[i].rect, node.pos, this._viewportCamera)) { valueBounds = node._meta.bounds.valueBounds[i]; break; } } if (valueBounds) { for (var i = 0; i &lt; node.properties.length; ++i) { if (node.properties[i].name === valueBounds.name) { this._highlightNode = node; this._highlightPropertyValue = valueBounds; this.$viewport.attr('title', (node.properties[i].options.description? node.properties[i].options.description + '\\n': '') + 'Click to change the current value of this property.\\nValue = &quot;' + node.properties[i].value + '&quot;\\n'); this.$viewport.addClass('wcClickable'); break; } } } // Property initial values. var initialBounds; for (var i = 0; i &lt; node._meta.bounds.initialBounds.length; ++i) { if (this.__inRect(this._mouse, node._meta.bounds.initialBounds[i].rect, node.pos, this._viewportCamera)) { initialBounds = node._meta.bounds.initialBounds[i]; break; } } if (initialBounds) { for (var i = 0; i &lt; node.properties.length; ++i) { if (node.properties[i].name === initialBounds.name) { this._highlightNode = node; this._highlightPropertyInitialValue = initialBounds; this.$viewport.attr('title', (node.properties[i].options.description? node.properties[i].options.description + '\\n': '') + 'Click to change the initial value of this property.\\nValue = &quot;' + node.properties[i].initialValue + '&quot;\\n'); this.$viewport.addClass('wcClickable'); break; } } } } // Custom viewport area. if (node._meta.bounds.viewportBounds) { var pos = { x: (mouse.x - this._viewportCamera.x) / this._viewportCamera.z - (node.pos.x + node._meta.bounds.viewportBounds.left), y: (mouse.y - this._viewportCamera.y) / this._viewportCamera.z - (node.pos.y + node._meta.bounds.viewportBounds.top), }; if (this.__inRect(this._mouse, node._meta.bounds.viewportBounds, node.pos, this._viewportCamera)) { this._highlightNode = node; this._highlightViewport = true; this.$viewport.addClass('wcClickable'); if (!wasOverViewport) { node.onViewportMouseEnter(event, pos, this._options.readOnly); } node.onViewportMouseMove(event, pos, this._options.readOnly); } else if (wasOverViewport) { node.onViewportMouseLeave(event, pos, this._options.readOnly); } } } } }, /** * Handle mouse press events over the viewport canvas. * @function wcPlayEditor#__onViewportMouseDown * @private * @param {Object} event - The mouse event. * @param {Object} elem - The target element. */ __onViewportMouseDown: function(event, elem) { this._mouse = this.__mouse(event, this.$viewport.offset()); if (this._mouse.which === 3) { return; } this._mouseMoved = false; // Control+drag or middle+drag to box select. if (event.ctrlKey || this._mouse.which === 2) { this._highlightRect = { top: (this._mouse.y - this._viewportCamera.y) / this._viewportCamera.z, left: (this._mouse.x - this._viewportCamera.x) / this._viewportCamera.z, oy: (this._mouse.y - this._viewportCamera.y) / this._viewportCamera.z, ox: (this._mouse.x - this._viewportCamera.x) / this._viewportCamera.z, x: 0, y: 0, width: 0, height: 0, }; return; } var hasTarget = false; var node = this.__findNodeAtPos(this._mouse, this._viewportCamera); if (node) { // Entry links. if (!hasTarget &amp;&amp; !this._options.readOnly) { for (var i = 0; i &lt; node._meta.bounds.entryBounds.length; ++i) { if (this.__inRect(this._mouse, node._meta.bounds.entryBounds[i].rect, node.pos, this._viewportCamera)) { hasTarget = true; // Alt click to disconnect all chains from this link. if (event.altKey) { this.onDisconnectEntryChains(node, node._meta.bounds.entryBounds[i].name); break; } this._selectedNode = node; this._selectedNodes = [node]; this._selectedEntryLink = node._meta.bounds.entryBounds[i]; this.$viewport.addClass('wcGrabbing'); break; } } } // Exit links. if (!hasTarget &amp;&amp; !this._options.readOnly) { for (var i = 0; i &lt; node._meta.bounds.exitBounds.length; ++i) { if (this.__inRect(this._mouse, node._meta.bounds.exitBounds[i].rect, node.pos, this._viewportCamera)) { hasTarget = true; // Alt click to disconnect all chains from this link. if (event.altKey) { this.onDisconnectExitChains(node, node._meta.bounds.exitBounds[i].name); break; } // Shift click to manually fire this exit chain. else if (event.shiftKey) { node.activateExit(node._meta.bounds.exitBounds[i].name); break; } this._selectedNode = node; this._selectedNodes = [node]; this._selectedExitLink = node._meta.bounds.exitBounds[i]; this.$viewport.addClass('wcGrabbing'); break; } } } // Input links. if (!hasTarget &amp;&amp; !this._options.readOnly) { for (var i = 0; i &lt; node._meta.bounds.inputBounds.length; ++i) { if (this.__inRect(this._mouse, node._meta.bounds.inputBounds[i].rect, node.pos, this._viewportCamera)) { hasTarget = true; // Alt click to disconnect all chains from this link. if (event.altKey) { this.onDisconnectInputChains(node, node._meta.bounds.inputBounds[i].name); break; } this._selectedNode = node; this._selectedNodes = [node]; this._selectedInputLink = node._meta.bounds.inputBounds[i]; this.$viewport.addClass('wcGrabbing'); break; } } } // Output links. if (!hasTarget &amp;&amp; !this._options.readOnly) { for (var i = 0; i &lt; node._meta.bounds.outputBounds.length; ++i) { if (this.__inRect(this._mouse, node._meta.bounds.outputBounds[i].rect, node.pos, this._viewportCamera)) { hasTarget = true; // Alt click to disconnect all chains from this link. if (event.altKey) { this.onDisconnectOutputChains(node, node._meta.bounds.outputBounds[i].name); break; } this._selectedNode = node; this._selectedNodes = [node]; this._selectedOutputLink = node._meta.bounds.outputBounds[i]; this.$viewport.addClass('wcGrabbing'); break; } } } // Custom viewport area. if (!hasTarget &amp;&amp; node._meta.bounds.viewportBounds) { var pos = { x: (this._mouse.x - this._viewportCamera.x) / this._viewportCamera.z - node._meta.bounds.viewportBounds.left, y: (this._mouse.y - this._viewportCamera.y) / this._viewportCamera.z - node._meta.bounds.viewportBounds.top, }; if (this.__inRect(this._mouse, node._meta.bounds.viewportBounds, node.pos, this._viewportCamera)) { this._selectedNode = node; this._selectedNodes = [node]; if (node.onViewportMouseDown(event, pos, this._options.readOnly)) { hasTarget = true; } } } // Center area. if (!hasTarget &amp;&amp; this.__inRect(this._mouse, node._meta.bounds.farRect, node.pos, this._viewportCamera)) { hasTarget = true; if (!this._selectedNodes.length || this._selectedNodes.indexOf(node) === -1) { this._selectedNode = node; this._selectedNodes = [node]; } this._viewportMovingNode = !this._options.readOnly; this._selectedNodeOrigins = []; for (var i = 0; i &lt; this._selectedNodes.length; ++i) { var myNode = this._selectedNodes[i]; this._selectedNodeOrigins.push({ x: myNode.pos.x, y: myNode.pos.y, }); } } } // Click outside of a node begins the canvas drag process. if (!hasTarget) { this._viewportMoving = true; this._viewportMoved = false; } }, /** * Handle mouse release events over the viewport canvas. * @function wcPlayEditor#__onViewportMouseUp * @private * @param {Object} event - The mouse event. * @param {Object} elem - The target element. */ __onViewportMouseUp: function(event, elem) { this.$viewport.removeClass('wcGrabbing'); if (this._draggingNodeData &amp;&amp; event.type === 'mouseup') { // Create an instance of the node and add it to the script. var screenOffset = this.$container.offset(); var mouse = this.__mouse(event, this.$viewport.offset(), this._viewportCamera); var newNode = new window[this._draggingNodeData.node.className](this._parent, {x: 0, y: 0}); var data = this._draggingNodeData.node.export(); data.id = newNode.id; data.pos.x = (mouse.x / this._viewportCamera.z) + (this._draggingNodeData.$canvas.width()/2 + this._draggingNodeData.offset.x + screenOffset.left); data.pos.y = (mouse.y / this._viewportCamera.z) + (this._draggingNodeData.offset.y + 5 + screenOffset.top); if (!newNode.chain.entry.length) { data.y += this._drawStyle.links.length; } newNode.import(data, []); this.__onCreateNode(newNode); this._selectedNode = newNode; this._selectedNodes = [newNode]; this.__updateNode(newNode, 0, this._viewportContext); this.__drawNode(newNode, this._viewportContext); this._draggingNodeData.$canvas.remove(); this._draggingNodeData.$canvas = null; this._draggingNodeData = null; this.$palette.removeClass('wcMoving'); this.$viewport.removeClass('wcMoving'); } if (this._highlightRect &amp;&amp; this._parent) { this._highlightRect = null; return; } // Finished moving a node. if (this._selectedNodes.length &amp;&amp; this._selectedNodeOrigins.length) { this._undoManager &amp;&amp; this._undoManager.beginGroup('Node(s) moved.'); for (var i = 0; i &lt; this._selectedNodes.length; ++i) { var node = this._selectedNodes[i]; if (node.pos.x !== this._selectedNodeOrigins[i].x || node.pos.y !== this._selectedNodeOrigins[i].y) { node.onMoved({x: this._selectedNodeOrigins[i].x, y: this._selectedNodeOrigins[i].y}, {x: node.pos.x, y: node.pos.y}); this._undoManager &amp;&amp; this._undoManager.addEvent('Moved Node &quot;' + node.category + '.' + node.type + '&quot;', { id: node.id, start: { x: this._selectedNodeOrigins[i].x, y: this._selectedNodeOrigins[i].y, }, end: { x: node.pos.x, y: node.pos.y, }, engine: this._engine, }, // Undo function() { var myNode = this.engine.nodeById(this.id); var pos = myNode.onMoving({x: this.end.x, y: this.end.y}, {x: this.start.x, y: this.start.y}) || this.start; myNode.pos.x = this.start.x; myNode.pos.y = this.start.y; myNode.onMoved({x: this.end.x, y: this.end.y}, {x: pos.x, y: pos.y}); }, // Redo function() { var myNode = this.engine.nodeById(this.id); var pos = myNode.onMoving({x: this.start.x, y: this.start.y}, {x: this.end.x, y: this.end.y}) || this.end; myNode.pos.x = this.end.x; myNode.pos.y = this.end.y; myNode.onMoved({x: this.start.x, y: this.start.y}, {x: pos.x, y: pos.y}); }); } } this._undoManager &amp;&amp; this._undoManager.endGroup(); this._selectedNodeOrigins = []; } // Check for link connections. if (this._selectedNode &amp;&amp; this._selectedEntryLink &amp;&amp; this._highlightNode &amp;&amp; this._highlightExitLink) { if (this._selectedNode.connectEntry(this._selectedEntryLink.name, this._highlightNode, this._highlightExitLink.name) === wcNode.CONNECT_RESULT.ALREADY_CONNECTED) { this._selectedNode.disconnectEntry(this._selectedEntryLink.name, this._highlightNode, this._highlightExitLink.name); this._undoManager &amp;&amp; this._undoManager.addEvent('Disconnected Entry Link &quot;' + this._selectedNode.category + '.' + this._selectedNode.type + '.' + this._selectedEntryLink.name + '&quot; to Exit Link &quot;' + this._highlightNode.category + '.' + this._highlightNode.type + '.' + this._highlightExitLink.name + '&quot;', { id: this._selectedNode.id, name: this._selectedEntryLink.name, targetId: this._highlightNode.id, targetName: this._highlightExitLink.name, engine: this._engine, }, // Undo function() { var myNode = this.engine.nodeById(this.id); var targetNode = this.engine.nodeById(this.targetId); myNode.connectEntry(this.name, targetNode, this.targetName); }, // Redo function() { var myNode = this.engine.nodeById(this.id); var targetNode = this.engine.nodeById(this.targetId); myNode.disconnectEntry(this.name, targetNode, this.targetName); }); } else { this._undoManager &amp;&amp; this._undoManager.addEvent('Connected Entry Link &quot;' + this._selectedNode.category + '.' + this._selectedNode.type + '.' + this._selectedEntryLink.name + '&quot; to Exit Link &quot;' + this._highlightNode.category + '.' + this._highlightNode.type + '.' + this._highlightExitLink.name + '&quot;', { id: this._selectedNode.id, name: this._selectedEntryLink.name, targetId: this._highlightNode.id, targetName: this._highlightExitLink.name, engine: this._engine, }, // Undo function() { var myNode = this.engine.nodeById(this.id); var targetNode = this.engine.nodeById(this.targetId); myNode.disconnectEntry(this.name, targetNode, this.targetName); }, // Redo function() { var myNode = this.engine.nodeById(this.id); var targetNode = this.engine.nodeById(this.targetId); myNode.connectEntry(this.name, targetNode, this.targetName); }); } } if (this._selectedNode &amp;&amp; this._selectedExitLink &amp;&amp; this._highlightNode &amp;&amp; this._highlightEntryLink) { if (this._selectedNode.connectExit(this._selectedExitLink.name, this._highlightNode, this._highlightEntryLink.name) === wcNode.CONNECT_RESULT.ALREADY_CONNECTED) { this._selectedNode.disconnectExit(this._selectedExitLink.name, this._highlightNode, this._highlightEntryLink.name); this._undoManager &amp;&amp; this._undoManager.addEvent('Disconnected Exit Link &quot;' + this._selectedNode.category + '.' + this._selectedNode.type + '.' + this._selectedExitLink.name + '&quot; to Entry Link &quot;' + this._highlightNode.category + '.' + this._highlightNode.type + '.' + this._highlightEntryLink.name + '&quot;', { id: this._selectedNode.id, name: this._selectedExitLink.name, targetId: this._highlightNode.id, targetName: this._highlightEntryLink.name, engine: this._engine, }, // Undo function() { var myNode = this.engine.nodeById(this.id); var targetNode = this.engine.nodeById(this.targetId); myNode.connectExit(this.name, targetNode, this.targetName); }, // Redo function() { var myNode = this.engine.nodeById(this.id); var targetNode = this.engine.nodeById(this.targetId); myNode.disconnectExit(this.name, targetNode, this.targetName); }); } else { this._undoManager &amp;&amp; this._undoManager.addEvent('Connected Exit Link &quot;' + this._selectedNode.category + '.' + this._selectedNode.type + '.' + this._selectedExitLink.name + '&quot; to Entry Link &quot;' + this._highlightNode.category + '.' + this._highlightNode.type + '.' + this._highlightEntryLink.name + '&quot;', { id: this._selectedNode.id, name: this._selectedExitLink.name, targetId: this._highlightNode.id, targetName: this._highlightEntryLink.name, engine: this._engine, }, // Undo function() { var myNode = this.engine.nodeById(this.id); var targetNode = this.engine.nodeById(this.targetId); myNode.disconnectExit(this.name, targetNode, this.targetName); }, // Redo function() { var myNode = this.engine.nodeById(this.id); var targetNode = this.engine.nodeById(this.targetId); myNode.connectExit(this.name, targetNode, this.targetName); }); } } if (this._selectedNode &amp;&amp; this._selectedInputLink &amp;&amp; this._highlightNode &amp;&amp; this._highlightOutputLink) { if (this._selectedNode.connectInput(this._selectedInputLink.name, this._highlightNode, this._highlightOutputLink.name) === wcNode.CONNECT_RESULT.ALREADY_CONNECTED) { this._selectedNode.disconnectInput(this._selectedInputLink.name, this._highlightNode, this._highlightOutputLink.name); this._undoManager &amp;&amp; this._undoManager.addEvent('Disconnected Property Input Link &quot;' + this._selectedNode.category + '.' + this._selectedNode.type + '.' + this._selectedInputLink.name + '&quot; to Property Output Link &quot;' + this._highlightNode.category + '.' + this._highlightNode.type + '.' + this._highlightOutputLink.name + '&quot;', { id: this._selectedNode.id, name: this._selectedInputLink.name, targetId: this._highlightNode.id, targetName: this._highlightOutputLink.name, engine: this._engine, }, // Undo function() { var myNode = this.engine.nodeById(this.id); var targetNode = this.engine.nodeById(this.targetId); myNode.connectInput(this.name, targetNode, this.targetName); }, // Redo function() { var myNode = this.engine.nodeById(this.id); var targetNode = this.engine.nodeById(this.targetId); myNode.disconnectInput(this.name, targetNode, this.targetName); }); } else { this._undoManager &amp;&amp; this._undoManager.addEvent('Connected Property Input Link &quot;' + this._selectedNode.category + '.' + this._selectedNode.type + '.' + this._selectedInputLink.name + '&quot; to Property Output Link &quot;' + this._highlightNode.category + '.' + this._highlightNode.type + '.' + this._highlightOutputLink.name + '&quot;', { id: this._selectedNode.id, name: this._selectedInputLink.name, targetId: this._highlightNode.id, targetName: this._highlightOutputLink.name, engine: this._engine, }, // Undo function() { var myNode = this.engine.nodeById(this.id); var targetNode = this.engine.nodeById(this.targetId); myNode.disconnectInput(this.name, targetNode, this.targetName); }, // Redo function() { var myNode = this.engine.nodeById(this.id); var targetNode = this.engine.nodeById(this.targetId); myNode.connectInput(this.name, targetNode, this.targetName); }); } } if (this._selectedNode &amp;&amp; this._selectedOutputLink &amp;&amp; this._highlightNode &amp;&amp; this._highlightInputLink) { if (this._selectedNode.connectOutput(this._selectedOutputLink.name, this._highlightNode, this._highlightInputLink.name) === wcNode.CONNECT_RESULT.ALREADY_CONNECTED) { this._selectedNode.disconnectOutput(this._selectedOutputLink.name, this._highlightNode, this._highlightInputLink.name); this._undoManager &amp;&amp; this._undoManager.addEvent('Disconnected Property Output Link &quot;' + this._selectedNode.category + '.' + this._selectedNode.type + '.' + this._selectedOutputLink.name + '&quot; to Property Input Link &quot;' + this._highlightNode.category + '.' + this._highlightNode.type + '.' + this._highlightInputLink.name + '&quot;', { id: this._selectedNode.id, name: this._selectedOutputLink.name, targetId: this._highlightNode.id, targetName: this._highlightInputLink.name, engine: this._engine, }, // Undo function() { var myNode = this.engine.nodeById(this.id); var targetNode = this.engine.nodeById(this.targetId); myNode.connectOutput(this.name, targetNode, this.targetName); }, // Redo function() { var myNode = this.engine.nodeById(this.id); var targetNode = this.engine.nodeById(this.targetId); myNode.disconnectOutput(this.name, targetNode, this.targetName); }); } else { this._undoManager &amp;&amp; this._undoManager.addEvent('Connected Property Output Link &quot;' + this._selectedNode.category + '.' + this._selectedNode.type + '.' + this._selectedOutputLink.name + '&quot; to Property Input Link &quot;' + this._highlightNode.category + '.' + this._highlightNode.type + '.' + this._highlightInputLink.name + '&quot;', { id: this._selectedNode.id, name: this._selectedOutputLink.name, targetId: this._highlightNode.id, targetName: this._highlightInputLink.name, engine: this._engine, }, // Undo function() { var myNode = this.engine.nodeById(this.id); var targetNode = this.engine.nodeById(this.targetId); myNode.disconnectOutput(this.name, targetNode, this.targetName); }, // Redo function() { var myNode = this.engine.nodeById(this.id); var targetNode = this.engine.nodeById(this.targetId); myNode.connectOutput(this.name, targetNode, this.targetName); }); } } // Custom viewport area. if (this._selectedNode &amp;&amp; this._highlightViewport) { var mouse = this.__mouse(event, this.$viewport.offset()); var pos = { x: (mouse.x - this._viewportCamera.x) / this._viewportCamera.z - this._selectedNode._meta.bounds.viewportBounds.left, y: (mouse.y - this._viewportCamera.y) / this._viewportCamera.z - this._selectedNode._meta.bounds.viewportBounds.top, }; this._selectedNode.onViewportMouseUp(event, pos, this._options.readOnly); } this._selectedEntryLink = false; this._selectedExitLink = false; this._selectedInputLink = false; this._selectedOutputLink = false; this._viewportMovingNode = false; if (this._viewportMoving) { this._viewportMoving = false; if (!this._viewportMoved) { this._selectedNode = null; this._selectedNodes = []; } else { this._viewportMoved = false; this.$viewport.removeClass('wcMoving'); } } }, /** * Handle mouse entering the viewport canvas. * @function wcPlayEditor#__onViewportMouseEnter * @private * @param {Object} event - The mouse event. * @param {Object} elem - The target element. */ __onViewportMouseEnter: function(event, elem) { this._mouseInViewport = true; }, /** * Handle mouse leaving the viewport canvas. * @function wcPlayEditor#__onViewportMouseLeave * @private * @param {Object} event - The mouse event. * @param {Object} elem - The target element. */ __onViewportMouseLeave: function(event, elem) { this._mouseInViewport = false; this.__handleAutoScroll(false); this.__onViewportMouseUp(event, elem); }, /** * Handle mouse click events over the viewport canvas. * @function wcPlayEditor#__onViewportMouseDown * @private * @param {Object} event - The mouse event. * @param {Object} elem - The target element. */ __onViewportMouseClick: function(event, elem) { if (!this._mouseMoved) { if (this._highlightCrumb &gt; -1) { if (this._crumbBounds[this._highlightCrumb].parent !== this._parent) { var focusNode = this._crumbBounds[this._highlightCrumb+1].parent; this._parent = this._crumbBounds[this._highlightCrumb].parent; this._selectedNode = focusNode; this._selectedNodes = [focusNode]; this.focus(this._selectedNodes); } return; } this._mouse = this.__mouse(event, this.$viewport.offset()); var hasTarget = false; var node = this.__findNodeAtPos(this._mouse, this._viewportCamera); if (node) { // Debug Log button. if (this.__inRect(this._mouse, node._meta.bounds.debugLog, node.pos, this._viewportCamera)) { var state = !node._log; node.debugLog(state); this._undoManager &amp;&amp; this._undoManager.addEvent((state? 'Enabled': 'Disabled') + ' Debug Logging for Node &quot;' + node.category + '.' + node.type + '&quot;', { id: node.id, state: state, engine: this._engine, }, // Undo function() { var myNode = this.engine.nodeById(this.id); myNode.debugLog(!this.state); }, // Redo function() { var myNode = this.engine.nodeById(this.id); myNode.debugLog(this.state); }); } // Breakpoint button. if (this.__inRect(this._mouse, node._meta.bounds.breakpoint, node.pos, this._viewportCamera)) { var state = !node._break; node.debugBreak(state); this._undoManager &amp;&amp; this._undoManager.addEvent((state? 'Enabled': 'Disabled') + ' Breakpoint on Node &quot;' + node.category + '.' + node.type + '&quot;', { id: node.id, state: state, engine: this._engine, }, // Undo function() { var myNode = this.engine.nodeById(this.id); myNode.debugBreak(!this.state); }, // Redo function() { var myNode = this.engine.nodeById(this.id); myNode.debugBreak(this.state); }); } // Title label. if (this.__inRect(this._mouse, node._meta.bounds.titleBounds, node.pos, this._viewportCamera)) { this.__drawTitleEditor(node, node._meta.bounds.titleBounds); } // Details button. if (this.__inRect(this._mouse, node._meta.bounds.detailsBounds, node.pos, this._viewportCamera)) { this.__drawDetailsPopup(node); } // Property values. var propBounds; for (var i = 0; i &lt; node._meta.bounds.valueBounds.length; ++i) { if (this.__inRect(this._mouse, node._meta.bounds.valueBounds[i].rect, node.pos, this._viewportCamera)) { propBounds = node._meta.bounds.valueBounds[i]; break; } } if (propBounds) { for (var i = 0; i &lt; node.properties.length; ++i) { if (node.properties[i].name === propBounds.name) { this.__drawPropertyEditor(node, node.properties[i], propBounds); break; } } } var propInitialBounds; for (var i = 0; i &lt; node._meta.bounds.initialBounds.length; ++i) { if (this.__inRect(this._mouse, node._meta.bounds.initialBounds[i].rect, node.pos, this._viewportCamera)) { propInitialBounds = node._meta.bounds.initialBounds[i]; break; } } if (propInitialBounds) { for (var i = 0; i &lt; node.properties.length; ++i) { if (node.properties[i].name === propInitialBounds.name) { this.__drawPropertyEditor(node, node.properties[i], propInitialBounds, true); break; } } } // Custom viewport area. if (node._meta.bounds.viewportBounds) { var pos = { x: (this._mouse.x - this._viewportCamera.x) / this._viewportCamera.z - node._meta.bounds.viewportBounds.left, y: (this._mouse.y - this._viewportCamera.y) / this._viewportCamera.z - node._meta.bounds.viewportBounds.top, }; if (this.__inRect(this._mouse, node._meta.bounds.viewportBounds, node.pos, this._viewportCamera)) { node.onViewportMouseClick(event, pos, this._options.readOnly); } } } } }, /** * Handle mouse double click events over the viewport canvas. * @function wcPlayEditor#__onViewportMouseDoubleClick * @private * @param {Object} event - The mouse event. * @param {Object} elem - The target element. */ __onViewportMouseDoubleClick: function(event, elem) { this._mouse = this.__mouse(event, this.$viewport.offset()); var hasTarget = false; var node = this.__findNodeAtPos(this._mouse, this._viewportCamera); if (node) { // Debug Log button. if (this.__inRect(this._mouse, node._meta.bounds.debugLog, node.pos, this._viewportCamera)) { hasTarget = true; } // Breakpoint button. if (this.__inRect(this._mouse, node._meta.bounds.breakpoint, node.pos, this._viewportCamera)) { hasTarget = true; } // Property values. for (var i = 0; i &lt; node._meta.bounds.valueBounds.length; ++i) { if (this.__inRect(this._mouse, node._meta.bounds.valueBounds[i].rect, node.pos, this._viewportCamera)) { hasTarget = true; break; } } // Entry links. if (!this._options.readOnly &amp;&amp; !hasTarget) { for (var i = 0; i &lt; node._meta.bounds.entryBounds.length; ++i) { if (this.__inRect(this._mouse, node._meta.bounds.entryBounds[i].rect, node.pos, this._viewportCamera)) { hasTarget = true; // Double click to manually fire this entry chain. node.activateEntry(node._meta.bounds.entryBounds[i].name); break; } } } // Exit links. if (!this._options.readOnly &amp;&amp; !hasTarget) { for (var i = 0; i &lt; node._meta.bounds.exitBounds.length; ++i) { if (this.__inRect(this._mouse, node._meta.bounds.exitBounds[i].rect, node.pos, this._viewportCamera)) { hasTarget = true; // Double click to manually fire this exit chain. node.activateExit(node._meta.bounds.exitBounds[i].name); break; } } } // Output links. if (!this._options.readOnly &amp;&amp; !hasTarget) { for (var i = 0; i &lt; node._meta.bounds.outputBounds.length; ++i) { if (this.__inRect(this._mouse, node._meta.bounds.outputBounds[i].rect, node.pos, this._viewportCamera)) { hasTarget = true; // Double click to manually fire this output chain. node.property(node._meta.bounds.outputBounds[i].name, node.property(node._meta.bounds.outputBounds[i].name), true); break; } } } // Custom viewport area. if (!hasTarget &amp;&amp; node._meta.bounds.viewportBounds) { var pos = { x: (this._mouse.x - this._viewportCamera.x) / this._viewportCamera.z - node._meta.bounds.viewportBounds.left, y: (this._mouse.y - this._viewportCamera.y) / this._viewportCamera.z - node._meta.bounds.viewportBounds.top, }; if (this.__inRect(this._mouse, node._meta.bounds.viewportBounds, node.pos, this._viewportCamera)) { hasTarget = node.onViewportMouseDoubleClick(event, pos, this._options.readOnly); } } // Center area. if (!hasTarget &amp;&amp; this.__inRect(this._mouse, node._meta.bounds.inner, node.pos, this._viewportCamera)) { hasTarget = true; if (node.instanceOf('wcNodeCompositeScript')) { // Step into composite script nodes. this._parent = node; this._selectedNode = null; this._selectedNodes = []; this.center(); } else if (node.instanceOf('wcNodeComposite') &amp;&amp; this._parent.instanceOf('wcNodeCompositeScript')) { // Step out if double clicking on an external link node. var focusNode = this._parent; this._parent = this._parent._parent; this._selectedNode = focusNode; this._selectedNodes = [focusNode]; this.focus(this._selectedNodes); } else if (node.instanceOf('wcNodeEntry')) { node.onActivated(); } } } }, __onViewportMouseWheel: function(event, elem) { var oldZoom = this._viewportCamera.z; // Custom viewport area. if (this._highlightNode &amp;&amp; this._highlightNode._meta.bounds.viewportBounds) { var pos = { x: (this._mouse.x - this._viewportCamera.x) / this._viewportCamera.z - this._highlightNode._meta.bounds.viewportBounds.left, y: (this._mouse.y - this._viewportCamera.y) / this._viewportCamera.z - this._highlightNode._meta.bounds.viewportBounds.top, }; if (this.__inRect(this._mouse, this._highlightNode._meta.bounds.viewportBounds, this._highlightNode.pos, this._viewportCamera) &amp;&amp; this._highlightNode.onViewportMouseWheel(event, pos, (event.originalEvent.wheelDelta &gt; 0 || event.originalEvent.detail &lt; 0), this._options.readOnly)) { return; } } if (event.originalEvent.wheelDelta &gt; 0 || event.originalEvent.detail &lt; 0) { // scroll up to zoom in. this._viewportCamera.z = Math.min(this._viewportCamera.z * 1.25, 5); } else { // scroll down to zoom out. this._viewportCamera.z = Math.max(this._viewportCamera.z * 0.75, 0.1); } this._viewportCamera.x = (this._viewportCamera.x - this._mouse.x) / (oldZoom / this._viewportCamera.z) + this._mouse.x; this._viewportCamera.y = (this._viewportCamera.y - this._mouse.y) / (oldZoom / this._viewportCamera.z) + this._mouse.y; }, /** * Does a bounding collision test to find any nodes at a given position. * @function wcPlayEditor#__findNodeAtPos * @private * @param {wcPlay~Coordinates} pos - The position. * @param {wcPlay~Coordinates} camera - The position of the camera. * @param {wcNode[]} [nodes] - If supplied, will only search this list of nodes, otherwise will search all nodes in the viewport. * @returns {wcNode|null} - A node at the given position, or null if none was found. */ __findNodeAtPos: function(pos, camera, nodes) { if (this._parent) { var self = this; function __test(nodes) { // Iterate backwards so we always test the nodes that are drawn on top first. for (var i = nodes.length-1; i &gt;= 0; --i) { if (nodes[i]._meta.bounds &amp;&amp; self.__inRect(pos, nodes[i]._meta.bounds.rect, nodes[i].pos, camera)) { return nodes[i]; } } return null; }; if (nodes === undefined) { return __test(this._parent._storageNodes) || __test(this._parent._compositeNodes) || __test(this._parent._processNodes) || __test(this._parent._entryNodes); } else { return __test(nodes); } } return null; }, /** * Finds the category area of the palette at a given position. * @function wcPlayEditor#__findCategoryAreaAtPos * @private * @param {wcPlay~Coordinates} pos - The position. * @returns {Object|null} - The category data found, or null if not found. */ __findCategoryAreaAtPos: function(pos) { for (var cat in this._nodeLibrary) { for (var type in this._nodeLibrary[cat]) { // Ignore types that are not visible. if (!this.$typeButton[this.__typeIndex(type)].hasClass('wcToggled')) continue; var typeData = this._nodeLibrary[cat][type]; // Ignore categories that are not visible. if (typeData.$button.hasClass('wcToggled')) continue; var rect = typeData.$canvas.offset(); rect.width = typeData.$canvas.width(); rect.height = typeData.$canvas.height(); if (this.__inRect(pos, rect)) { return typeData; } } } }, };  Search results Close "},"editor.jsdoc.html":{"id":"editor.jsdoc.html","title":"Source: editor.jsdoc","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Source: editor.jsdoc /** * Custom options available when constructing a new {@link wcPlay} instance. * @typedef {Object} wcPlayEditor~Options * @property {Boolean} [readOnly=false] - If true, the script will not be editable. * @property {Boolean} [playable=true] - Whether the script can be played using the live debugger. * @property {wcPlayEditor~CategoryOptions} [category] - Options that determine what categories appear in the palette. By default, all categories are visible. */ /** * Category display options. * @typedef {Object} wcPlayEditor~CategoryOptions * @property {String[]} items - A list of categories to show in the palette. * @property {Boolean} isBlacklist - If true, the items list will be treated as a blacklist of categories to hide. */ /** * The 2D bounds of a rectangle. * @typedef {Object} wcPlayEditor~Rect * @property {Number} top * @property {Number} left * @property {Number} width * @property {Number} height */ /** * Bounding information for links on a node. * @typedef {Object} wcPlayEditor~BoundingData * @property {wcPlayEditor~Rect} rect - The bounding rectangle. * @property {wcPlay~Coordinates} point - The anchor point where lines will attach to this link. * @property {String} name - The name of the bounded object. */ /** * Data associated with a drawn node. * @typedef {Object} wcPlayEditor~DrawNodeData * @property {wcNode} node - The node instance. * @property {wcPlayEditor~Rect} rect - Bounding rectangle of the node (not including links that stick out). * @property {wcPlayEditor~BoundingData[]} entryBounds - Bounding data of entry links. * @property {wcPlayEditor~BoundingData[]} exitBounds - Bounding data of exit links. * @property {wcPlayEditor~BoundingData[]} inputBounds - Bounding data of property input links. * @property {wcPlayEditor~BoundingData[]} outputBounds - Bounding data of property output links. * @property {wcPlayEditor~BoundingData[]} valueBounds - Bounding data of property value text. * @property {wcPlayEditor~BoundingData[]} initialBounds - Bounding data of property initial value text. */ /** * On click handler for menu and toolbar options. * @callback wcPlayEditor~OnMenuActivated * @param {Object} event - The mouse click event object. * @param {wcPlayEditor} editor - The instance of the editor invoking the menu option. * @param {wcPlay} engine - The instance of the script engine being viewed by the editor. */ /** * A callback that retrieves the icon class for a menu option. * @function wcPlayEditor~MenuIconFunc * @param {wcPlayEditor} editor - The instance of the editor invoking the menu option. * @param {wcPlay} engine - The instance of the script engine being viewed by the editor. */ /** * A callback that retrieves the description string for a menu option. * @function wcPlayEditor~MenuDescriptionFunc * @param {wcPlayEditor} editor - The instance of the editor invoking the menu option. * @param {wcPlay} engine - The instance of the script engine being viewed by the editor. */ /** * Custom options for a menu option. * @typedef {Object} wcPlayEditor~MenuOptions * @property {String|wcPlayEditor~MenuIconFunc} [icon] - A classname to apply as an icon for the option. If this is a function, it will be called during the update call and should return the icon class. * @property {String} [description|wcPlayEditor~MenuDescriptionFunc] - The description to show as a tooltip for this option. * @property {Number} [itemIndex] - An insertion index to insert the item within the menu category, default is to append to the end. * @property {Number} [categoryIndex] - If this creates a new category, it will be inserted at this index in the top level menu. * @property {Boolean} [toolbarIndex] - If supplied, creates a toolbar button for this option and inserts it in the tab bar at the specified index. -1 will append it to the end. * @property {String} [hotkeys] - A string that describes hotkeys for your control, the format is 'Ctrl+Z' or 'Alt+Shift+L,Shift+L' for multiple. * @property {Function} [condition] - A function to call during the update to determine if the menu option should be enabled or disabled. Return false to disable the option. * @param {wcPlayEditor~OnMenuActivated} onActivated - A handler to call when the option is activated. */  Search results Close "},"play.jsdoc.html":{"id":"play.jsdoc.html","title":"Source: play.jsdoc","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Source: play.jsdoc /** * Custom options available when constructing a new {@link wcPlay} instance. * @typedef {Object} wcPlay~Options * @property {Boolean} [silent=false] - If true, will disable debug logging on all nodes. * @property {Number} [updateRate=25] - The time, in milliseconds, between node updates. * @property {Number} [updateLimit=100] - The maximum number of nodes allowed to be updated in a single update. This minimizes the potential for script lock. * @property {Boolean} [debugging=true] - If true, debug break toggles on individual nodes will trigger the script to pause. Turn this off during production. */ /** * A 2D positional coordinate. * @typedef {Object} wcPlay~Coordinates * @property {Number} x - The horizontal coordinate. * @property {Number} y - The vertical coordinate. */  Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Classes Classes wcNode wcNodeComposite wcNodeEntry wcNodeEntryCallRemote wcNodeEntryRemote wcNodeEntryStart wcNodeEntryUpdate wcNodeProcess wcNodeProcessAJAX wcNodeProcessAlert wcNodeProcessConsoleLog wcNodeProcessDelay wcNodeProcessOperation wcNodeProcessStrCat wcNodeStorage wcNodeStorageGlobal wcNodeStorageNumber wcNodeStorageString wcNodeStorageToggle wcPlay wcPlayEditor  Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Tutorials Classes wcNode wcNodeComposite wcNodeEntry wcNodeEntryCallRemote wcNodeEntryRemote wcNodeEntryStart wcNodeEntryUpdate wcNodeProcess wcNodeProcessAJAX wcNodeProcessAlert wcNodeProcessConsoleLog wcNodeProcessDelay wcNodeProcessOperation wcNodeProcessStrCat wcNodeStorage wcNodeStorageGlobal wcNodeStorageNumber wcNodeStorageString wcNodeStorageToggle wcPlay wcPlayEditor  Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Welcome!Welcome to WebCabin.org! Your developers cabin, on the web! Here at Web Cabin, we sincerely believe that anyone with the proper tools can become a developer! The open source community provides us with a powerful network for sharing, inspiring, and revolutionizing the world! It is awfully daunting, viewing the long road ahead through our small cabin window, but all memorable journeys must have a beginning. Will you join us? What is wcPlay?wcPlay (Web Cabin Play) is a node based visual scripting tool for the web! Allow users to script their own content for your application in a way that does not require them to code! Users place nodes into their script and then visually connect them together. wcPlay also comes with a built in live debugger, so users can visually inspect and change their scripts while it is running! You can design your own scripting nodes for the user to use and even provide a server backend for user login and ajax nodes. http://play.webcabin.org Try the front page demo. http://play.api.webcabin.org View the API documentation. https://github.com/WebCabin/wcPlay View the source code. Features Extremely responsive design! Visual environment for users to build their scripts! Live visual debugging system! Design your own nodes. Comprehensive API Documentation! Compatible with all modern browsers that support HTML5 Canvas Completely free and open source! Getting StartedSee the Getting Started tutorial. Change LogVersion: (pre-release) 1.0.0 Dependencies JQuery Library version 1.11.1 http://jquery.com/ Font-Awesome http://fortawesome.github.io/Font-Awesome/ wcMenu https://github.com/WebCabin/wcMenu Optional Dependencies wcUndoManager https://github.com/WebCabin/wcUndoManager FileSaver.js https://github.com/eligrey/FileSaver.js/ LicenseMIT License  2015-2015 Jeff Houde (lochemage@webcabin.org) Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Suggestions/Comments?Please feel free to contact me, Jeff Houde (lochemage@webcabin.org), for any information or to give feedback and suggestions. Also, if you are a web programmer, and believe you can help, please let me know! Thank you  Search results Close "},"wcNode.html":{"id":"wcNode.html","title":"Class: wcNode","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Class: wcNode wcNode The foundation class for all nodes. When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init functions. new wcNode(parent, pos) Should be inherited and never constructed directly. Parameters: Name Type Description parent String The parent object of this node. pos wcPlay~Coordinates The position of this node in the visual editor. Source: nodes/node.js, line 3 Members &lt;static&gt; var CONNECT_RESULT The connection result. Type: String Properties: Name Type Default Description NOT_FOUND String not_found ALREADY_CONNECTED String already_connected SUCCESS String success Source: nodes/node.js, line 2109 &lt;static&gt; var LINK_TYPE The type of node link. Type: String Properties: Name Type Default Description ENTRY String entry EXIT String exit INPUT String input OUTPUT String output Source: nodes/node.js, line 2098 Methods function activateEntry(name, fromNode, fromName) -&gt; Boolean Activates an entry link and activates this node. Parameters: Name Type Description name String The name of the entry link to trigger. fromNode wcNode The node triggering the entry. fromName String The Exit link name. Source: nodes/node.js, line 1223 Returns: - Fails if the entry link does not exist. Type Boolean function activateExit(name) -&gt; Boolean Activates an exit link. Parameters: Name Type Description name String The name of the exit link to trigger. Source: nodes/node.js, line 1244 Returns: - Fails if the exit link does not exist. Type Boolean function activateProperty(name, value [, upstream]) Activates a property that is about to be changed by the output of another property. Parameters: Name Type Argument Description name String The name of the property. value Object The new value of the property. upstream Boolean &lt;optional&gt; If true, the activation was from a property in its output, and we are propagating in reverse. Source: nodes/node.js, line 1474 function ajax( [url] [, options]) -&gt; jqXHR Utility function for performing an AJAX request in a way that is compatible with live debugging in the editor tool. The success, error, and complete callback functions are changed so that the 'this' object is the node instance, or the custom context if you provided a context in your options. Parameters: Name Type Argument Description url String &lt;optional&gt; Option URL to send the request, if not supplied, it should be provided in the options parameter. options Object &lt;optional&gt; The options for the request, as described here: http://api.jquery.com/jquery.ajax/. Source: nodes/node.js, line 429 Returns: - The jQuery XHR object generated by the ajax request. Type jqXHR function beginThread(id) -&gt; Number If your node takes time to process, call this to begin a thread that will keep the node 'active' until you close the thread with wcNode#finishThread. This ensures that, even if a node is executed more than once at the same time, each 'thread' is kept track of individually. Note: This is not necessary if your node executes immediately without a timeout. Also Node: If using a setTimeout event, it is recommended that you use wcNode#setTimeout instead. Parameters: Name Type Description id Number | function The thread ID, generated by a call to setTimeout, setInterval, or a function to call when we want to force cancel the job. Source: nodes/node.js, line 481 Returns: - The id that was given wcNode#finishThread. Type Number Example onActivated: function(name) { this._super(name); // Always fire the 'out' link immediately. this.activateExit('out'); // Now set a timeout to wait for 'Milliseconds' amount of time. var self = this; var delay = this.property('milliseconds'); // Start a new thread that will keep the node alive until we are finished. var thread = this.beginThread(setTimeout(function() { // Once the time has completed, fire the 'Finished' link and finish our thread. self.activateExit('finished'); self.finishThread(thread); }, delay)); } function connectEntry(name, targetNode, targetName) -&gt; wcNode.CONNECT_RESULT Connects an entry link on this node to an exit link of another. Parameters: Name Type Description name String The name of the entry link on this node. targetNode wcNode The target node to link to. targetName String The name of the target node's exit link to link to. Source: nodes/node.js, line 815 Returns: - The result. Type wcNode.CONNECT_RESULT function connectExit(name, targetNode, targetName) -&gt; wcNode.CONNECT_RESULT Connects an exit link on this node to an entry link of another. Parameters: Name Type Description name String The name of the exit link on this node. targetNode wcNode The target node to link to. targetName String The name of the target node's entry link to link to. Source: nodes/node.js, line 881 Returns: - The result. Type wcNode.CONNECT_RESULT function connectInput(name, targetNode, targetName) -&gt; wcNode.CONNECT_RESULT Connects a property input link to a target property output link. Parameters: Name Type Description name String The name of the property being connected. targetNode wcNode The target node to connect with. targetName String The name of the property on the target node to connect with. Source: nodes/node.js, line 947 Returns: - The result. Type wcNode.CONNECT_RESULT function connectOutput(name, targetNode, targetName) -&gt; wcNode.CONNECT_RESULT Connects a property output link to a target property input link. Parameters: Name Type Description name String The name of the property being connected. targetNode wcNode The target node to connect with. targetName String The name of the property on the target node to connect with. Source: nodes/node.js, line 1013 Returns: - The result. Type wcNode.CONNECT_RESULT function createEntry(name [, description]) -&gt; Boolean Creates a new entry link on the node. Parameters: Name Type Argument Description name String The name of the entry link. description String &lt;optional&gt; An optional description to display as a tooltip for this link. Source: nodes/node.js, line 548 Returns: - Fails if the entry link name already exists. Type Boolean function createExit(name [, description]) -&gt; Boolean Creates a new exit link on the node. Parameters: Name Type Argument Description name String The name of the exit link. description String &lt;optional&gt; An optional description to display as a tooltip for this link. Source: nodes/node.js, line 578 Returns: - Fails if the exit link name already exists. Type Boolean function createProperty(name, type [, initialValue] [, options]) -&gt; Boolean Creates a new property. Parameters: Name Type Argument Description name String The name of the property. type wcPlay.PROPERTY The type of property. initialValue Object &lt;optional&gt; A initial value for this property when the script starts. options Object &lt;optional&gt; Additional options for this property, see wcPlay.PROPERTY. Source: nodes/node.js, line 607 Returns: - Fails if the property does not exist. Type Boolean function debugBreak( [enabled]) -&gt; Boolean Sets, or Gets this node's debug pause state. Parameters: Name Type Argument Description enabled Boolean &lt;optional&gt; If supplied, will assign a new debug pause state. Source: nodes/node.js, line 318 Returns: - The current debug pause state. Type Boolean function debugLog( [enabled]) -&gt; Boolean Sets, or Gets this node's debug log state. Parameters: Name Type Argument Description enabled Boolean &lt;optional&gt; If supplied, will assign a new debug log state. Source: nodes/node.js, line 303 Returns: - The current debug log state. Type Boolean function description( [description]) -&gt; String Gets, or Sets the description for this node. This is usually shown as a tooltip for the node within the editor tool. Parameters: Name Type Argument Description description String &lt;optional&gt; If supplied, will assign a new description for this node. Source: nodes/node.js, line 333 Returns: - The current description of this node. Type String function destroy() Destroys and removes the node. Source: nodes/node.js, line 67 function details( [details]) -&gt; String Gets, or Sets the very verbose description details for this node. This is usually shown as a popup dialog to further explain the user of the node. Parameters: Name Type Argument Description details String &lt;optional&gt; If supplied, will assign a new description details for this node. Source: nodes/node.js, line 347 Returns: - The current description details of this node. Type String function disconnectEntry(name [, targetNode] [, targetName]) -&gt; wcNode.CONNECT_RESULT Disconnects a chain, or all chains, from an entry link. Parameters: Name Type Argument Description name String The name of the entry link. targetNode wcNode &lt;optional&gt; If supplied, will only remove links to the specified target node. targetName String &lt;optional&gt; If supplied, will only remove links to the specified named exit links. Source: nodes/node.js, line 1079 Returns: Type wcNode.CONNECT_RESULT function disconnectExit(name [, targetNode] [, targetName]) -&gt; wcNode.CONNECT_RESULT Disconnects a chain, or all chains, from an exit link. Parameters: Name Type Argument Description name String The name of the exit link. targetNode wcNode &lt;optional&gt; If supplied, will only remove links to the specified target node. targetName String &lt;optional&gt; If supplied, will only remove links to the specified named entry links. Source: nodes/node.js, line 1115 Returns: Type wcNode.CONNECT_RESULT function disconnectInput(name [, targetNode] [, targetName]) -&gt; wcNode.CONNECT_RESULT Disconnects a chain, or all chains, from a property input. Parameters: Name Type Argument Description name String The name of the property. targetNode wcNode &lt;optional&gt; If supplied, will only remove links to the specified target node. targetName String &lt;optional&gt; If supplied, will only remove links to the specified named property output links. Source: nodes/node.js, line 1151 Returns: Type wcNode.CONNECT_RESULT function disconnectOutput(name [, targetNode] [, targetName]) -&gt; wcNode.CONNECT_RESULT Disconnects a chain, or all chains, from a property output. Parameters: Name Type Argument Description name String The name of the property. targetNode wcNode &lt;optional&gt; If supplied, will only remove links to the specified target node. targetName String &lt;optional&gt; If supplied, will only remove links to the specified named property input links. Source: nodes/node.js, line 1187 Returns: Type wcNode.CONNECT_RESULT function enabled( [enabled]) -&gt; Boolean Sets, or Gets this node's enabled state. Parameters: Name Type Argument Description enabled Boolean &lt;optional&gt; If supplied, will assign a new enabled state. Source: nodes/node.js, line 249 Returns: - The current enabled state. Type Boolean function engine() -&gt; wcPlay | null Retrieves the wcPlay engine that owns this node. Source: nodes/node.js, line 236 Returns: - Either the wcPlay engine, or null if it doesn't belong to one. Type wcPlay | null function export( [minimal]) -&gt; Object Exports information about this node as well as all connected chain data so it can be imported later. Parameters: Name Type Argument Description minimal Boolean &lt;optional&gt; If true, only the most important data should be exported, this means current values and redundant link connections are omitted. Source: nodes/node.js, line 201 Returns: - The exported data for this node. Type Object function extend(className, displayName, category, classDef) Inherits a new class from this node. Parameters: Name Type Description className String The class name for your node, this should be unique between all global class names. displayName String The display name of your node. category String The category to display your node in the editor palette. classDef Object An object that defines your class with all functions and variables. Source: nodes/node.js, line 58 function finishThread() Finishes a previously started thread from wcNode#beginThread. Note: If you do not properly finish a thread that was generated, your node will remain forever in its active state. Source: nodes/node.js, line 515 function import(data [, idMap]) Imports previously exported data to generate this node. Parameters: Name Type Argument Description data Object The data to import. idMap Array.&lt;Number&gt; &lt;optional&gt; If supplied, identifies a mapping of old ID's to new ID's, any not found in this list will be unchanged. Source: nodes/node.js, line 136 function initialProperty(name [, value] [, forceOrSilent] [, forceUpstream]) -&gt; Object | undefined Gets, or Sets the initial value of a property. Parameters: Name Type Argument Description name String The name of the property. value Object &lt;optional&gt; If supplied, will assign a new default value to the property. forceOrSilent Boolean &lt;optional&gt; If supplied, true will force the change event to be sent to all chained properties even if this value didn't change while false will force the change to not be chained. forceUpstream Boolean &lt;optional&gt; Contrary to normal operation, if this is true then the property change will be sent backwards, from this property's input link to any outputs connected to it. Source: nodes/node.js, line 1415 Returns: - The default value of the property, or undefined if not found. Type Object | undefined function isBroken() -&gt; Boolean Retrieves whether the node has been broken via breakpoint in the debugger tool. Source: nodes/node.js, line 294 Returns: Type Boolean function listEntryChains( [name] [, ignoreNodes]) -&gt; Array.&lt;wcNode~ChainData&gt; Retrieves a list of all chains connected to an entry link on this node. Parameters: Name Type Argument Description name String &lt;optional&gt; The entry link, if omitted, all link chains are retrieved. ignoreNodes Array.&lt;wcNode&gt; &lt;optional&gt; If supplied, will ignore all chains connected to a node in this list. Source: nodes/node.js, line 1498 Returns: - A list of all chains connected to this link, if the link was not found, an empty list is returned. Type Array.&lt;wcNode~ChainData&gt; function listExitChains( [name] [, ignoreNodes]) -&gt; Array.&lt;wcNode~ChainData&gt; Retrieves a list of all chains connected to an exit link on this node. Parameters: Name Type Argument Description name String &lt;optional&gt; The exit link, if omitted, all link chains are retrieved. ignoreNodes Array.&lt;wcNode&gt; &lt;optional&gt; If supplied, will ignore all chains connected to a node in this list. Source: nodes/node.js, line 1526 Returns: - A list of all chains connected to this link, if the link was not found, an empty list is returned. Type Array.&lt;wcNode~ChainData&gt; function listInputChains( [name] [, ignoreNodes]) -&gt; Array.&lt;wcNode~ChainData&gt; Retrieves a list of all chains connected to a property input link on this node. Parameters: Name Type Argument Description name String &lt;optional&gt; The property input link, if omitted, all link chains are retrieved. ignoreNodes Array.&lt;wcNode&gt; &lt;optional&gt; If supplied, will ignore all chains connected to a node in this list. Source: nodes/node.js, line 1554 Returns: - A list of all chains connected to this link, if the link was not found, an empty list is returned. Type Array.&lt;wcNode~ChainData&gt; function listOutputChains( [name] [, ignoreNodes]) -&gt; Array.&lt;wcNode~ChainData&gt; Retrieves a list of all chains connected to a property output link on this node. Parameters: Name Type Argument Description name String &lt;optional&gt; The property output link, if omitted, all link chains are retrieved. ignoreNodes Array.&lt;wcNode&gt; &lt;optional&gt; If supplied, will ignore all chains connected to a node in this list. Source: nodes/node.js, line 1582 Returns: - A list of all chains connected to this link, if the link was not found, an empty list is returned. Type Array.&lt;wcNode~ChainData&gt; function listProperties( [minimal]) -&gt; Array.&lt;wcNode~PropertyData&gt; Retrieves a list of all properties and their values for this node. Parameters: Name Type Argument Description minimal Boolean &lt;optional&gt; If true, only the minimal data is listed, this means current values will be omitted. Source: nodes/node.js, line 1610 Returns: - A list of all property data. Type Array.&lt;wcNode~PropertyData&gt; function onActivated(name) Event that is called when an entry link has been activated. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description name String The name of the entry link triggered. Source: nodes/node.js, line 1838 function onConnect(isConnecting, name, type, targetNode, targetName, targetType) Event that is called when a connection has been made. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description isConnecting Boolean True if a connection is being made, false if it is a disconnection. name String The name of the link being connected to. type wcNode.LINK_TYPE The link's type. targetNode wcNode The target node being connected to. targetName String The link name on the target node being connected to. targetType wcNode.LINK_TYPE The target link's type. Source: nodes/node.js, line 1783 function onDestroyed() Event that is called after the node has been destroyed. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Source: nodes/node.js, line 2084 function onDestroying() Event that is called when the node is about to be destroyed. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Source: nodes/node.js, line 2075 function onDraw() Event that is called when this node is about to be drawn. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Source: nodes/node.js, line 1829 function onExport(data [, minimal]) Event that is called when the node is being exported, after the export data has been configured. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Argument Description data Object The export data for this node. minimal Boolean &lt;optional&gt; If true, only the most important data should be exported, this means current values and redundant link connections are omitted. Source: nodes/node.js, line 2055 function onGlobalInitialPropertyChanged(name, oldValue, newValue) Event that is called when a global property initial value has changed. Overload this in inherited nodes. Note: Do not call 'this._super(..)' for this function, as the parent does not implement it. Parameters: Name Type Description name String The name of the global property. oldValue Object The old value of the global property. newValue Object The new value of the global property. Source: nodes/node.js, line 2021 function onGlobalPropertyChanged(name, oldValue, newValue) Event that is called when a global property value has changed. Overload this in inherited nodes. Note: Do not call 'this._super(..)' for this function, as the parent does not implement it. Parameters: Name Type Description name String The name of the global property. oldValue Object The old value of the global property. newValue Object The new value of the global property. Source: nodes/node.js, line 1988 function onGlobalPropertyRemoved(name) Event that is called when a global property has been removed. Overload this in inherited nodes. Note: Do not call 'this._super(..)' for this function, as the parent does not implement it. Parameters: Name Type Description name String The name of the global property. Source: nodes/node.js, line 2000 function onGlobalPropertyRenamed(oldName, newName) Event that is called when a global property has been renamed. Overload this in inherited nodes. Note: Do not call 'this._super(..)' for this function, as the parent does not implement it. Parameters: Name Type Description oldName String The old name of the global property. newName String The new name of the global property. Source: nodes/node.js, line 2010 function onImported(data [, idMap]) Event that is called after the node has imported. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Argument Description data Object The data being imported. idMap Array.&lt;Number&gt; &lt;optional&gt; If supplied, identifies a mapping of old ID's to new ID's, any not found in this list will be unchanged. Source: nodes/node.js, line 2044 function onImporting(data [, idMap]) Event that is called when the node is about to be imported. This is your chance to prepare the node for import, or possibly modify the import data. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Argument Description data Object The data being imported. idMap Array.&lt;Number&gt; &lt;optional&gt; If supplied, identifies a mapping of old ID's to new ID's, any not found in this list will be unchanged. Source: nodes/node.js, line 2033 function onInitialPropertyChanged(name, oldValue, newValue) Event that is called when a property initial value has changed. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description name String The name of the property. oldValue Object The old value of the property. newValue Object The new value of the property. Source: nodes/node.js, line 1959 function onInitialPropertyChanging(name, oldValue, newValue) -&gt; Object Event that is called when a property initial value is about to be changed. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description name String The name of the property. oldValue Object The current value of the property. newValue Object The new, proposed, value of the property. Source: nodes/node.js, line 1943 Returns: - Return the new value of the property (usually newValue unless you are proposing restrictions). If no value is returned, newValue is assumed. Type Object function onInitialPropertyGet(name) -&gt; Object | undefined Event that is called when the property initial value is being asked its value, before the value is actually retrieved. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description name String The name of the property. Source: nodes/node.js, line 1974 Returns: - If a value is returned, that value is what will be retrieved from the get. Type Object | undefined function onMoving(oldPos, newPos) -&gt; wcPlay~Coordinates | undefined Event that is called when the node is about to change its position. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description oldPos wcPlay~Coordinates The current position of the node. newPos wcPlay~Coordinates The new position to move the node. Source: nodes/node.js, line 1851 Returns: - Return the new position of the node (usually newPos unless you are restricting the position). If no value is returned, newPos is assumed. Type wcPlay~Coordinates | undefined function onMoving(oldPos, newPos) Event that is called after the node has changed its position. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description oldPos wcPlay~Coordinates The old position of the node. newPos wcPlay~Coordinates The new position of the node. Source: nodes/node.js, line 1863 function onNameChanged(oldName, newName) Event that is called when the name of this node has changed. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description oldName String The current name. newName String The new name. Source: nodes/node.js, line 1886 function onNameChanging(oldName, newName) -&gt; String | undefined Event that is called when the name of this node is about to change. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description oldName String The current name. newName String The new name. Source: nodes/node.js, line 1874 Returns: - Return the new value of the name (usually newValue unless you are restricting the name). If no value is returned, newValue is assumed. Type String | undefined function onPropertyChanged(name, oldValue, newValue) Event that is called when a property has changed. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description name String The name of the property. oldValue Object The old value of the property. newValue Object The new value of the property. Source: nodes/node.js, line 1914 function onPropertyChanging(name, oldValue, newValue) -&gt; Object Event that is called when a property is about to be changed. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description name String The name of the property. oldValue Object The current value of the property. newValue Object The new, proposed, value of the property. Source: nodes/node.js, line 1898 Returns: - Return the new value of the property (usually newValue unless you are proposing restrictions). If no value is returned, newValue is assumed. Type Object function onPropertyGet(name) -&gt; Object | undefined Event that is called when the property is being asked its value, before the value is actually retrieved. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description name String The name of the property. Source: nodes/node.js, line 1929 Returns: - If a value is returned, that value is what will be retrieved from the get. Type Object | undefined function onReset() Event that is called when the node is about to be reset. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Source: nodes/node.js, line 2066 function onStart() Event that is called as soon as the Play script has started. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Source: nodes/node.js, line 1803 function onStop() Event that is called as soon as the Play script has stopped. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Source: nodes/node.js, line 1815 function onViewportDraw(context, readOnly) Event that is called when it is time to draw the contents of your custom viewport. It is up to you to stay within the wcNode.viewportSize you've specified. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description context external:Canvas~Context The canvas context to draw on, coordinates 0,0 will be the top left corner of your viewport. It is up to you to stay within the viewport bounds you have assigned. readOnly Boolean The editors readonly status, when true, you should not allow changes to the node. Source: nodes/node.js, line 1667 See: wcNode#viewportSize function paused(paused) -&gt; Boolean Gets, or Sets whether this node is paused, or any nodes inside if it is a composite. When pausing, all wcNode#setTimeout events are also paused so they don't jump ahead of the debugger. Parameters: Name Type Description paused Boolean If supplied, will assign a new paused state. Source: nodes/node.js, line 264 Returns: - Whether this, or inner nodes, are paused. Type Boolean function pos( [pos]) -&gt; wcPlay~Coordinates Gets, or Sets the current position of the node. Parameters: Name Type Argument Description pos wcPlay~Coordinates &lt;optional&gt; If supplied, will assign a new position for this node. Source: nodes/node.js, line 532 Returns: - The current position of this node. Type wcPlay~Coordinates function property(name [, value] [, forceOrSilent] [, forceUpstream]) -&gt; Object | undefined Gets, or Sets the value of a property. Parameters: Name Type Argument Description name String The name of the property. value Object &lt;optional&gt; If supplied, will assign a new value to the property. forceOrSilent Boolean &lt;optional&gt; If supplied, true will force the change event to be sent to all chained properties even if this value didn't change while false will force the change to not be chained. forceUpstream Boolean &lt;optional&gt; Contrary to normal operation, if this is true then the property change will be sent backwards, from this property's input link to any outputs connected to it. Source: nodes/node.js, line 1301 Returns: - The value of the property, or undefined if not found. Type Object | undefined function propertyOptions(name) -&gt; Object | null Gets the options assigned to a property, you may change attributes from here. Parameters: Name Type Description name String The name of the property. Source: nodes/node.js, line 1284 Returns: - The options object associated with the property, or null if the property does not exist. Type Object | null function removeEntry(name) -&gt; Boolean Removes an entry link from the node. Parameters: Name Type Description name String The name of the entry link to remove. Source: nodes/node.js, line 653 Returns: - Fails if the link does not exist. Type Boolean function removeExit(name) -&gt; Boolean Removes an exit link from the node. Parameters: Name Type Description name String The name of the exit link to remove. Source: nodes/node.js, line 672 Returns: - Fails if the link does not exist. Type Boolean function removeProperty(name) -&gt; Boolean Removes a property from the node. Parameters: Name Type Description name String The name of the property to remove. Source: nodes/node.js, line 691 Returns: - Fails if the property does not exist. Type Boolean function renameEntry(oldName, newName) -&gt; Boolean Renames an entry link on this node while preserving all connected chains. Parameters: Name Type Description oldName String The old (current) name of the link. newName String The new name of the link. Source: nodes/node.js, line 711 Returns: - Fails if the new name already exists, or the old name does not. Type Boolean function renameExit(oldName, newName) -&gt; Boolean Renames an exit link on this node while preserving all connected chains. Parameters: Name Type Description oldName String The old (current) name of the link. newName String The new name of the link. Source: nodes/node.js, line 742 Returns: - Fails if the new name already exists, or the old name does not. Type Boolean function renameProperty(oldName, newName) -&gt; Boolean Renames a property on this node while preserving all connected chains. Parameters: Name Type Description oldName String The old (current) name of the link. newName String The new name of the link. Source: nodes/node.js, line 773 Returns: - Fails if the new name already exists, or the old name does not. Type Boolean function reset() Resets all properties to their initial values. Source: nodes/node.js, line 98 function resetThreads() Resets only latent running threads. Source: nodes/node.js, line 116 function search(search) -&gt; Boolean Determines whether a search value matches this node. Parameters: Name Type Description search String The search value. Source: nodes/node.js, line 361 Returns: Type Boolean function setInterval(callback, interval) Utility function for setting an interval update in a way that is compatible with live debugging in the editor tool. Note: You can call wcNode#resetThreads if you want to cancel any existing intervals running on your node. Parameters: Name Type Description callback function A callback function to call each time the time interval has elapsed. As an added convenience, 'this' will be the node instance. interval Number The time interval, in milliseconds, between each call to callback. Source: nodes/node.js, line 402 Example onActivated: function(name) { var interval = this.property('milliseconds'); this.resetThreads(); this.setInterval(function() { this.activateExit('out'); }, interval); } function setTimeout(callback, delay) Utility function for setting a timed event in a way that is compatible with live debugging in the editor tool. Parameters: Name Type Description callback function A callback function to call when the time has elapsed. As an added convenience, 'this' will be the node instance. delay Number The time delay, in milliseconds, to wait before calling the callback function. Source: nodes/node.js, line 376 Example onActivated: function(name) { this._super(name); // Now set a timeout to wait for 'Milliseconds' amount of time. var delay = this.property('milliseconds'); // Start a timeout event using the node's built in timeout handler. this.setTimeout(function() { this.activateExit('out'); }, delay); } function viewportSize( [width] [, height]) -&gt; wcPlay~Coordinates Sets a size for the custom viewport. The custom viewport is a rectangular area embedded into the node's visual display in which you can 'draw' whatever you wish. It appears below the title text and above properties. Parameters: Name Type Argument Description width Number &lt;optional&gt; If supplied, assigns the width of the viewport desired. Use 0 or null to disable the viewport. height Number &lt;optional&gt; If supplied, assigns the height of the viewport desired. Use 0 or null to disable the viewport. Source: nodes/node.js, line 1642 See: wcNode#onViewportDraw Returns: - The current size of the viewport. Type wcPlay~Coordinates &lt;inner&gt; function onViewportMouseClick(event, pos, readOnly) -&gt; Boolean | undefined Event that is called when the mouse button is double clicked in the same spot over your viewport area. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description event Object The original jquery mouse event. pos wcPlay~Coordinates The position of the mouse relative to the viewport area (top left corner is 0,0). readOnly Boolean The editors readonly status, when true, you should not allow changes to the node. Source: nodes/node.js, line 1770 Returns: - Return true if you want to disable node auto-collapse when double clicking. Type Boolean | undefined &lt;inner&gt; function onViewportMouseClick(event, pos, readOnly) Event that is called when the mouse button is pressed and released in the same spot over your viewport area. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description event Object The original jquery mouse event. pos wcPlay~Coordinates The position of the mouse relative to the viewport area (top left corner is 0,0). readOnly Boolean The editors readonly status, when true, you should not allow changes to the node. Source: nodes/node.js, line 1758 &lt;inner&gt; function onViewportMouseDown(event, pos, readOnly) -&gt; Boolean | undefined Event that is called when the mouse button is pressed over your viewport area. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description event Object The original jquery mouse event. pos wcPlay~Coordinates The position of the mouse relative to the viewport area (top left corner is 0,0). readOnly Boolean The editors readonly status, when true, you should not allow changes to the node. Source: nodes/node.js, line 1708 Returns: - Return true if you want to disable node dragging during mouse down within your viewport. Type Boolean | undefined &lt;inner&gt; function onViewportMouseEnter(event, pos, readOnly) Event that is called when the mouse has entered the viewport area. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description event Object The original jquery mouse event. pos wcPlay~Coordinates The position of the mouse relative to the viewport area (top left corner is 0,0). readOnly Boolean The editors readonly status, when true, you should not allow changes to the node. Source: nodes/node.js, line 1679 &lt;inner&gt; function onViewportMouseLeave(event, readOnly) Event that is called when the mouse has left the viewport area. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description event Object The original jquery mouse event. readOnly Boolean The editors readonly status, when true, you should not allow changes to the node. Source: nodes/node.js, line 1694 &lt;inner&gt; function onViewportMouseMove(event, pos, readOnly) Event that is called when the mouse has moved over your viewport area. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description event Object The original jquery mouse event. pos wcPlay~Coordinates The position of the mouse relative to the viewport area (top left corner is 0,0). readOnly Boolean The editors readonly status, when true, you should not allow changes to the node. Source: nodes/node.js, line 1733 &lt;inner&gt; function onViewportMouseUp(event, pos, readOnly) Event that is called when the mouse button is released over your viewport area. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description event Object The original jquery mouse event. pos wcPlay~Coordinates The position of the mouse relative to the viewport area (top left corner is 0,0). readOnly Boolean The editors readonly status, when true, you should not allow changes to the node. Source: nodes/node.js, line 1721 &lt;inner&gt; function onViewportMouseWheel(event, pos, scrollDelta, readOnly) Event that is called when the mouse wheel is used over your viewport area. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description event Object The original jquery mouse event. pos wcPlay~Coordinates The position of the mouse relative to the viewport area (top left corner is 0,0). scrollDelta Number The scroll amount and direction. readOnly Boolean The editors readonly status, when true, you should not allow changes to the node. Source: nodes/node.js, line 1745 Type Definitions typedef var PROPERTY_ENABLED Enabled property name. Type: String Source: nodes/node.js, line 2120 typedef var ChainData Basic information about a chain connection. Type: Object Properties: Name Type Description inName String The name of the input or entry link this chain is connected to. inNodeId Number The ID of the input or entry node this chain is connected to. outName String The name of the output or exit link this chain is connected to. outNodeId Number The ID of the output or exit node this chain is connected to. Source: nodes/node.jsdoc, line 103 typedef function CustomCreateFunc(node, name, value, isInitial, onChanged) -&gt; external:jQuery~Object A callback function to generate a custom property control, this should generate the necessary controls and return a containing control element. Parameters: Name Type Description node wcNode The node. name String The property name being changed. value Object The property value. isInitial Boolean If true, the property being changed is the initial value. onChanged wcNode~CustomOnChangedFunc A function to call when the property value has been changed. Source: nodes/node.jsdoc, line 79 Returns: - A containing element that contains the control. Type external:jQuery~Object typedef function CustomOnChangedFunc(newValue) Used with the custom property type, a callback to call when the property value has changed. This allows for proper undo management. Parameters: Name Type Description newValue Object The new value. Source: nodes/node.jsdoc, line 90 typedef var CustomOptions Options for a CUSTOM value. Type: Object Properties: Name Type Argument Description description String &lt;optional&gt; An optional description to display as a tooltip for this property. display wcNode~PropertyDisplay &lt;optional&gt; An optional function that will be called to retrieve the display string for the value/initial value for this property. exportValue wcNode~ExportValue &lt;optional&gt; An optional function that will retrieve the property's value when it is about to be exported to file. input Boolean &lt;optional&gt; If true, this property will have an input link so its value can be changed through script. output Boolean &lt;optional&gt; If true, this property will have an output link so its value can be retrieved through script. linked Boolean &lt;optional&gt; If true, the value and initial values will be linked and can not be separated. Changing either will change them both. onCreate wcNode~CustomCreateFunc &lt;optional&gt; If supplied, will be called when the property control is being edited and should return an element to display the control. Source: nodes/node.jsdoc, line 61 typedef var NumberOptions Options for a NUMBER value. Type: Object Properties: Name Type Argument Default Description description String &lt;optional&gt; An optional description to display as a tooltip for this property. display wcNode~PropertyDisplay &lt;optional&gt; An optional function that will be called to retrieve the display string for the value/initial value for this property. exportValue wcNode~ExportValue &lt;optional&gt; An optional function that will retrieve the property's value when it is about to be exported to file. input Boolean &lt;optional&gt; If true, this property will have an input link so its value can be changed through script. output Boolean &lt;optional&gt; If true, this property will have an output link so its value can be retrieved through script. linked Boolean &lt;optional&gt; If true, the value and initial values will be linked and can not be separated. Changing either will change them both. min Number &lt;optional&gt; -Infinity The minimum value of the number range. max Number &lt;optional&gt; Infinity The maximum value of the number range. step Number &lt;optional&gt; 1 The amount the value will go up or down when the user clicks the up and down arrow controls. Source: nodes/node.jsdoc, line 19 typedef var PropertyData Basic information for a property. Type: Object Properties: Name Type Description name String The name of the property. value Object The current value of the property. initialValue Object The initial value of the property. Source: nodes/node.jsdoc, line 112 typedef function PropertyDisplay() -&gt; String Allows for overriding the display string for a property value as displayed on the node. Parameters: Type Description Object The value or initial value of the property to display. Source: nodes/node.jsdoc, line 1 Returns: - A string value to display on the node. Type String typedef var PropertyOptions A set of options that apply to all property types. Type: Object Properties: Name Type Argument Description description String &lt;optional&gt; An optional description to display as a tooltip for this property. display wcNode~PropertyDisplay &lt;optional&gt; An optional function that will be called to retrieve the display string for the value/initial value for this property. exportValue wcNode~ExportValue &lt;optional&gt; An optional function that will retrieve the property's value when it is about to be exported to file. input Boolean &lt;optional&gt; If true, this property will have an input link so its value can be changed through script. output Boolean &lt;optional&gt; If true, this property will have an output link so its value can be retrieved through script. linked Boolean &lt;optional&gt; If true, the value and initial values will be linked and can not be separated. Changing either will change them both. Source: nodes/node.jsdoc, line 8 typedef var SelectItem A select property item. Type: Object Properties: Name Type Description name String The display text to display for this item. value String | Number The value to assign to the property when this property is selected. Source: nodes/node.jsdoc, line 96 typedef function SelectItemFunc(items) A callback that dynamically retrieves a list of items to display in a Select property. Parameters: Name Type Description items Array.&lt;wcNode~SelectItem&gt; | Array.&lt;String&gt; A list of items to display in the combo box. Source: nodes/node.jsdoc, line 73 typedef var SelectOptions Options for a SELECT value. Type: Object Properties: Name Type Argument Default Description description String &lt;optional&gt; An optional description to display as a tooltip for this property. display wcNode~PropertyDisplay &lt;optional&gt; An optional function that will be called to retrieve the display string for the value/initial value for this property. exportValue wcNode~ExportValue &lt;optional&gt; An optional function that will retrieve the property's value when it is about to be exported to file. input Boolean &lt;optional&gt; If true, this property will have an input link so its value can be changed through script. output Boolean &lt;optional&gt; If true, this property will have an output link so its value can be retrieved through script. linked Boolean &lt;optional&gt; If true, the value and initial values will be linked and can not be separated. Changing either will change them both. items Array.&lt;wcNode~SelectItem&gt; | Array.&lt;String&gt; | wcNode~SelectItemFunc A list of items to display in the combo box, or a callback function that can dynamically retrieve a list. allowNone Boolean &lt;optional&gt; true If true, will allow the user to select '' as an option. noneValue Object &lt;optional&gt; If supplied, and allowNone is true, will assign the internal value of the '' option. Source: nodes/node.jsdoc, line 47 typedef var StringOptions Options for a STRING value. Type: Object Properties: Name Type Argument Default Description description String &lt;optional&gt; An optional description to display as a tooltip for this property. display wcNode~PropertyDisplay &lt;optional&gt; An optional function that will be called to retrieve the display string for the value/initial value for this property. exportValue wcNode~ExportValue &lt;optional&gt; An optional function that will retrieve the property's value when it is about to be exported to file. input Boolean &lt;optional&gt; If true, this property will have an input link so its value can be changed through script. output Boolean &lt;optional&gt; If true, this property will have an output link so its value can be retrieved through script. linked Boolean &lt;optional&gt; If true, the value and initial values will be linked and can not be separated. Changing either will change them both. maxlength Number &lt;optional&gt; Infinity The maximum number of characters allowed. multiline Boolean &lt;optional&gt; false Whether to use a multi-line text editor for this property. items Array.&lt;wcNode~SelectItem&gt; | Array.&lt;String&gt; | wcNode~SelectItemFunc A list of items to drop down in a suggestion as the user types, or a callback function that can dynamically retrieve a list. See here for browser compatability information. Source: nodes/node.jsdoc, line 33  Search results Close "},"wcNodeComposite.html":{"id":"wcNodeComposite.html","title":"Class: wcNodeComposite","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Class: wcNodeComposite wcNodeComposite The base class for all composite nodes. new wcNodeComposite(parent, pos) Parameters: Name Type Description parent String The parent object of this node. pos wcPlay~Coordinates The position of this node in the visual editor. Source: nodes/composite.js, line 2 Methods function classInit(className, type, category) Magic function that is called whenever any new class type is extended from this one. Handles initializing of the class as well as registering the new node type. Parameters: Name Type Description className String The name of the class constructor. type String The type name for the node. category String A category where this node will be grouped. Source: nodes/composite.js, line 18  Search results Close "},"wcNodeEntry.html":{"id":"wcNodeEntry.html","title":"Class: wcNodeEntry","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Class: wcNodeEntry wcNodeEntry The base class for all entry nodes. These are nodes that start script chains. When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. new wcNodeEntry(parent, pos) Should be inherited and never constructed directly. Parameters: Name Type Description parent String The parent object of this node. pos wcPlay~Coordinates The position of this node in the visual editor. Source: nodes/entry.js, line 2 Methods function classInit(className, type, category) Magic function that is called whenever any new class type is extended from this one. Handles initializing of the class as well as registering the new node type. Parameters: Name Type Description className String The name of the class constructor. type String The type name for the node. category String A category where this node will be grouped. Source: nodes/entry.js, line 21 function onActivated(name) Overloading the default onActivated event handler so we can make it immediately trigger our Exit link. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description name String The name of the entry link triggered. Source: nodes/entry.js, line 39  Search results Close "},"wcNodeEntryCallRemote.html":{"id":"wcNodeEntryCallRemote.html","title":"Class: wcNodeEntryCallRemote","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Class: wcNodeEntryCallRemote wcNodeEntryCallRemote An entry node that fires when a Call Remote Event Node of the same name is activated. When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. new wcNodeEntryCallRemote(parent, pos) Parameters: Name Type Description parent String The parent object of this node. pos wcPlay~Coordinates The position of this node in the visual editor. Source: nodes/entry/callremote.js, line 2 Methods function onActivated(name) Event that is called when an entry link has been activated. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description name String The name of the entry link triggered. Source: nodes/entry/callremote.js, line 23  Search results Close "},"wcNodeEntryRemote.html":{"id":"wcNodeEntryRemote.html","title":"Class: wcNodeEntryRemote","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Class: wcNodeEntryRemote wcNodeEntryRemote An entry node that fires when a Call Remote Event Node of the same name is activated. When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. new wcNodeEntryRemote(parent, pos) Parameters: Name Type Description parent String The parent object of this node. pos wcPlay~Coordinates The position of this node in the visual editor. Source: nodes/entry/remote.js, line 2  Search results Close "},"wcNodeEntryStart.html":{"id":"wcNodeEntryStart.html","title":"Class: wcNodeEntryStart","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Class: wcNodeEntryStart wcNodeEntryStart An entry node that fires as soon as the script starts. When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. new wcNodeEntryStart(parent, pos) Parameters: Name Type Description parent String The parent object of this node. pos wcPlay~Coordinates The position of this node in the visual editor. Source: nodes/entry/start.js, line 2 Methods function onStart() Event that is called as soon as the Play script has started. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Source: nodes/entry/start.js, line 17  Search results Close "},"wcNodeEntryUpdate.html":{"id":"wcNodeEntryUpdate.html","title":"Class: wcNodeEntryUpdate","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Class: wcNodeEntryUpdate wcNodeEntryUpdate An entry node that fires continuously on a regular update. When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. new wcNodeEntryUpdate(parent, pos) Parameters: Name Type Description parent String The parent object of this node. pos wcPlay~Coordinates The position of this node in the visual editor. Source: nodes/entry/update.js, line 2 Methods function onActivated(name) Overloading the default onActivated event handler so we can make it immediately trigger our exit link if our conditions are met. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description name String The name of the entry link triggered. Source: nodes/entry/update.js, line 19 function onPropertyChanged(name, oldValue, newValue) Event that is called when a property has changed. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description name String The name of the property. oldValue Object The old value of the property. newValue Object The new value of the property. Source: nodes/entry/update.js, line 45 function onStart() Event that is called as soon as the Play script has started. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Source: nodes/entry/update.js, line 34  Search results Close "},"wcNodeProcess.html":{"id":"wcNodeProcess.html","title":"Class: wcNodeProcess","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Class: wcNodeProcess wcNodeProcess The base class for all process nodes. These are nodes that make up the bulk of script chains. When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. new wcNodeProcess(parent, pos) Should be inherited and never constructed directly. Parameters: Name Type Description parent String The parent object of this node. pos wcPlay~Coordinates The position of this node in the visual editor. Source: nodes/process.js, line 2 Methods function classInit(className, type, category) Magic function that is called whenever any new class type is extended from this one. Handles initializing of the class as well as registering the new node type. Parameters: Name Type Description className String The name of the class constructor. type String The type name for the node. category String A category where this node will be grouped. Source: nodes/process.js, line 22  Search results Close "},"wcNodeProcessAJAX.html":{"id":"wcNodeProcessAJAX.html","title":"Class: wcNodeProcessAJAX","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Class: wcNodeProcessAJAX wcNodeProcessAJAX Performs an AJAX request. When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. new wcNodeProcessAJAX(parent, pos) Parameters: Name Type Description parent String The parent object of this node. pos wcPlay~Coordinates The position of this node in the visual editor. Source: nodes/process/ajax.js, line 2 Methods function onActivated(name) Event that is called when an entry link has been activated. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description name String The name of the entry link triggered. Source: nodes/process/ajax.js, line 27  Search results Close "},"wcNodeProcessAlert.html":{"id":"wcNodeProcessAlert.html","title":"Class: wcNodeProcessAlert","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Class: wcNodeProcessAlert wcNodeProcessAlert For debugging purposes, will popup an alert box with a message the moment it is activated. Silent mode will silence this node. When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. new wcNodeProcessAlert(parent, pos) Parameters: Name Type Description parent String The parent object of this node. pos wcPlay~Coordinates The position of this node in the visual editor. Source: nodes/process/alert.js, line 2 Methods function onActivated(name) Event that is called when an entry link has been activated. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description name String The name of the entry link triggered. Source: nodes/process/alert.js, line 20  Search results Close "},"wcNodeProcessConsoleLog.html":{"id":"wcNodeProcessConsoleLog.html","title":"Class: wcNodeProcessConsoleLog","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Class: wcNodeProcessConsoleLog wcNodeProcessConsoleLog For debugging purposes, will print out a message into the console log the moment it is activated. Silent mode will silence this node. When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. new wcNodeProcessConsoleLog(parent, pos) Parameters: Name Type Description parent String The parent object of this node. pos wcPlay~Coordinates The position of this node in the visual editor. Source: nodes/process/consolelog.js, line 2 Methods function onActivated(name) Event that is called when an entry link has been activated. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description name String The name of the entry link triggered. Source: nodes/process/consolelog.js, line 20  Search results Close "},"wcNodeProcessDelay.html":{"id":"wcNodeProcessDelay.html","title":"Class: wcNodeProcessDelay","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Class: wcNodeProcessDelay wcNodeProcessDelay Waits for a specified amount of time before continuing the flow chain. When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. new wcNodeProcessDelay(parent, pos) Parameters: Name Type Description parent String The parent object of this node. pos wcPlay~Coordinates The position of this node in the visual editor. Source: nodes/process/delay.js, line 2 Methods function onActivated(name) Event that is called when an entry link has been activated. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description name String The name of the entry link triggered. Source: nodes/process/delay.js, line 19  Search results Close "},"wcNodeProcessOperation.html":{"id":"wcNodeProcessOperation.html","title":"Class: wcNodeProcessOperation","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Class: wcNodeProcessOperation wcNodeProcessOperation Performs a simple math operation on two values. When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. new wcNodeProcessOperation(parent, pos) Parameters: Name Type Description parent String The parent object of this node. pos wcPlay~Coordinates The position of this node in the visual editor. Source: nodes/process/operation.js, line 2 Methods function onActivated(name) Event that is called when an entry link has been activated. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description name String The name of the entry link triggered. Source: nodes/process/operation.js, line 32  Search results Close "},"wcNodeProcessStrCat.html":{"id":"wcNodeProcessStrCat.html","title":"Class: wcNodeProcessStrCat","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Class: wcNodeProcessStrCat wcNodeProcessStrCat Formats a templated string by replacing template commands with the value of other properties. When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. new wcNodeProcessStrCat(parent, pos) Parameters: Name Type Description parent String The parent object of this node. pos wcPlay~Coordinates The position of this node in the visual editor. Source: nodes/process/strcat.js, line 2 Methods function onActivated(name) Event that is called when an entry link has been activated. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description name String The name of the entry link triggered. Source: nodes/process/strcat.js, line 23  Search results Close "},"wcNodeStorage.html":{"id":"wcNodeStorage.html","title":"Class: wcNodeStorage","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Class: wcNodeStorage wcNodeStorage The base class for all storage nodes. These are nodes designed solely for managing data. When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. Also when inheriting, a 'value' property MUST be created as the storage value. new wcNodeStorage(parent, pos) Parameters: Name Type Description parent String The parent object of this node. pos wcPlay~Coordinates The position of this node in the visual editor. Source: nodes/storage.js, line 2 Methods function classInit(className, type, category) Magic function that is called whenever any new class type is extended from this one. Handles initializing of the class as well as registering the new node type. Parameters: Name Type Description className String The name of the class constructor. type String The type name for the node. category String A category where this node will be grouped. Source: nodes/storage.js, line 17 function onStart() Event that is called as soon as the Play script has started. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Source: nodes/storage.js, line 35  Search results Close "},"wcNodeStorageGlobal.html":{"id":"wcNodeStorageGlobal.html","title":"Class: wcNodeStorageGlobal","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Class: wcNodeStorageGlobal wcNodeStorageGlobal References a global property on the script. When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. new wcNodeStorageGlobal(parent, pos) Parameters: Name Type Description parent String The parent object of this node. pos wcPlay~Coordinates The position of this node in the visual editor. Source: nodes/storage/global.js, line 2 Methods function onGlobalInitialPropertyChanged(name, oldValue, newValue) Event that is called when a global property initial value has changed. Overload this in inherited nodes. Note: Do not call 'this._super(..)' for this function, as the parent does not implement it. Parameters: Name Type Description name String The name of the global property. oldValue Object The old value of the global property. newValue Object The new value of the global property. Source: nodes/storage/global.js, line 155 function onGlobalPropertyChanged(name, oldValue, newValue) Event that is called when a global property value has changed. Overload this in inherited nodes. Note: Do not call 'this._super(..)' for this function, as the parent does not implement it. Parameters: Name Type Description name String The name of the global property. oldValue Object The old value of the global property. newValue Object The new value of the global property. Source: nodes/storage/global.js, line 139 function onGlobalPropertyRemoved(name) Event that is called when a global property has been removed. Overload this in inherited nodes. Note: Do not call 'this._super(..)' for this function, as the parent does not implement it. Parameters: Name Type Description name String The name of the global property. Source: nodes/storage/global.js, line 171 function onGlobalPropertyRenamed(oldName, newName) Event that is called when a global property has been renamed. Overload this in inherited nodes. Note: Do not call 'this._super(..)' for this function, as the parent does not implement it. Parameters: Name Type Description oldName String The old name of the global property. newName String The new name of the global property. Source: nodes/storage/global.js, line 184 function onInitialPropertyChanging(name, oldValue, newValue) -&gt; Object Any changes to the 'value' property will also change the global property. Event that is called when a property initial value is about to be changed. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description name String The name of the property. oldValue Object The current value of the property. newValue Object The new, proposed, value of the property. Source: nodes/storage/global.js, line 98 Returns: - Return the new value of the property (usually newValue unless you are proposing restrictions). If no value is returned, newValue is assumed. Type Object function onInitialPropertyGet(name) -&gt; Object | undefined Always redirect property gets on 'value' to the referenced global property. Event that is called when the property initial value is being asked its value, before the value is actually retrieved. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description name String The name of the property. Source: nodes/storage/global.js, line 119 Returns: - If a value is returned, that value is what will be retrieved from the get. Type Object | undefined function onNameChanged(oldName, newName) Event that is called when the name of this node has changed. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description oldName String The current name. newName String The new name. Source: nodes/storage/global.js, line 21 function onPropertyChanged(name, oldValue, newValue) Any changes to the 'value' property will also change the global property. Event that is called when a property has changed. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description name String The name of the property. oldValue Object The old value of the property. newValue Object The new value of the property. Source: nodes/storage/global.js, line 59 function onPropertyGet(name) -&gt; Object | undefined Always redirect property gets on 'value' to the referenced global property. Event that is called when the property is being asked its value, before the value is actually retrieved. Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. Parameters: Name Type Description name String The name of the property. Source: nodes/storage/global.js, line 79 Returns: - If a value is returned, that value is what will be retrieved from the get. Type Object | undefined  Search results Close "},"wcNodeStorageNumber.html":{"id":"wcNodeStorageNumber.html","title":"Class: wcNodeStorageNumber","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Class: wcNodeStorageNumber wcNodeStorageNumber Stores a number value. When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. new wcNodeStorageNumber(parent, pos) Parameters: Name Type Description parent String The parent object of this node. pos wcPlay~Coordinates The position of this node in the visual editor. Source: nodes/storage/number.js, line 2  Search results Close "},"wcNodeStorageString.html":{"id":"wcNodeStorageString.html","title":"Class: wcNodeStorageString","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Class: wcNodeStorageString wcNodeStorageString Stores a string value. When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. new wcNodeStorageString(parent, pos) Parameters: Name Type Description parent String The parent object of this node. pos wcPlay~Coordinates The position of this node in the visual editor. Source: nodes/storage/string.js, line 2  Search results Close "},"wcNodeStorageToggle.html":{"id":"wcNodeStorageToggle.html","title":"Class: wcNodeStorageToggle","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Class: wcNodeStorageToggle wcNodeStorageToggle Stores a boolean (toggleable) value. When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. new wcNodeStorageToggle(parent, pos) Parameters: Name Type Description parent String The parent object of this node. pos wcPlay~Coordinates The position of this node in the visual editor. Source: nodes/storage/toggle.js, line 2  Search results Close "},"wcPlay.html":{"id":"wcPlay.html","title":"Class: wcPlay","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Class: wcPlay wcPlay The main scripting engine. new wcPlay( [options]) Parameters: Name Type Argument Description options wcPlay~Options &lt;optional&gt; Custom options. Source: play.js, line 8 Members &lt;static&gt; var INSTANCE_LIBRARY A global list of play engine instances that exist. Source: play.js, line 96 &lt;static&gt; var NODE The different types of nodes. Type: String Properties: Name Type Default Description ENTRY String entry Entry nodes mark the beginning of an execution flow chain and are usually triggered by some type of event that happens outside of the script. PROCESS String process Process nodes perform a process, often very simple, and make up the bulk of a flow chain within the script. STORAGE String storage Storage nodes are designed with a single purpose of storing data for use within the script. COMPOSITE String composite Composite nodes are a group of nodes combined into a single visible node. They appear in the composite section of the node palette for easy duplication within your script. Source: play.js, line 75 &lt;static&gt; var NODE_LIBRARY A global list of nodes that exist. All node types must add themselves into this list when they are coded. Source: play.js, line 90 &lt;static&gt; var PROPERTY Determines how a property's control should be rendered within the editor view. Type: String Properties: Name Type Default Description DYNAMIC String dynamic Displays the property as a string, but does not enforce or convert its type. String options are used. TOGGLE String toggle Displays the property as a checkbox. Default options are used. NUMBER String number Displays the property as a number control. Number options are used. STRING String string Displays the property as a text field. String options are used. SELECT String select Displays the property as a combo box control. Select options are used. CUSTOM String custom Displays the property as a custom control. Custom options are used. Source: play.js, line 56 Methods &lt;static&gt; function registerNodeType(name, displayName, category, nodeType) -&gt; Boolean A global function that registers a new node type into the library. This is called automatically when a new extended node type is defined, you should not have to do this manually. Parameters: Name Type Description name String The name of the node constructor. displayName String The display name. category String The display category name. nodeType wcPlay.NODE The node's type. Source: play.js, line 106 Returns: - Success or failure. Type Boolean &lt;static&gt; function unregisterNodeType(name) -&gt; Boolean A global function that unregisters a node type from the library. Parameters: Name Type Description name String The name of the node constructor. Source: play.js, line 138 Returns: - True if the node type has been found and removed. Type Boolean function clear() Clears all nodes from the script. Source: play.js, line 218 function createProperty(name, type [, initialValue] [, options]) -&gt; Boolean Creates a new global property (can be used with the global storage node). Parameters: Name Type Argument Description name String The name of the property. type wcPlay.PROPERTY The type of property. initialValue Object &lt;optional&gt; A default value for this property. options Object &lt;optional&gt; Additional options for this property, see wcPlay.PROPERTY. Source: play.js, line 664 Returns: - Fails if the property does not exist. Type Boolean function customData( [data]) -&gt; Object Gets, or Sets a custom data object to the script that will be saved and restored with the output file data. NOTE: Binding new data will always replace any data that may have been previously bound. Parameters: Name Type Argument Description data Object | function &lt;optional&gt; If supplied, will assign a new custom data. If you supply a function, it will be invoked when retrieving the data. If not supplied, will retrieve the currently bound data. Source: play.js, line 337 Returns: - The current custom data object. Type Object function debugging( [debug]) -&gt; Boolean Gets, or Sets the debugging state of the script. Parameters: Name Type Argument Description debug Boolean &lt;optional&gt; If supplied, will assign the debugging state of the script. Source: play.js, line 604 Returns: - The current debugging state of the script. Type Boolean function destroy() Destroys this instance. Source: play.js, line 1012 function import(serialData) -&gt; Boolean Imports a script as a new composite node that can be retrieved with wcPlay#importedComposites. Parameters: Name Type Description serialData String The serialized data to import. Source: play.js, line 356 Returns: - Whether the new composite node was created. Type Boolean function importedComposites() -&gt; Array.&lt;wcNodeCompositeScript&gt; Retrieves the list of all imported composite nodes. Source: play.js, line 405 See: wcPlay#importComposite Returns: - An array of imported composite nodes. Type Array.&lt;wcNodeCompositeScript&gt; function initialProperty(name [, value]) -&gt; Object Gets, or Sets a global property initial value. Parameters: Name Type Argument Description name String The name of the property. value Object &lt;optional&gt; If supplied, will assign a new value to the property. Source: play.js, line 768 Returns: - The current value of the property, or undefined if not found. Type Object function instanceOf() -&gt; String Retrieves the class name of this object. Source: play.js, line 1044 Returns: Type String function isA() -&gt; String Retrieves the class name of this object. Source: play.js, line 1035 Returns: Type String function isRunning() -&gt; Boolean Retrieves whether the script is running. Source: play.js, line 183 Returns: Type Boolean function listProperties() -&gt; Array.&lt;wcNode~PropertyData&gt; Retrieves a list of all global properties and their values for this script. Source: play.js, line 802 Returns: - A list of all property data. Type Array.&lt;wcNode~PropertyData&gt; function load(serialData) -&gt; Boolean Loads a script from previously serialized data generated by save. Parameters: Name Type Description serialData String The serialized data to load. Source: play.js, line 278 Returns: - Success or failure. Type Boolean function nodeById(id) -&gt; wcNode | null Retrieves a node from a given ID, if it exists in this script. Parameters: Name Type Description id Number The ID of the node. Source: play.js, line 471 Returns: - Either the found node, or null. Type wcNode | null function nodesByClassName(className) -&gt; Array.&lt;wcNode&gt; Retrieves a list of nodes that match a given class name, if they exists in this script. Parameters: Name Type Description className String The className of the nodes to retrieve. Source: play.js, line 510 Returns: - A list of all found nodes. Type Array.&lt;wcNode&gt; function nodesBySearch(search) -&gt; Array.&lt;wcNode&gt; Retrieves a list of nodes that match a given search filter. Parameters: Name Type Description search String The search value. Source: play.js, line 550 Returns: - A list of all found nodes. Type Array.&lt;wcNode&gt; function notifyEditors(func, args) Sends a custom notification event to all renderers. Parameters: Name Type Description func String The renderer function to call. args Array.&lt;Object&gt; A list of arguments to forward into the function call. Source: play.js, line 883 function notifyNodes(func, args [, includeEditorPalette]) Sends a custom notification event to all nodes. Parameters: Name Type Argument Description func String The node function to call. args Array.&lt;Object&gt; A list of arguments to forward into the function call. includeEditorPalette Boolean &lt;optional&gt; If true, will also notify all nodes generated for use with editor palette views. Source: play.js, line 838 function paused( [paused]) -&gt; Boolean Gets, or Sets the pause state of the script. Parameters: Name Type Argument Description paused Boolean &lt;optional&gt; If supplied, will assign the paused state of the script. Source: play.js, line 618 Returns: - The current pause state of the script. Type Boolean function property(name [, value]) -&gt; Object Gets, or Sets a global property value. Parameters: Name Type Argument Description name String The name of the property. value Object &lt;optional&gt; If supplied, will assign a new value to the property. Source: play.js, line 739 Returns: - The current value of the property, or undefined if not found. Type Object function queueNodeEntry(node, name, fromNode, fromName [, forceQueue]) Queues a node entry link to trigger on the next update. Parameters: Name Type Argument Description node wcNode The node being queued. name String The entry link name. fromNode wcNode The node causing the queue. fromName String The exit link name. forceQueue Boolean &lt;optional&gt; If true, will force the event into the queue rather than the waiting list. Source: play.js, line 899 function queueNodeProperty(node, name, value [, upstream]) Queues a node property value change to trigger on the next update. Parameters: Name Type Argument Description node wcNode The node being queued. name String The property name. value Object The property value. upstream Boolean &lt;optional&gt; If true, we are propagating the property change in reverse. Source: play.js, line 972 function removeProperty(name) -&gt; Boolean Removes a global property. Parameters: Name Type Description name String The name of the property to remove. Source: play.js, line 722 Returns: - Fails if the property does not exist. Type Boolean function renameProperty(name, newName) -&gt; Boolean Renames an existing global property. Parameters: Name Type Description name String The current name of the global property to rename. newName String The new desired name of the global property. Source: play.js, line 695 Returns: - Fails if the property was not found or if the new name is already used. Type Boolean function reset() Resets all volotile data in the script. Source: play.js, line 192 function save() -&gt; String Serializes the script into a string that can be saved into a file and restored. Source: play.js, line 243 Returns: - A serialized string with the entire script. Type String function silent(silent) -&gt; Boolean Gets, or Sets whether the script is running in silent mode. Parameters: Name Type Description silent Boolean If supplied, assigns a new silent state of the script. Source: play.js, line 590 Returns: - The current silent state of the script. Type Boolean function start() Initializes the script and begins the update process. Source: play.js, line 159 function stepping( [stepping]) -&gt; Boolean Gets, or Sets the stepping state of the script. Parameters: Name Type Argument Description stepping Boolean &lt;optional&gt; If supplied, will assign the stepping state of the script. Source: play.js, line 650 Returns: - The current stepping state of the script. Type Boolean function stop() Stops the script. Source: play.js, line 173 function triggerEvent(type [, name] [, data]) Triggers an event into the Play script. Parameters: Name Type Argument Description type String The type name of the node (as displayed in the title). name String &lt;optional&gt; The event name to trigger (as displayed in the title between the parenthesis). Use an empty string to ignore the name. data Object &lt;optional&gt; Any data object that will be passed into the entry node. Source: play.js, line 823 function update() Update handler. Source: play.js, line 415 Type Definitions typedef var Coordinates A 2D positional coordinate. Type: Object Properties: Name Type Description x Number The horizontal coordinate. y Number The vertical coordinate. Source: play.jsdoc, line 10 typedef var Options Custom options available when constructing a new wcPlay instance. Type: Object Properties: Name Type Argument Default Description silent Boolean &lt;optional&gt; false If true, will disable debug logging on all nodes. updateRate Number &lt;optional&gt; 25 The time, in milliseconds, between node updates. updateLimit Number &lt;optional&gt; 100 The maximum number of nodes allowed to be updated in a single update. This minimizes the potential for script lock. debugging Boolean &lt;optional&gt; true If true, debug break toggles on individual nodes will trigger the script to pause. Turn this off during production. Source: play.jsdoc, line 1  Search results Close "},"wcPlayEditor.html":{"id":"wcPlayEditor.html","title":"Class: wcPlayEditor","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Class: wcPlayEditor wcPlayEditor Provides a visual interface for editing a Play script. Requires HTML5 canvas. new wcPlayEditor(container [, options]) Parameters: Name Type Argument Description container external:jQuery~Object | external:jQuery~Selector | external:domNode The container element. options wcPlayEditor~Options &lt;optional&gt; Custom options. Source: editor.js, line 20 Methods function __drawDetailsPopup(node) Draws the detail popup box for the node. Parameters: Name Type Description node wcNode The node to draw for. Source: editor.js, line 3516 function __handleAutoScroll(active, movingNodes) Handles auto scrolling based on mouse position. Parameters: Name Type Description active Boolean Whether the auto scroll is active. movingNodes Boolean If true, the auto scroll will also move selected nodes. Source: editor.js, line 3960 function __onCreateNode(node) Generates an undo event for a node that was created. Parameters: Name Type Description node wcNode The node that was created. Source: editor.js, line 3873 function __onDestroyNode(node) Generates an undo event for a node that is destroyed. Parameters: Name Type Description node wcNode the node to destroy. Source: editor.js, line 3920 function center() Positions the canvas view to the center of all nodes. Source: editor.js, line 269 function clearModified() Clears the modified state of the current script. Note, this is done automatically when saving the script, use this only under special circumstances. Source: editor.js, line 210 function engine( [engine]) -&gt; wcPlay Gets, or Sets the wcPlay engine that this renderer will render. Parameters: Name Type Argument Description engine wcPlay &lt;optional&gt; If supplied, will assign a new wcPlay engine to render. Source: editor.js, line 222 Returns: - The current wcPlay engine. Type wcPlay function focus(nodes) Scrolls the canvas view until a given set of nodes are within view. Parameters: Name Type Description nodes wcNode A list of nodes to focus the view on. Source: editor.js, line 279 function focusRect(rect) Scrolls the canvas view and centers on a given bounding rectangle. Parameters: Name Type Description rect wcPlayEditor~Rect The rectangle to focus on. Source: editor.js, line 304 function isModified() -&gt; Boolean Retrieves whether unsaved changes exist in the current script. Source: editor.js, line 198 Returns: Type Boolean function menu() -&gt; wcMenu Retrieves the current modified state of the editor. /** Retrieves the menu instance. Source: editor.js, line 257 Returns: Type wcMenu function notifyPaletteNodes(func, args) Sends a custom notification event to all nodes. Parameters: Name Type Description func String The node function to call. args Array.&lt;Object&gt; A list of arguments to forward into the function call. Source: editor.js, line 322 function onBeforeImport(func) -&gt; Boolean Binds an event handler for when we are about to save our script. Parameters: Name Type Description func function Assigns the function to handle this event. Source: editor.js, line 420 Returns: - Success or failure. Type Boolean function onBeforeLoad(func) -&gt; Boolean Binds an event handler for when we are about to save our script. Parameters: Name Type Description func function Assigns the function to handle this event. Source: editor.js, line 388 Returns: - Success or failure. Type Boolean function onBeforeSave(func) -&gt; Boolean Binds an event handler for when we are about to save our script. Parameters: Name Type Description func function Assigns the function to handle this event. Source: editor.js, line 356 Returns: - Success or failure. Type Boolean function onBeginUndoGroup(description) Event that is called to begin an undo manager group operation. Parameters: Name Type Description description String The description of the undo event. Source: editor.js, line 452 function onDisconnectEntryChains(node, linkName) Disconnects all chains attached to a node's entry link. Parameters: Name Type Description node wcNode The node to disconnect from. linkName String The name of the link. Source: editor.js, line 492 function onDisconnectExitChains(node, linkName) Disconnects all chains attached to a node's exit link. Parameters: Name Type Description node wcNode The node to disconnect from. linkName String The name of the link. Source: editor.js, line 526 function onDisconnectInputChains(node, linkName) Disconnects all chains attached to a node's input link. Parameters: Name Type Description node wcNode The node to disconnect from. linkName String The name of the link. Source: editor.js, line 560 function onDisconnectOutputChains(node, linkName) Disconnects all chains attached to a node's output link. Parameters: Name Type Description node wcNode The node to disconnect from. linkName String The name of the link. Source: editor.js, line 594 function onEndUndoGroup() Event that is called to end an undo manager group operation. Source: editor.js, line 461 function onImported(func) -&gt; Boolean Binds an event handler for when we are about to save our script. Parameters: Name Type Description func function Assigns the function to handle this event. Source: editor.js, line 436 Returns: - Success or failure. Type Boolean function onLoaded(func) -&gt; Boolean Binds an event handler for when we are about to save our script. Parameters: Name Type Description func function Assigns the function to handle this event. Source: editor.js, line 404 Returns: - Success or failure. Type Boolean function onResized() Event that is called when the container view is resized. Source: editor.js, line 469 function onSaved(func) -&gt; Boolean Binds an event handler for when we are about to save our script. Parameters: Name Type Description func function Assigns the function to handle this event. Source: editor.js, line 372 Returns: - Success or failure. Type Boolean function triggerEvent(eventName) Triggers a previously bound event handler. Parameters: Name Type Description eventName String The name of the event to trigger. Source: editor.js, line 343 &lt;inner&gt; function MenuDescriptionFunc(editor, engine) A callback that retrieves the description string for a menu option. Parameters: Name Type Description editor wcPlayEditor The instance of the editor invoking the menu option. engine wcPlay The instance of the script engine being viewed by the editor. Source: editor.jsdoc, line 61 &lt;inner&gt; function MenuIconFunc(editor, engine) A callback that retrieves the icon class for a menu option. Parameters: Name Type Description editor wcPlayEditor The instance of the editor invoking the menu option. engine wcPlay The instance of the script engine being viewed by the editor. Source: editor.jsdoc, line 54 Type Definitions typedef var BoundingData Bounding information for links on a node. Type: Object Properties: Name Type Description rect wcPlayEditor~Rect The bounding rectangle. point wcPlay~Coordinates The anchor point where lines will attach to this link. name String The name of the bounded object. Source: editor.jsdoc, line 25 typedef var CategoryOptions Category display options. Type: Object Properties: Name Type Description items Array.&lt;String&gt; A list of categories to show in the palette. isBlacklist Boolean If true, the items list will be treated as a blacklist of categories to hide. Source: editor.jsdoc, line 9 typedef var DrawNodeData Data associated with a drawn node. Type: Object Properties: Name Type Description node wcNode The node instance. rect wcPlayEditor~Rect Bounding rectangle of the node (not including links that stick out). entryBounds Array.&lt;wcPlayEditor~BoundingData&gt; Bounding data of entry links. exitBounds Array.&lt;wcPlayEditor~BoundingData&gt; Bounding data of exit links. inputBounds Array.&lt;wcPlayEditor~BoundingData&gt; Bounding data of property input links. outputBounds Array.&lt;wcPlayEditor~BoundingData&gt; Bounding data of property output links. valueBounds Array.&lt;wcPlayEditor~BoundingData&gt; Bounding data of property value text. initialBounds Array.&lt;wcPlayEditor~BoundingData&gt; Bounding data of property initial value text. Source: editor.jsdoc, line 33 typedef var MenuOptions Custom options for a menu option. Type: Object Properties: Name Type Argument Description icon String | wcPlayEditor~MenuIconFunc &lt;optional&gt; A classname to apply as an icon for the option. If this is a function, it will be called during the update call and should return the icon class. description|wcPlayEditor~MenuDescriptionFunc String &lt;optional&gt; The description to show as a tooltip for this option. itemIndex Number &lt;optional&gt; An insertion index to insert the item within the menu category, default is to append to the end. categoryIndex Number &lt;optional&gt; If this creates a new category, it will be inserted at this index in the top level menu. toolbarIndex Boolean &lt;optional&gt; If supplied, creates a toolbar button for this option and inserts it in the tab bar at the specified index. -1 will append it to the end. hotkeys String &lt;optional&gt; A string that describes hotkeys for your control, the format is 'Ctrl+Z' or 'Alt+Shift+L,Shift+L' for multiple. condition function &lt;optional&gt; A function to call during the update to determine if the menu option should be enabled or disabled. Return false to disable the option. Source: editor.jsdoc, line 68 typedef function OnMenuActivated(event, editor, engine) On click handler for menu and toolbar options. Parameters: Name Type Description event Object The mouse click event object. editor wcPlayEditor The instance of the editor invoking the menu option. engine wcPlay The instance of the script engine being viewed by the editor. Source: editor.jsdoc, line 46 typedef var Options Custom options available when constructing a new wcPlay instance. Type: Object Properties: Name Type Argument Default Description readOnly Boolean &lt;optional&gt; false If true, the script will not be editable. playable Boolean &lt;optional&gt; true Whether the script can be played using the live debugger. category wcPlayEditor~CategoryOptions &lt;optional&gt; Options that determine what categories appear in the palette. By default, all categories are visible. Source: editor.jsdoc, line 1 typedef var Rect The 2D bounds of a rectangle. Type: Object Properties: Name Type Description top Number left Number width Number height Number Source: editor.jsdoc, line 16  Search results Close "},"tutorial-1.0.html":{"id":"tutorial-1.0.html","title":"Tutorial: Getting Started","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Getting Started wcPlay (Web Cabin Play) is a node based visual scripting tool for the web! Allow users to script their own content for your application in a way that does not require them to code! Users place nodes into their script and then visually connect them together. wcPlay also comes with a built in live debugger, so users can visually inspect and change their scripts while it is running! wcPlay is developed and maintained by Jeff Houde (lochemage@webcabin.org). DependenciesBegin by including the necessary dependencies: JQuery Library version 1.11.1 http://jquery.com/ Font-Awesome http://fortawesome.github.io/Font-Awesome/ You can also include these optional dependencies for added features: wcUndoManager https://github.com/WebCabin/wcUndoManager FileSaver.js https://github.com/eligrey/FileSaver.js/ InstallationYou can use bower for easy installation using the Node Package Manager {@lang bash}npm install -g bower bower install wcPlayOnce installed, all of the source files will now be located in the bower_components folder and ready to link into your project. You can also download the source files and link them directly. Basic Implementation{@lang xml}&lt;!-- Include external dependencies --&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;bower_components/font-awesome/css/font-awesome.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;bower_components/wcMenu/Build/wcMenu.min.css&quot;/&gt; &lt;script src=&quot;bower_components/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;bower_components/FileSaver/FileSaver.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;bower_components/wcUndoManager/wcUndoManager.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;bower_components/wcMenu/Build/wcMenu.min.js&quot;&gt;&lt;/script&gt; &lt;!-- Include the Core wcPlay Engine --&gt; &lt;script src=&quot;bower_components/wcPlay/Build/wcPlay.min.js&quot;&gt;&lt;/script&gt; &lt;!-- Include the optional set of common generic node types --&gt; &lt;script src=&quot;bower_components/wcPlay/Build/wcPlayNodes.min.js&quot;&gt;&lt;/script&gt; &lt;!-- Include wcPlay editor tools --&gt; &lt;script src=&quot;bower_components/wcPlay/Build/wcPlayEditor.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;bower_components/wcPlay/Build/wcPlayEditor.min.css&quot;/&gt; Once the proper files have been included, you can create as many instances of the wcPlay engine as you need. Each one can be loaded with their own script: var myScript = new wcPlay(); var myScriptFileData = '...'; // Fill this with the string contents of a previously saved script. myScript.load(myScriptFileData); myScript.start();By itself, the wcPlay engine has no visual component for the user to view or edit the script with. To open a wcPlay script in the editor tool, simply create an instance of the editor tool and attach it to the DOM element container where your editor will be shown: var myEditor = new wcPlayEditor(domElem);Once you have an editor, you will need to tie it to an instance of wcPlay so you can edit its script: myEditor.engine(myScript); Continue to the Node Anatomy tutorial.  Search results Close "},"tutorial-2.0.html":{"id":"tutorial-2.0.html","title":"Tutorial: Node Anatomy","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Node Anatomy The most important part of wcPlay's node based scripting system, is the node! So let's dig into how they work, and how you will be interacting with them. Lets start with an extreme closeup of a node: Title AreaThe node type is the large bold text label near the top of the node. Any custom Title name will appear between the parenthesis '()' block, you can click on this to change it at any time. Further to the right of the title name is the information detail button, clicking on this will show a dialog that further explains what the node does. PropertiesProperties make up the center area of the node. Each property takes up a row, and are made up of three columns; their name, their current (or volatile) value, and their initial (or default) value. The current value is what the script uses throughout execution and is constantly changing, while the initial values are applied to the current value on startup and are the values recorded in your script file when you save it. ChainingChains determine the flow of your script as they connect nodes together into sequences. They are the curved lines that make a connection between two links. There are two types of chains, flow and property. Flow ChainsFlow chains make up the overall flow of your script, they are responsible for activating a new node and then continueing to the next node, or nodes, in a sequence. Conditions throughout the chain path will often cause it to redirect to alternate routes. A node connects to flow chains through their link connectors on their top and bottom. The Entry links on top will activate the node and cause it to perform its operation, while the Exit links on the bottom are activated when the node has finished a task. The example node above has four Entry links, 'add', 'sub', 'mul', and 'div'. It also has a single Exit link 'out'. The operation it does depends on which Entry link was activated, but only a single Exit link will activate once that operation is finished. Property ChainsProperty chains handle all of the information traffic between nodes by passing data from one to another. Data always passes from the Output link on the right side of a node to the Input link on the left side. In the example above, an operation is done between property 'valueA' and property 'valueB', and then copied into the property 'result'. When the result has been assigned its new value, it will activate its output link to send that new value to all other properties attached to it, and so on. DebuggingFor debugging, each node comes with two toggle buttons that appear as squares on the left and right side of the title label. The left side enables debug logging, which will output messages to the browsers console whenever various parts of the node are activated. This can be a very useful tool for solving problems you may be having with your script. The right side toggles a breakpoint on your node, which causes the execution of the script to pause whenever that node is activated. More information about the breakpoint system can be found later in the tutorial. Return to the Getting Started tutorial.Continue to the Debugging tutorial.  Search results Close "},"tutorial-3.0.html":{"id":"tutorial-3.0.html","title":"Tutorial: Debugging","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Debugging Debugging is a very important aspect of developing. It allows the developer to closely inspect the actions of their script in order to ensure that it behaves correctly. Debug LogThe first method of debugging, is the console log system. By toggling debug logging on a node, any time a link or value is activated, a console message will appear in the browsers debugger. This is a useful feature as it doesn't interrupt the execution of your script, but it may become overwhelming with too many log messages. BreakpointThe breakpoint system is where wcPlay debugging really shines. By toggling a node's breakpoint on, any time that node becomes activated in your script, your script will automatically pause execution on that node and the editor will display that node in red. From here, you can step one update at a time to follow your scripts progress one node at a time. You can step the debugger with the icon on the toolbar or the spacebar key. Once you are finished debugging, or just want to continue running your script, press the icon or the enter key. Make sure to toggle off the breakpoint of the node unless you want it to pause again. Debug SteppingThe debug stepping process may seem a little confusing at first, but each step basically follows these rules: As soon as a node turns red, it has been activated, but not yet processed. A step of the debugger will execute the action of the node, which may change properties and activate Exit links. If properties are changed, those values are propagated through the property chain system until every property in that chain has processed. It is important that property values propagate first, as nodes next in the flow chain may need those values updated. Once all properties have been propagated, nodes activated through the flow chain will continue processing. Chains that split to multiple nodes, or multiple Entry links, will run in parallel to each other. Return to the Node Anatomy tutorial.Continue to the Custom Nodes tutorial.  Search results Close "},"tutorial-4.0.html":{"id":"tutorial-4.0.html","title":"Tutorial: Custom Nodes","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ Custom Nodes One important aspect of your script is the ability to have custom nodes. Not all scripts can solely rely on the core set of nodes provided for you by wcPlay. For this, custom nodes can be developed for use in your scripts. Custom nodes are written directly in JavaScript and included into your page via the &lt;script&gt; tag. wcNodeProcess.extend('wcNodeProcessDelay', 'Delay', 'Core', { /** * @class * Waits for a specified amount of time before continuing the flow chain.&lt;br&gt; * When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function. * * @constructor wcNodeProcessDelay * @param {String} parent - The parent object of this node. * @param {wcPlay~Coordinates} pos - The position of this node in the visual editor. */ init: function(parent, pos) { this._super(parent, pos); this.description(&quot;Waits for a specified amount of time before continuing the flow chain.&quot;); // Create the message property so we know what to output in the log. this.createProperty('milliseconds', wcPlay.PROPERTY.NUMBER, 1000, {description: &quot;The time delay, in milliseconds, to wait before firing the 'out' Exit link.&quot;}); }, /** * Event that is called when an entry link has been activated.&lt;br&gt; * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top. * @function wcNodeProcessDelay#onActivated * @param {String} name - The name of the entry link triggered. */ onActivated: function(name) { this._super(name); // Now set a timeout to wait for 'Milliseconds' amount of time. var delay = this.property('milliseconds'); // Start a timeout event using the node's built in timeout handler. this.setTimeout(function() { this.activateExit('out'); }, delay); }, }); Extending a Node ClassTo program your own node, use the extend method on any base node class. Base node classes are either wcNodeEntry, wcNodeProcess, or wcNodeStorage depending on what type of node you want to make. Entry nodes generally begin chains, they listen for specific events and activate themselves whenever those conditions pass. Process nodes make up the bulk of your script, these nodes are designed to perform an action whenever they are activated through an Entry link, and then continue the script by activating an Exit link. Storage nodes are very simply a node that just stores a property value. The extend method takes a number of parameters explained here. Setting up Properties and LinksOnce you have extended your new node class, you will want to implement the init method first, this is your constructor where all your Entry, Exit, and Property setup should be. By default, all nodes have an 'enabled' property, all Entry nodes have an 'out' Exit link, and all Process nodes have an 'in' Entry link and an 'out' Exit link. You should never remove the 'enabled' property, as doing so will permenently disable your node. However, the default Entry and Exit links can be removed via the wcNode.removeEntry and wcNode.removeExit methods. Overloading Event MethodsIn many cases, you will need to catch events as they happen on your node. For this, wcNode provides many event methods that you can overload. All event methods are prefixed with 'on' in their names, such as wcNode.onActivated. There are many more event hooks to use, to see a listing, view the documentation. Latent NodesIn cases where your node may take time to perform an action, a threading system is provided for you. This allows the script to keep track of any timeout, or latent, events being processed on a node so it may have a better sense of what nodes are active, as well as a method for cancelling node operations if necessary. There are a few ways to implement a latent node: The recommended method is shown in the example code above, it uses a special wcNode.setTimeout method in place of the global window.setTimeout. The reason this is recommended, is the actual timeout is handled internally so it can be paused, resumed, and even canceled by the script if necessary. This allows the live debugger to more accurately step a node by only a specified amount of time. Also provided is the wcNode.setInterval which should replace any call to the global window.setInterval. For AJAX requests, wcNode.ajax is provided as a wrapper for jQuery's AJAX functionality. Again, it is recommended that you run ajax commands through this method as it is better equipped for the live debugger. Alternatively, you can use the global window.setTimeout and window.setInterval functions, with a slight alteration. The resulting ID of the timer function should be sent to wcNode.beginThread when started, and again to wcNode.finishThread when the timed event is finished. Although wcPlay supports these, it is not recommended as the live debugger has limited control which will cause a less accurate debugging experience. The final method for implementing a latent node is through a custom cancellation function. This is the worst and most complicated way to do it, but is provided in those cases where it is absolutely necessary. To do this, perform your latent operation as normal, except you also need to provide a callback function that can be called to cancel, or ignore, the resulting event when it comes in. This won't help much during debugging, but it will allow the script to properly stop when necessary. Continuing the FlowIt is very important for nodes to continue the flow chain, it does not happen automatically. When your node has performed its task, it should then use the wcNode.activateExit method to activate one of its available Exit links. Note: There is currently a known bug with the debugger where it does not highlighting the nodes and links properly if you modify a property value after you have already activated an Exit link. As a work around, always activate Exit links last. Return to the Debugging tutorial.Continue to the FAQ tutorial.  Search results Close "},"tutorial-5.0.html":{"id":"tutorial-5.0.html","title":"Tutorial: FAQ","body":" Web Cabin Playv1.0.0 Classes wcNodewcNodeCompositewcNodeEntrywcNodeEntryCallRemotewcNodeEntryRemotewcNodeEntryStartwcNodeEntryUpdatewcNodeProcesswcNodeProcessAJAXwcNodeProcessAlertwcNodeProcessConsoleLogwcNodeProcessDelaywcNodeProcessOperationwcNodeProcessStrCatwcNodeStoragewcNodeStorageGlobalwcNodeStorageNumberwcNodeStorageStringwcNodeStorageTogglewcPlaywcPlayEditor Tutorials Getting StartedNode AnatomyDebuggingCustom NodesFAQ FAQ Q: TODOA: TODO Return to the Custom Nodes tutorial.  Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
